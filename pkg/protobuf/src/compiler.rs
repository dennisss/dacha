// Code for taking a parsed .proto file descriptor and performing code
// generation into Rust code.

use super::spec::*;

// TODO: Lets not forget to serialize and parse unknown fields as well.

/*
	Operations to support:
	- Non-repeated fields:
		- has_name() -> bool
	
	- Repeated fields:
		- name() -> &[T]
		- name_mut() -> &mut [T]
		- add_name([v: T]) -> &mut T
		- name_len()
		- clear_name()

	- Primitive fields:
		.set_name(v: T) -> ()
		.clear_name() -> ()
*/
/*
	It would generally be more efficient to maintain a bitvector containing 
*/

// google.protobuf.Descriptor.InnerMessage

// Given a field, support getting a statement for it's default 

/*
	Query for Z in x.y.J
	- Check for .x.y.J.Z
	- Check for .x.y.Z
	- Check for .x.Z
	- Check for 
*/

// Roughly similar to the descriptor database in the regular protobuf library
// Stores all parsed .proto files currently loaded
struct DescriptorDatabase {
	base_dir: String
}


enum ResolvedTypeDesc<'a> {
	Message(&'a Message),
	Enum(&'a Enum)
}

struct ResolvedType<'a> {
	// Name of the type in the currently being compiled source file.
	typename: String,
	desciptor: ResolvedTypeDesc<'a>
}

pub struct Compiler<'a> {
	// The current top level code string that we are building.
	outer: String,

	// Top level proto file descriptor that is being compiled
	proto: &'a Proto,

	// TODO: Will also need a DescriptorDatabase to look up items in other files
}

/*
	TODO:
	Things to validate about a proto file
	- All definitions at the same level have distinct names
	- Enum fields and message fields have have distinct names
	- All message fields have distinct numbers
*/


type Path<'a> = &'a[&'a str];

trait Resolvable {
	fn resolve(&self, path: Path) -> Option<ResolvedType>;
}

impl Resolvable for Message {
	fn resolve(&self, path: Path) -> Option<ResolvedType> {
		if path.len() >= 1 && path[0] == &self.name {
			if path.len() == 1 {
				Some(ResolvedType {
					typename: self.name.clone(),
					desciptor: ResolvedTypeDesc::Message(self)
				})
			} else {
				// Look for a type inside of the message with the current name.
				for item in &self.body {
					let inner = match item {
						MessageItem::Enum(e) =>  e.resolve(&path[1..]),
						MessageItem::Message(m) => m.resolve(&path[1..]),
						_ => None
					};

					// If we found it, prepend the name of the message.
					if let Some(mut t) = inner {
						t.typename = format!("{}_{}", self.name, t.typename);
						return Some(t);
					}
				}

				None
			}
		} else {
			None
		}
	}
}

impl Resolvable for Enum {
	fn resolve(&self, path: &[&str]) -> Option<ResolvedType> {
		if path.len() == 1 && path[0] == &self.name {
			Some(ResolvedType {
				typename: self.name.clone(),
				desciptor: ResolvedTypeDesc::Enum(self)
			})
		} else {
			None
		}
	}
}

impl Resolvable for Proto {
	fn resolve(&self, path: &[&str]) -> Option<ResolvedType> {
		for def in &self.definitions {
			let inner = match def {
				TopLevelDef::Enum(e) => e.resolve(&path),
				TopLevelDef::Message(m) => m.resolve(&path),
				_ => None
			};

			if inner.is_some() {
				return inner;
			}
		}

		None
	}
}

impl Compiler<'_> {

	pub fn compile(desc: &Proto) -> String {
		let mut c = Compiler { outer: String::new(), proto: desc };

		c.outer += "// AUTOGENERATED CODE\n\n";
		c.outer += "use protobuf::*;\n";
		c.outer += "use protobuf::wire::*;\n";
		c.outer += "use protobuf::spec::*;\n\n";

		// TODO: Eventually, this will become the package name
		let path = vec![];

		for def in &desc.definitions {
			let s = c.compile_topleveldef(def, &path);
			c.outer.push_str(&s);
		}

		c.outer
	}

	fn resolve(&self, name_str: &str, mut path: Path) -> Option<ResolvedType> {
		let name = name_str.split('.').collect::<Vec<_>>();
		if name[0] == "" {
			panic!("Absolute paths currently not supported");
		}

		loop {
			let mut fullname = Vec::from(path);
			fullname.extend_from_slice(&name);

			let t = self.proto.resolve(&fullname);
			if t.is_some() {
				return t;
			}

			if path.len() == 0 {
				break;
			}

			// For path 'x.y.z', try 'x.y' next time.
			path = &path[0..(path.len() - 1)];
		}

		None
	}

	fn compile_enum_field(&self, f: &EnumField) -> String {
		format!("\t{} = {},\n", f.name, f.num)
	}

	fn compile_enum(&self, e: &Enum, path: Path) -> String {
		// Because we can't put an enum inside of a struct in Rust, we instead
		// create a top level enum.
		// TODO: Need to consistently escape _'s in the original name.
		let fullname = format!("{}_{}", path.join("_"), e.name);

		let mut s = String::new();
		s += &format!("enum {} {{\n", fullname);
		for i in &e.body {
			match i {
				EnumBodyItem::Option(_) => {},
				EnumBodyItem::Field(f) => {
					s += &self.compile_enum_field(f);
				}
			}
		}
		s += "}\n";


		s += &format!("impl Enum for {} {{\n", fullname);
		s += "\tfn from_usize(v: usize) -> std::result::Result<Self, ()> {\n";
		s += "\t\tOk(match v {\n";
		for i in &e.body {
			match i {
				EnumBodyItem::Option(_) => {},
				EnumBodyItem::Field(f) => {
					s += &format!("\t\t\t{} => {}::{},\n", f.num, fullname, f.name);
				}
			}
		}
		s += "\t\t\t_ => { return Err(()); }\n\t\t})\n";
		s += "\t}\n}\n";

		s
	}

	fn compile_field_type(&self, typ: &FieldType, path: Path) -> String {
		String::from(match typ {
			FieldType::Double => "f64",
			FieldType::Float => "f32",
			FieldType::Int32 => "i32",
			FieldType::Int64 => "i64",
			FieldType::Uint32 => "u32",
			FieldType::Uint64 => "u64",
			FieldType::Sint32 => "i32",
			FieldType::Sint64 => "i64",
			FieldType::Fixed32 => "u32",
			FieldType::Fixed64 => "u64",
			FieldType::Sfixed32 => "i32",
			FieldType::Sfixed64 => "i64",
			FieldType::Bool => "bool",
			FieldType::String => "String",
			FieldType::Bytes => "BytesMut",
			// TODO: This must resolve the right module (and do any nesting conversions needed)
			// ^ There
			FieldType::Named(s) => {
				return self.resolve(&s, path).expect("Failed to resolve type").typename;
			}
		})
	}

	fn compile_field(&self, field: &Field, path: Path) -> String {
		let mut s = String::new();
		s += "\t";
		s += &field.name;
		s += ": ";

		let is_repeated = if field.label == Label::Repeated { true } else { false };
		if is_repeated {
			s += "Vec";
		} else {
			s += "Option"
		}
		s += "<";
		s += &self.compile_field_type(&field.typ, path);
		s += ">";
		s += ",\n";
		s
	}

	fn compile_message_item(&mut self, item: &MessageItem, path: Path) -> String {
		match item {
			MessageItem::Enum(e) => {
				self.outer.push_str(&self.compile_enum(e, path));
				String::new()
			},
			// MessageItem::Message(msg) => Self::compile_message(outer, msg),
			MessageItem::Field(f) => {
				let mut s = String::new();
				s += &self.compile_field(f, path);
				s	
			},
			_ => String::new()
		}
	}

	fn compile_message(&mut self, msg: &Message, path: Path) -> String {
		let mut inner_path = Vec::from(path);
		inner_path.push(&msg.name);

		let mut s = String::new();
		s += "#[derive(Clone, Default)]\n";
		s += &format!("pub struct {} {{\n", msg.name);
		for i in &msg.body {
			s += &self.compile_message_item(&i, &inner_path);
		}

		s += &format!("}}\nimpl {} {{\n", msg.name);
		for i in &msg.body {
			match i {
				MessageItem::Field(f) => {
					let is_repeated = f.label == Label::Repeated;
					let typ = self.compile_field_type(&f.typ, &inner_path);
					let is_primitive = if let FieldType::Named(_) = f.typ { false } else { true };

					// field()
					if is_repeated {
						s += &format!("\tpub fn {}(&self) -> &[{}] {{", f.name, typ);
						s += &format!(" &self.{}", f.name);
						s += " }\n";
					} else {
						s += &format!("\tpub fn {}(&self) -> &{} {{", f.name, typ);
						s += &format!(" &self.{} }}\n", f.name);
					}

					if is_repeated {
						// field_len()
						s += &format!("\tpub fn {}_len(&self) -> usize {{", f.name);
						s += &format!(" self.{}.len() }}\n", f.name);
					} else {
						// has_field() -> bool
						s += &format!("\tpub fn has_{}(&self) -> bool {{", f.name);
						s += &format!(" self.{}.is_some() }}\n", f.name);
					}

					if is_repeated {
						if is_primitive {
							// add_field(v: T) -> &mut T
							s += &format!("\tpub fn add_{}(&mut self, v: {}) -> &mut {} {{\n", f.name, typ, typ);
							s += &format!("\t\tself.{}.push(v); self.{}.last().unwrap() \n\t}}\n", f.name, f.name);
						} else {
							// add_field() -> &mut T
						}
					} else {
						if is_primitive {
							// set_field(v: T)
							s += &format!("\tpub fn set_{}(&mut self, v: {}) {{\n", f.name, typ);
							s += &format!("\t\tself.{} = v;\n\t}}\n", f.name);
						}

						// field_mut() -> &mut T
						s += &format!("\tpub fn {}_mut(&mut self) -> &mut {} {{", f.name, typ);
						s += &format!(" &mut self.{} }}\n", f.name);
					}

					// clear_field()
					s += &format!("\tpub fn clear_{}(&mut self) {{", f.name);
					if is_repeated {
						s += &format!(" self.{}.clear(); }}\n", f.name);
					} else {
						s += &format!(" self.{} = None; }}\n", f.name);
					}
				},
				_ => {}
			}
		}
		s += "}\n";

		s += &format!("impl Message for {} {{\n", msg.name);
		s += "\tfn parse(data: Bytes) -> Result<Self> {\n"; // TODO: Will be a result
		s += "\t\tlet msg = Self::default();\n";
		s += "\t\tlet fields = parse_wire(&data);\n";
		s += "\t\tfor f in &fields {\n";
		s += "\t\t\tmatch f.field_number {\n";
		
		for i in &msg.body {
			match i {
				MessageItem::Field(f) => {
					let is_repeated = f.label == Label::Repeated;

					let typename = match &f.typ {
						FieldType::Named(n) => {
							let typ = self.resolve(&n, &inner_path)
								.expect("Failed to resolve type");

							match &typ.desciptor {
								ResolvedTypeDesc::Enum(e) => "enum",
								ResolvedTypeDesc::Message(m) => "message"
							}
						},
						_ => f.typ.as_str()
					};

					let mut p = String::new(); 
					if is_repeated {
						p += &format!("msg.{}.push(f.parse_{}()?)", f.name, typename);
					} else {
						p += &format!("msg.{} = Some(f.parse_{}()?)", f.name, typename);
					}

					s += &format!("\t\t\t\t{} => {{ {} }},\n", f.num, p);
				}
				_ => {}
			}
		}

		// Basically match on the field number to determine why how to parse it
		s += "\t\t\t}\n";
		s += "\t\t}\n";
		s += "\t\tOk(msg)\n";
		s += "\t}\n";


		s += "\tfn serialize(&self) -> BytesMut {\n"; // TODO: Will be a result
		/*
			let mut data = vec![];
			if let Some(v) = self.my_field {
				WireField::serialize_f32(field_number, v, data);
			}
			for v in &self.repeated_field {

			}

		*/
		s += "\t}\n";

		// Implementing merge_from
		// extend_from_slice and assignment


		s += "}\n";
		s
	}

	fn compile_topleveldef(&mut self, def: &TopLevelDef, path: Path) -> String {
		match def {
			TopLevelDef::Message(m) => self.compile_message(&m, path),
			TopLevelDef::Enum(e) => self.compile_enum(e, path),
			_ => String::new()
		}
	}

}
