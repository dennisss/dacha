// Defines the 

syntax = "proto3";

message BinaryDescriptorLibrary {
    repeated Struct structs = 1;
    repeated EnumTypeProto enums = 2;
    repeated UnionTypeProto unions = 3;
}

message EnumTypeProto {
    string name = 1;
    // NOTE: Must resolve to an integer type
    TypeProto type = 2;

    Endian endian = 4;

    repeated EnumValue values = 3;

    // If true, then we will only allow parsing the values specified in 'values'.
    // You should set this on fields like a 'version' which if not supported 
    bool exhaustive = 5;
}

message EnumValue {
    string name = 1;
    uint64 value = 2;
    string comment = 3;
}

enum Endian {
    UNKNOWN = 0;
    LITTLE_ENDIAN = 1;
    BIG_ENDIAN = 2;
}

message Argument {
    string name = 1;
    TypeProto type = 2;
}

message Struct {
    string name = 1;
    Endian endian = 2;
    repeated FieldProto field = 3;

    repeated Argument argument = 4;
}

enum PrimitiveTypeProto {
    UNKNOWN = 0;
    U8 = 1;
    I8 = 2;
    U16 = 3;
    I16 = 4;
    U32 = 5;
    I32 = 6;
    U64 = 7;
    I64 = 8;
    FLOAT = 9;
    DOUBLE = 10;
    BOOL = 11;

    // TODO: Also include variable length integer types?
}

message BufferTypeProto {
    // TODO: I guess we could also have a buffer of buffers
    TypeProto element_type = 1;
    oneof size {
        uint64 fixed_length = 2;

        // NOTE: The length field must currently be in the same struct as the buffer.
        string length_field_name = 3;

        // If true, this buffer is terminated at the end of the input buffer.
        // If this field is followed by additional 
        bool end_terminated = 4;

        // Byte pattern which must appear for this buffer to end. This pattern is considered to be part of the buffer.
        // e.g. this can be used to indicate a null terminated buffer.
        bytes end_marker = 5;

        // Python-like expression defining the number of elements in this buffer.
        // Any symbols referenced in this are implicitly declared as 'arguments'
        string length = 6;
    }
}

message TypeProto {
    oneof type {
        PrimitiveTypeProto primitive = 1;

        // TODO: Possibly recursive?
        BufferTypeProto buffer = 2;

        // Should be the name of the struct
        string named = 3;

        StringTypeProto string = 4;
    }
}

message StringTypeProto {
    // Underlying buffer type which contains the string's data.
    BufferTypeProto buffer = 1;

    StringCharset charset = 2;
}

enum StringCharset {
    UNKNOWN = 0;
    UTF8 = 1;
}

message LayeredTypeProto {
    TypeProto inner = 1;
    TypeProto outer = 2;
}

message Value {
    repeated int64 int64_value = 1;
    repeated bool bool_value = 2;
    bytes bytes_value = 3;
}

message FieldProto {
    string name = 1;

    TypeProto type = 2;

    string comment = 3;

    // Width of this field in bits. Only applicable when the type is a primitive integer.
    // Non-zero values mean that this is set.
    //
    // NOTE: If this is not divisible by 8, then additional adjacent bit fields must be
    // present which sum up with this field to an even number of bytes with width.
    uint64 bit_width = 4;

    // Python-like expression defining how to produce the value of this field based on other
    // fields/arguments/constants.
    string value = 5;

    // TODO: Implement this.
    // If true, this field is a placeholder. It's only meant to advance forward the cursor in the
    // serialized form, but it's value won't be settable or readable.
    // bool skip = 6;

    // Path to a boolean field which determines whether or not this field is present in the binary
    // format. Will be represented as an Option<> type in Rust.
    //
    // NOTE: When a struct field with this field set is used as the length of a buffer, it will be
    // interpreted as having a value of 0  
    string presence = 7;

    // Arguments that are fed to the inner type while parsing/serializing.
    // TODO: Ensure that all types actually validate that these are used if given. 
    repeated FieldArgument argument = 9;

    // Name of another field which contains a byte array which should be used to parse this field.
    string stream = 10;
}

message FieldArgument {
    string name = 1; 
    string value = 2;
}

message UnionTypeProto {
    string name = 1;

    Endian endian = 5;

    repeated Argument argument = 2;

    string switch_value = 3;

    repeated UnionTypeCaseProto case = 4;
}

message UnionTypeCaseProto {
    string name = 1;

    TypeProto type = 2;

    string comment = 3;

    // The value which the 'switch_value' expression must equal to in order to select this case.
    string case_value = 4;

    // If true, then this is the default case that should be matched if none other is matched.
    // In this case case_value is ignored. If is_default is set, then this must be the last case in the list.
    bool is_default = 6;

    repeated FieldArgument argument = 5;
}
