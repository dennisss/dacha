syntax = "proto3";

package cluster;

import "pkg/builder/proto/bundle.proto";

// Complete definition for how a single worker should be started on some cluster node.
message WorkerSpec {
    // Name of the worker. This is assigned by the manager job.
    string name = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

    string cwd = 10;

    repeated string args = 3;

    repeated string env = 4;

    // Volumes to mount. Files will be accessible at '/volumes/{name}/...'
    message Volume {
        string name = 1;
        
        oneof source {
            
            // The volume will be initialized by creating a new read-writeable directory on the host.
            // - Whenever a worker is started on the same node with the same persistent_name, it will
            //   see the previously initialized directory and will also have read-write access to it. 
            // - Each persistent directory is exclusive to the current worker and not shareable across
            //   multiple workers.
            // - Having a persistnet directory will prevent this worker from being moved to another
            //   machine in the future.
            string persistent_name = 3;

            // Path to the build target for a bundle which should be built to derive the source for this volume.
            //
            // NOTE: This will only be present locally and is converted to the 'bundle' when running the 'cluster' command.  
            string build_target = 4;

            // The volume will be a read-only snapshot of the contents of the blob with this id.
            builder.BundleSpec bundle = 5;

            // TODO: Support temp dir
            
        }
        
        reserved 2;

        // TODO: Should support exclusive/reader/reader-writer locks to persistent volumes.
    }
    repeated Volume volumes = 2;

    enum RestartPolicy {
        // Equivalent to ALWAYS.
        UNKNOWN = 0;

        // If the worker exits on its own for whatever reason, we will not restart the worker until
        // it is updated.
        NEVER = 1;

        ON_FAILURE = 2;

        ALWAYS = 3;
    }
    RestartPolicy restart_policy = 5;

    // Entrypoints which other services can use for communicating with this worker.
    //
    // Reading the port number at runtime will be possible through an environment variable
    // named 'PORT_{NAME}' where the port name is concerned to all uppercase and '-' is replaced
    // with '_'.
    //
    // TODO: Switch to serializing this whole proto in the environment variable
    message Port {
        string name = 1;

        // What type of port this should be (e.g. TCP, UNIX, etc.)
        PortType type = 2;

        // Layered protocols supported by the server on this port.
        // This is mainly used to dynamically configure clients so that incompatible changes can be
        // made (e.g. switching from plaintext to TLS).
        repeated PortProtocol protocol = 3;

        // INTERNAL ONLY
        // The port number on the node to use if this is a TCP port.
        // Set by the Cluster Manager when assigning the worker to a node.
        uint32 number = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
    }
    repeated Port ports = 6;

    // INTERNAL ONLY
    // If true, then this worker will restart when the node is restarted without the need for
    // external intervention. By default, this is false, so workers disappear when a node restarts.
    //
    // This is set by the Cluster Manager for system workers that must survive a cluster cold-start
    // and any workers which can't be moved to another node (e.g. due to resources local to only one
    // node). If set by a user, then the worker will be rejected.
    bool persistent = 7 [(google.api.field_behavior) = OUTPUT_ONLY];

    // List of devices to mount into the container.
    repeated Device devices = 9;

    repeated string additional_groups = 8;

    // Prober used to periodically check if a worker doesn't need to be killed and restarted. 
    // (initially this is swapped out for the startup_probe)
    Probe liveness_probe = 11;

    // Probe used during worker startup to verify that it started ok and doesn't need to be restarted.
    //
    // If not set, will default to the liveness_probe.
    Probe startup_probe = 12;

    // Prober used to determine if a worker can accept requests on any of its ports.
    //
    // If not set, will default to the liveness probe.
    Probe readiness_probe = 13;

    Resources resources = 14;

    // TODO: Add labels?
}

message Resources {
    // CPU request/limit
    // Memory request/limit
}

// Specification for how to check the state of a worker.
//
// - Each prober will determine if a worker is in either a 'Success', 'Failure', or 'Unknown' state.
// - 'Unknown' is only  
message Probe {
    // Number of seconds we will wait after the worker's main process is started until we start
    // sending probing requests.
    uint32 initial_delay_secs = 1;

    // Time in-between attempts to probe the worker.
    uint32 interval_secs = 2;

    // Maximum amount of time a single probing request will wait for the worker to respond.
    uint32 attempt_timeout_secs = 3;

    // Number of consecutive success probes needed to consider the worker healthy.
    uint32 success_threshold = 4;

    // Number of consecutive failed probes needed to consider the worker unhealthy.
    uint32 failure_threshold = 5;

    // How probing should happen
    // If no method is defined, the prober will always consider the worker to be healthy.
    oneof method {
        HttpProbe http = 6;
    }
}

enum PortType {
    UNKNOWN = 0;
    TCP = 1;
}

enum PortProtocol {
    UNKNOWN = 0;
    HTTP = 1;
    TLS = 2;
    GRPC = 3;
}

message HttpProbe {
    // Name of the port to query.
    string port_name = 1;
    
    // Uri path to use for probing.
    string path = 2;
}


message USBSelector {
    uint32 vendor = 1;
    uint32 product = 2;
}

message DeviceSource {
    oneof source {
        // Path to a special device file on the host machine (e.g. /dev/i2c-1)
        //
        // This path may continue a wildcard ('*') to match multiple files (e.g. '/dev/ttyACM*')
        //
        // If no 'destination' is specified, this device will be mounted to the same path in
        // the container as on the host. 
        string raw = 1;

        // Selects a USB device connected to the host.
        //
        // When mounted to a destination path, the usbdevfs  
        //
        // When mounted without a 'destination' path, we will create:
        // - /sys/bus/usb/devices/3-3.5/
        // - /dev/bus/usb/001/004
        USBSelector usb = 2;
    }

    // Maximum number of devices to select if more than one matches the 
    uint32 limit = 3;
}

message Device {
    // How to find this device.
    DeviceSource source = 1;

    // Path in the container at which this device will be mounted.
    //
    // If the source matches multiple devices, then an arbitrary device will be picked to be
    // mapped to this destination.
    //
    // If not specified, then the default path for the 'source' will be used.
    string destination = 2;

    // If true, no other worker will be allowed to mount a device with the same source while it
    // is mounted on this device. If another worker has already mounted the device, then this
    // worker will fail to start.
    bool exclusive = 3;
}