// The file contains the format of the records stored in the source of truth metastore instance
// used by the entire cluster.

syntax = "proto3";

package cluster;

import "pkg/container/src/proto/task.proto";
import "pkg/container/src/proto/job.proto";
import "pkg/container/src/proto/blob.proto";
import "pkg/container/src/proto/node.proto";
import "third_party/google/src/proto/timestamp.proto";
import "pkg/builder/src/proto/bundle.proto";

// Stored at a singleton at the metastore key '/cluster/zone'
message ZoneMetadata {
    string name = 1;
}

/*
Restarting a node:
- Mark it as draining
- Suppose we drain a node because it is offline
    - If we re-assign tasks to another node and the old machine comes back online, we must prevent TaskMetadata contention by having each node check the 'assigned_node' field to verify that it is actually still the owner of a task
*/


// Information about a node attached to the cluster.
// Stored at the metastore key '/cluster/node/[node_id]'
message NodeMetadata {
    uint64 id = 1;

    // Address at which this node can be contacted including the port on which the control RPC
    // server is running.
    //
    // e.g. "10.0.0.102:10400"
    string address = 2;

    enum State {
        UNKNOWN = 0;
        
        // This is a brand new node this has just joined the cluster.
        // In this state, the node won't start/stop any tasks assigned to it.
        NEW = 1;

        // This is a regular node and will start any tasks newly assigned to it and stop any tasks
        // which aren't assigned to it in the metastore.
        ACTIVE = 2;
        
        DRAINING = 3;
        
        RESTARTING = 4;
    }
    State state = 3;

    // Last time this node started its runtime (e.g. after the last reboot).
    google.protobuf.Timestamp start_time = 4;

    //
    google.protobuf.Timestamp last_seen = 5;

    PortRange allocatable_port_range = 6;

    repeated uint32 allocated_ports = 7 [unordered_set = true];

    string zone = 8;

    // TODO: Enumerate capabilities, platform, etc.

    // TODO: When was the node added

    // TODO: Build time of the runtime
}

message JobMetadata {
    JobSpec spec = 1;

    // Monotonic counter which is increased each time the TaskSpec is changed.
    uint64 task_revision = 2;
}

// Defines the intent for a single instance of a Task which we want to run on some specific node.
message TaskMetadata {
    // Spec used to run this task.
    // This should be mostly the same as the spec in the JobSpec but also includes a resolved
    // 'name', port numbers, etc.
    //
    // REQUIRED
    TaskSpec spec = 1;

    // Id of the node which this task is running on.
    //
    // NOTE: This field is immutable. Moving a task to another node requires creating a new name.
    //
    // REQUIRED
    uint64 assigned_node = 2;

    // If true, this task should be stopped by the node and not started again.
    //
    // Once drain == true, this TaskMetadata proto is guranteed to not change again and will be
    // deleted once the node markes the task is DONE in the TaskStateMetadata.
    //
    // OPTIONAL
    bool drain = 3;

    // Revision of this task.
    // When this is equal to the corresponding JobMetadata::task_revision, this task doesn't need
    // to be updated.
    uint64 revision = 4;
}

// Current high level progress of running a task specified in a corresponding TaskMetadata entry.
//
// While the TaskMetadata entries are updated by Manager jobs, this proto is updated by the Nodes.
// A Node must ONLY update the TaskStateMetadata when a TaskMetadata entry exists. 
//
// This is meant to be a TLDR of the current state of the task and very concise. Lower level
// details such as the # of restarts, etc. will be stored in local node storage.
//
// This has the following main use-cases:
// 1. Used by the Manager job to know when a task has been fully brought up or turned down in order
//    to allow more tasks to be added/deleted/updated.
// 2. Used by RPC clients to know if a task can be reached.
//
// TODO: Connections to the metastore should not depend on observing the readiness of the tasks.
message TaskStateMetadata {
    string task_name = 1;

    // Current state which the node 
    //
    // NOTE: This value can only be trusted if the NodeMetadata of the assigned node has a recent
    // last_seen time (indicating that the node hasn't died).
    enum ReportedState {
        UNKNOWN = 0;

        // The node is currently starting or stopping this task. It can't be reliably queried.
        UPDATING = 1;

        // This task is running on the assigned node and has passed readiness checks.
        // This is the only state in which it is ok for users to send traffic to this task.
        READY = 2;

        // The task isn't running and won't be re-started unless a new task revision is available.
        DONE = 3;
    }
    ReportedState state = 2;

    // The task revision at which the 'state' field is valid.
    //
    // NOTE: If a client notices that the TaskMetadata includes a new revision, but the TaskStateMetadata shows that the task is READY at an old revision, it should stop ending traffic under the expectation that it will be updated soon.
    uint64 task_revision = 3;
}

message BlobMetadata {
    builder.BlobSpec spec = 1;

    // List of the ids of all nodes which are known to have this blob.
    repeated BlobReplica replicas = 2;

    // Last time this blob was referenced in some registered job.
    // If this is empty, then it is actively in use.
    google.protobuf.Timestamp last_used = 3;
}

message BlobReplica {
    uint64 node_id = 1;
    bool uploaded = 2;
}

