syntax = "proto3";

message TaskSpec {
    string name = 1;

    repeated string args = 3;

    repeated string env = 4;

    // Volumes to mount. Files will be accessible at '/volumes/{name}/...'
    message Volume {
        string name = 1;
        
        oneof source {
            // The volume will be a read-only snapshot of the contents of the blob with this id.
            string blob_id = 2;
            
            // The volume will be initialized by creating a new read-writeable directory on the host.
            // Whenever a task is started on the same node with the same persistent_name, it will
            // see the previously initialized directory and will also have read-write access to it. 
            string persistent_name = 3;

            // Path to the build target for a bundle which should be built to derive the source for this volume.
            // NOTE: This will only be present locally.
            string build_target = 4;
        }
        
        // TODO: Should support exclusive/reader/reader-writer locks to persistent volumes.
    }
    repeated Volume volumes = 2;

    enum RestartPolicy {
        UNKNOWN = 0;
        NEVER = 1;
        ON_FAILURE = 2;
        ALWAYS = 3;
    }
    RestartPolicy restart_policy = 5;

    // Reading the port number at runtime will be possible through an environment variable
    // named 'PORT_{NAME}' where the port name is concerned to all uppercase and '-' is replaced
    // with '_'.
    message Port {
        string name = 1;

        // Set by the container manager.
        int32 number = 2;
    }
    repeated Port ports = 6;

    // If true, then this task will restart when the node is restarted without the need for
    // external intervention. By default, this is false, so tasks disappear when a node restarts.
    bool persistent = 7;

    // List of devices to mount into the container.
    repeated Device devices = 9;

    repeated string additional_groups = 8;

    // TODO: Add labels?
}

message USBSelector {
    uint32 vendor = 1;
    uint32 product = 2;
}

message DeviceSource {
    oneof source {
        // Path to a special device file on the host machine (e.g. /dev/i2c-1)
        //
        // This path may continue a wildcard ('*') to match multiple files (e.g. '/dev/ttyACM*')
        //
        // If no 'destination' is specified, this device will be mounted to the same path in
        // the container as on the host. 
        string raw = 1;

        // Selects a USB device connected to the host.
        //
        // When mounted to a destination path, the usbdevfs  
        //
        // When mounted without a 'destination' path, we will create:
        // - /sys/bus/usb/devices/3-3.5/
        // - /dev/bus/usb/001/004
        USBSelector usb = 2;
    }

    // Maximum number of devices to select if more than one matches the 
    uint32 limit = 3;
}

message Device {
    // How to find this device.
    DeviceSource source = 1;

    // Path in the container at which this device will be mounted.
    //
    // If the source matches multiple devices, then an arbitrary device will be picked to be
    // mapped to this destination.
    //
    // If not specified, then the default path for the 'source' will be used.
    string destination = 2;

    // If true, no other task will be allowed to mount a device with the same source while it
    // is mounted on this device. If another task has already mounted the device, then this
    // task will fail to start.
    bool exclusive = 3;
}