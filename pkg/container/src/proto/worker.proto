syntax = "proto3";

package cluster;

import "pkg/builder/src/proto/bundle.proto";

message WorkerSpec {
    // Name of the worker. This is assigned by the manager job.
    string name = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

    string cwd = 10;

    repeated string args = 3;

    repeated string env = 4;

    // Volumes to mount. Files will be accessible at '/volumes/{name}/...'
    message Volume {
        string name = 1;
        
        oneof source {
            
            // The volume will be initialized by creating a new read-writeable directory on the host.
            // - Whenever a worker is started on the same node with the same persistent_name, it will
            //   see the previously initialized directory and will also have read-write access to it. 
            // - Each persistent directory is exclusive to the current worker and not shareable across
            //   multiple workers.
            // - Having a persistnet directory will prevent this worker from being moved to another
            //   machine in the future.
            string persistent_name = 3;

            // Path to the build target for a bundle which should be built to derive the source for this volume.
            // NOTE: This will only be present locally.
            string build_target = 4;

            // The volume will be a read-only snapshot of the contents of the blob with this id.
            builder.BundleSpec bundle = 5;

            // TODO: Support temp dir
            
        }
        
        reserved 2;

        // TODO: Should support exclusive/reader/reader-writer locks to persistent volumes.
    }
    repeated Volume volumes = 2;

    enum RestartPolicy {
        // Equivalent to ALWAYS.
        UNKNOWN = 0;

        // When we 
        NEVER = 1;
        ON_FAILURE = 2;
        ALWAYS = 3;
    }
    RestartPolicy restart_policy = 5;

    // Reading the port number at runtime will be possible through an environment variable
    // named 'PORT_{NAME}' where the port name is concerned to all uppercase and '-' is replaced
    // with '_'.
    message Port {
        string name = 1;

        // INTERNAL ONLY
        // The port number on the node to use. Set by the Cluster Manager when assigning the worker
        // to a node.
        uint32 number = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
    }
    repeated Port ports = 6;

    // INTERNAL ONLY
    // If true, then this worker will restart when the node is restarted without the need for
    // external intervention. By default, this is false, so workers disappear when a node restarts.
    //
    // This is set by the Cluster Manager for system workers that must survive a cluster cold-start
    // and any workers which can't be moved to another node (e.g. due to resources local to only one
    // node). If set by a user, then the worker will be rejected.
    bool persistent = 7 [(google.api.field_behavior) = OUTPUT_ONLY];

    // List of devices to mount into the container.
    repeated Device devices = 9;

    repeated string additional_groups = 8;

    Probe readiness_probe = 11;

    // TODO: Add labels?
}

message Probe {
    // Time in-between attempts to probe the worker.
    uint32 interval_secs = 1;



    // Number of seconds 
    // uint32 initial_delay_secs = 1;
}

message HttpProbe {
    string port_name = 1;
    string path = 2;
}


message USBSelector {
    uint32 vendor = 1;
    uint32 product = 2;
}

message DeviceSource {
    oneof source {
        // Path to a special device file on the host machine (e.g. /dev/i2c-1)
        //
        // This path may continue a wildcard ('*') to match multiple files (e.g. '/dev/ttyACM*')
        //
        // If no 'destination' is specified, this device will be mounted to the same path in
        // the container as on the host. 
        string raw = 1;

        // Selects a USB device connected to the host.
        //
        // When mounted to a destination path, the usbdevfs  
        //
        // When mounted without a 'destination' path, we will create:
        // - /sys/bus/usb/devices/3-3.5/
        // - /dev/bus/usb/001/004
        USBSelector usb = 2;
    }

    // Maximum number of devices to select if more than one matches the 
    uint32 limit = 3;
}

message Device {
    // How to find this device.
    DeviceSource source = 1;

    // Path in the container at which this device will be mounted.
    //
    // If the source matches multiple devices, then an arbitrary device will be picked to be
    // mapped to this destination.
    //
    // If not specified, then the default path for the 'source' will be used.
    string destination = 2;

    // If true, no other worker will be allowed to mount a device with the same source while it
    // is mounted on this device. If another worker has already mounted the device, then this
    // worker will fail to start.
    bool exclusive = 3;
}