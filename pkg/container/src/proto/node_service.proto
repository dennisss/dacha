syntax = "proto3";

package cluster;

import "pkg/container/src/proto/config.proto";
import "pkg/container/src/proto/log.proto";
import "pkg/container/src/proto/task.proto";
import "pkg/container/src/proto/meta.proto";
import "third_party/google/src/proto/empty.proto";

message ListTasksRequest {
    // If present, we will only return data for the container with this id.
    // An empty list will be returned if no such container exists. 
    string container_id = 1;
}

message ListTasksResponse {
    repeated TaskProto tasks = 1;
}

message TaskProto {
    TaskSpec spec = 1;
    TaskStateProto state = 2;
    ContainerMetadata container = 3;
    bool pending_update = 4;
}

enum TaskStateProto {
    UNKOWN = 0;
    PENDING = 1;
    RUNNING = 2;
    STOPPING = 3;
    FORCE_STOPPING = 4;
    RESTART_BACKOFF = 5;
    TERMINAL = 6;
}

message StartTaskRequest {
    TaskSpec task_spec = 1;
}

message StartTaskResponse {

}

message RestartTaskRequest {

}

message RestartTaskResponse {

}


message LogRequest {
    string task_name = 1;
    uint64 start_offset = 2;

    // TODO: Consider supporting things like time/text filters?
}

message WriteInputRequest {

    string task_name = 1;

    bytes data = 2;
}

message ReplicateBlobRequest {
    string blob_id = 1;
}

service ContainerNode {

    // TODO: How do we ensure that a node never switches places with another node ip. (then the manager may be sending the wrong requests to the wrong server if data is stale). So we need every request to be richly authenticated with a host name.
    // ^ RPC HTTP servers should minimally reject any request coming to the wrong host name.
    rpc Identity (google.protobuf.Empty) returns (NodeMetadata);

    // Enumerates all tasks present on this node.
    rpc ListTasks (ListTasksRequest) returns (ListTasksResponse);

    /// Starts running a task on this node using the given spec.
    ///
    /// - If a task with the same name already exists on this node, it will stopped and replaced
    ///   with one using the new spec.
    /// - This will return as soon as the node has durably ingested the request. The actual
    ///   starting/stopping of the task will occur asynchronously.
    ///
    /// TODO: Eventually also need an API to delete a task and know for sure this node will no longer try to start it.
    rpc StartTask (StartTaskRequest) returns (StartTaskResponse);

    // // Triggers the stopping of a task.
    // //
    // // This executes asynchronously.
    // // - If the task is running, we will try to gracefully stop it
    // // - If the task is not running, we will stop trying to backoff, etc. and enter a Terminal state.
    // // - If 
    // //
    // rpc StopTask (StopTaskRequest) returns (StopTaskResponse);

    // /// Triggers the stopping of an existing task followed by immediately starting it again.
    // ///
    // /// If the task is currently in backoff, the backoff will be reset.  
    // rpc RestartTask (RestartTaskRequest) returns (RestartTaskResponse);

    // // Removes all data associated with a given task from this node.
    // //
    // // This includes:
    // // - task spec
    // // - stdout/stderr logs.
    // // - information on past attempts
    // //
    // // By default all the above data is retained even after a task is stopped to allow it to be
    // // backed up to a remote logging service before being deleted.
    // //
    // // NOTE: The task must first be in a Terminal state before it can be deleted.
    // rpc DeleteTask (DeleteTaskRequest) returns (DeleteTaskResponse); 

    rpc WriteInput (stream WriteInputRequest) returns (google.protobuf.Empty);

    /// Asks the node to fetch and locally store the blob with the given id.
    /// THis is called by the manager to ensure blobs are sufficiently mirrored.
    rpc ReplicateBlob (ReplicateBlobRequest) returns (google.protobuf.Empty);

    // rpc ExecProcess (ExecProcess)

    // Streams back log entries for a single task.
    rpc GetLogs(LogRequest) returns (stream LogEntry);
}
