use std::pin::Pin;

use common::bytes::Bytes;
use common::errors::*;

use crate::status::*;
use crate::request::*;
use crate::response::*;

#[async_trait]
pub trait Service: Send + Sync {
    /// Name of the service. 
    fn service_name(&self) -> &'static str;

    /// Names of all methods which this service can accept. (used for reflection).
    fn method_names(&self) -> &'static [&'static str];
    
    async fn call(
        &self,
        method_name: &str,
        request_context: ServerRequestContext,
        request_bytes: Bytes,
    ) -> Result<(ServerResponseContext, StatusResult<Bytes>)>;
}

/*
std::future::Future<Output = std::result::Result<ServerUnaryResponse<_>, common::errors::Error>>`,

std::future::Future<Output = std::result::Result<ServerUnaryResponse<AddResponse>, common::errors::Error>> + std::marker::Send

*/

/// Used by autogenerated 
pub async fn Service_call_unary_impl<
    'a, 
    T: 'static + ?Sized,
    Req: protobuf::Message, Res: protobuf::Message,
    Fut: std::future::Future<Output=Result<ServerUnaryResponse<Res>>> + 'a,
    F: Fn(&'a T, ServerRequest<Req>) -> Fut
> (
    inst: &'a T,
    f: &F,
    request_context: ServerRequestContext,
    request_bytes: Bytes
) -> Result<(ServerResponseContext, StatusResult<Bytes>)> {

    let request = Req::parse(request_bytes)?;

    let response = f(inst, ServerRequest {
        context: request_context,
        value: request
    }).await?;

    let response_context = response.context;
    let response_bytes = match response.result {
        Ok(res) => Ok(res.serialize()?.into()),
        Err(e) => Err(e)
    };

    Ok((response_context, response_bytes))
}