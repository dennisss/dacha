use common::errors::*;
use std::collections::HashMap;
use std::convert::TryFrom;

const UNDEF: u16 = 0xffff;

/// Mapping from T.61 8-bit codes to Unicode code points.
/// https://en.wikipedia.org/wiki/ITU_T.61
/// The 8-bit code is the index into this array.
const T61_TO_UNICODE: [u16; 256] = [
    // '0_'
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B,
    0x000C, 0x000D, 0x000E, 0x000F, // '1_'
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A, 0x001B,
    0x001C, 0x001D, 0x001E, 0x001F, // '2_'
    0x0020, 0x0021, 0x0022, UNDEF, UNDEF, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B,
    0x002C, 0x002D, 0x002E, 0x002F, // '3_'
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B,
    0x003C, 0x003D, 0x003E, 0x003F, // '4_'
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B,
    0x004C, 0x004D, 0x004E, 0x004F, // '5_'
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B,
    UNDEF, 0x005D, UNDEF, 0x005F, // '6_'
    UNDEF, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B,
    0x006C, 0x006D, 0x006E, 0x006F, // '7_'
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, UNDEF,
    0x007C, UNDEF, UNDEF, 0x007F, // '8_'
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, // '9_'
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097, 0x0098, 0x0099, 0x009A, 0x009B,
    0x009C, 0x009D, 0x009E, 0x009F, // 'A_'
    0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x0024, 0x00A5, 0x0023, 0x00A7, 0x00A4, UNDEF, UNDEF, 0x00AB,
    UNDEF, UNDEF, UNDEF, UNDEF, // 'B_'
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00D7, 0x00B5, 0x00B6, 0x00B7, 0x00F7, UNDEF, UNDEF, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0x00BF, // 'C_'
    UNDEF, 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0306, 0x0307, 0x0308, UNDEF, 0x030A, 0x0327,
    0x0332, 0x030B, 0x0328, 0x030C, // 'D_'
    UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF,
    UNDEF, UNDEF, UNDEF, // 'E_'
    0x2126, 0x00C6, 0x00D0, 0x00AA, 0x0126, UNDEF, 0x0132, 0x013F, 0x0141, 0x00D8, 0x0152, 0x00BA,
    0x00DE, 0x0166, 0x014A, 0x0149, // 'F_'
    0x0138, 0x00E6, 0x0111, 0x00F0, 0x0127, 0x0131, 0x0133, 0x0140, 0x0142, 0x00F8, 0x0153, 0x00DF,
    0x00FE, 0x0167, 0x014B, UNDEF,
];

lazy_static! {
    pub static ref UNICODE_TO_T61: HashMap<u16, u8> = {
        let mut map = HashMap::new();
        for i in 0..T61_TO_UNICODE.len() {
            let v = T61_TO_UNICODE[i];
            if v != UNDEF {
                map.insert(v, i as u8);
            }
        }
        map
    };
}

pub fn t61_parse(data: &[u8]) -> Result<String> {
    let mut out = String::new();
    out.reserve(data.len());

    for b in data {
        let c = T61_TO_UNICODE[*b as usize];
        if c == UNDEF {
            return Err(err_msg("Character undefined in T61"));
        }

        out.push(char::try_from(c as u32).unwrap());
    }

    Ok(out)
}

pub fn t61_serialize(s: &str) -> Result<Vec<u8>> {
    let mut out = vec![];
    out.reserve(s.len());

    for c in s.chars() {
        if (c as usize) > 0xffff {
            return Err(err_msg("Char outside u16 range"));
        }
        if let Some(b) = UNICODE_TO_T61.get(&(c as u16)) {
            out.push(*b);
        } else {
            return Err(err_msg("Char outside T61 alphabet."));
        }
    }

    Ok(out)
}
