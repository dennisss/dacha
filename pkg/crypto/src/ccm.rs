// Implementation of the AEAD CCM cipher as described in:
// https://datatracker.ietf.org/doc/html/rfc3610
//
// NOTE: Currently only fixed block sizes are supported.

use core::result::Result;

use common::ceil_div;

use crate::constant_eq;
use crate::utils::xor_inplace;

/// Number of bytes in an AES-128 key.
pub const KEY_SIZE: usize = 16;

const BLOCK_SIZE: usize = 16; // 128-bit blocks

/// A buffer for encrypting blocks with some cipher.
///
/// This object should consist of a 'plaintext' block buffer to be filled by the
/// user with the unencrypted block and an indepedent 'ciphertext' block buffer
/// that will continue the encrypted form of the 'plaintext' buffer upon
/// request.
pub trait BlockCipherBuffer {
    fn plaintext(&self) -> &[u8; BLOCK_SIZE];

    fn plaintext_mut(&mut self) -> &mut [u8; BLOCK_SIZE];

    fn ciphertext(&self) -> &[u8; BLOCK_SIZE];

    fn plaintext_mut_ciphertext(&mut self) -> (&mut [u8; BLOCK_SIZE], &[u8; BLOCK_SIZE]);

    /// Should encrypt the plaintext buffer writing the result into the internal
    /// ciphertext buffer.
    ///
    /// MUST NOT modify the plaintext buffer.
    fn encrypt(&mut self);
}

pub struct CCM<'a, B> {
    block: B,
    tag_size: usize,
    length_size: usize,
    nonce: &'a [u8],
}

impl<'a, B: BlockCipherBuffer> CCM<'a, B> {
    ///
    /// Arguments:
    /// - block:
    /// - tag_size: Number of bytes used to store the message authentication
    ///   tag.
    /// - length_size: Number of bytes used to represent the message length.
    /// - nonce:
    pub fn new(block: B, tag_size: usize, length_size: usize, nonce: &'a [u8]) -> Self {
        let nonce_size = 15 - length_size;
        assert_eq!(nonce_size, nonce.len());

        Self {
            block,
            tag_size,
            length_size,
            nonce,
        }
    }

    /// Performs in-place encryption of the given message.
    ///
    /// Arguments:
    /// - message: A buffer of size plaintext_length + tag_size. The final
    ///   tag_size bytes can be initially to any value.
    /// - additional_data: Additional data which will be considered while making
    ///   the CBC-MAC.
    pub fn encrypt_inplace(&mut self, message: &mut [u8], additional_data: &[u8]) {
        assert!(message.len() >= self.tag_size);

        let (plaintext, tag) = message.split_at_mut(message.len() - self.tag_size);

        self.compute_cbc_mac(plaintext, additional_data, tag);

        self.apply_ctr_mode(plaintext, tag);
    }

    /// Performs in-place decryption of the given message.
    ///
    /// Arguments:
    /// - message: The buffer consisting of an encrypted plaintext + a tag. This
    ///   is also the data generated by encrypt_inplace.
    ///
    /// Returns: If the MIC is valid, returns a pointer to the plaintext part of
    /// the buffer else returns an error.
    pub fn decrypt_inplace<'b>(
        &mut self,
        message: &'a mut [u8],
        additional_data: &[u8],
    ) -> Result<&'a [u8], ()> {
        if message.len() < self.tag_size {
            return Err(());
        }

        let (ciphertext, tag) = message.split_at_mut(message.len() - self.tag_size);
        self.apply_ctr_mode(ciphertext, tag);

        // Buffer to store the computed tag (the tag can be at most BLOCK_SIZE bytes in
        // length).
        let mut expected_tag_buf = [0u8; BLOCK_SIZE];
        let expected_tag = &mut expected_tag_buf[0..self.tag_size];

        self.compute_cbc_mac(ciphertext, additional_data, expected_tag);

        // TODO: Use a constant time comparison function
        if expected_tag != tag {
            return Err(());
        }

        Ok(ciphertext)
    }

    fn compute_cbc_mac(&mut self, plaintext: &[u8], mut additional_data: &[u8], tag: &mut [u8]) {
        // Set up B_0 for CBC-MAC
        self.copy_nonce_to_block();

        self.setup_for_cbc_mac(!additional_data.is_empty(), plaintext.len());

        // Generate X_1 into self.block.ciphertext
        self.block.encrypt();

        if !additional_data.is_empty() {
            // Construct B_i containing the length of the block.
            {
                let mut remaining = &mut self.block.plaintext_mut()[..];
                if additional_data.len() < ((1 << 16) - (1 << 8)) {
                    *array_mut_ref![remaining, 0, 2] = (additional_data.len() as u16).to_be_bytes();
                    remaining = &mut remaining[2..];
                } else if additional_data.len() <= (core::u32::MAX as usize) {
                    remaining[0] = 0xFF;
                    remaining[1] = 0xFE;
                    *array_mut_ref![remaining, 2, 4] = (additional_data.len() as u32).to_be_bytes();
                    remaining = &mut remaining[6..];
                } else {
                    remaining[0] = 0xFF;
                    remaining[1] = 0xFF;
                    *array_mut_ref![remaining, 2, 8] = (additional_data.len() as u64).to_be_bytes();
                    remaining = &mut remaining[10..];
                }

                let n = core::cmp::min(remaining.len(), additional_data.len());
                remaining[0..n].copy_from_slice(&additional_data[0..n]);
                additional_data = &additional_data[n..];
                for i in n..remaining.len() {
                    remaining[i] = 0;
                }
            }

            // Store 'X_i XOR B_i' into self.block.plaintext.
            {
                let (p, c) = self.block.plaintext_mut_ciphertext();
                xor16_inplace(c, p);
            }

            // Encrypt 'X_i XOR B_i' to get X_i+1
            self.block.encrypt();

            // Construct remaining additional data blocks.
            self.append_cbc_mac_data_blocks(additional_data);
        }

        self.append_cbc_mac_data_blocks(plaintext);

        // Get raw unencrypted tag by taking first tag_size bytes.
        tag.copy_from_slice(&self.block.ciphertext()[0..tag.len()]);
    }

    fn append_cbc_mac_data_blocks(&mut self, mut input: &[u8]) {
        while input.len() > 0 {
            let (plaintext, ciphertext) = self.block.plaintext_mut_ciphertext();

            // Set the data.plaintext to B_i (the next input block padded with zeros).
            let n = core::cmp::min(input.len(), BLOCK_SIZE);
            plaintext[0..n].copy_from_slice(&input[0..n]);
            input = &input[n..];
            for i in n..BLOCK_SIZE {
                plaintext[i] = 0;
            }

            // TODO: Deduplicate these two lines.

            // Perform 'X_i XOR B_i'
            xor16_inplace(ciphertext, plaintext);

            // Encrypt 'X_i XOR B_i' to get X_i+1
            self.block.encrypt();
        }
    }

    /// Applies CTR encryption to the given plaintext and tag encrpyting them
    /// in-place.
    fn apply_ctr_mode(&mut self, plaintext: &mut [u8], tag: &mut [u8]) {
        // Setup A_0
        self.copy_nonce_to_block();

        self.setup_for_ctr_enc(0);

        // Generate S_0
        self.block.encrypt();

        // Encrypt tag as 'T XOR first-M-bytes( S_0 )' and write to the end of the
        // output buffer.
        xor_inplace(&self.block.ciphertext()[0..tag.len()], tag);

        for i in 0..ceil_div(plaintext.len(), BLOCK_SIZE) {
            let counter = i + 1;

            // Setup A_(i + 1)
            self.setup_for_ctr_enc(counter);

            // Generate S_(i + 1)
            self.block.encrypt();

            let start_i = i * BLOCK_SIZE;
            let end_i = core::cmp::min(plaintext.len(), start_i + BLOCK_SIZE);

            xor_inplace(
                &self.block.ciphertext()[0..(end_i - start_i)],
                &mut plaintext[start_i..end_i],
            );
        }
    }

    fn copy_nonce_to_block(&mut self) {
        self.block.plaintext_mut()[1..(1 + self.nonce.len())].copy_from_slice(&self.nonce[..]);
    }

    fn setup_for_cbc_mac(&mut self, has_additional_data: bool, length: usize) {
        let block = self.block.plaintext_mut();

        block[0] = (if has_additional_data { 1 } else { 0 }) << 6
            | ((self.tag_size as u8 - 2) / 2) << 3
            | (self.length_size as u8 - 1);

        if self.length_size == 2 {
            *array_mut_ref![block, block.len() - 2, 2] = (length as u16).to_be_bytes();
        } else {
            todo!();
        }
    }

    fn setup_for_ctr_enc(&mut self, counter: usize) {
        let block = self.block.plaintext_mut();

        block[0] = (self.length_size as u8 - 1);

        if self.length_size == 2 {
            *array_mut_ref![block, block.len() - 2, 2] = (counter as u16).to_be_bytes();
        } else {
            todo!();
        }
    }
}

fn xor16_inplace(a: &[u8; BLOCK_SIZE], b: &mut [u8; BLOCK_SIZE]) {
    for i in 0..(BLOCK_SIZE / 4) {
        let a_ref = array_ref![a, 4 * i, 4];
        let b_ref = array_mut_ref![b, 4 * i, 4];
        *b_ref = (u32::from_ne_bytes(*a_ref) ^ u32::from_ne_bytes(*b_ref)).to_ne_bytes();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::{aes::AESBlockCipher, cipher::BlockCipher};

    pub struct AES128BlockEncryptor {
        cipher: AESBlockCipher,
        plaintext: [u8; BLOCK_SIZE],
        ciphertext: [u8; BLOCK_SIZE],
    }

    impl AES128BlockEncryptor {
        pub fn new(key: &[u8]) -> Self {
            assert_eq!(key.len(), KEY_SIZE);

            Self {
                cipher: AESBlockCipher::create(key).unwrap(),
                plaintext: [0u8; BLOCK_SIZE],
                ciphertext: [0u8; BLOCK_SIZE],
            }
        }
    }

    impl BlockCipherBuffer for AES128BlockEncryptor {
        fn plaintext(&self) -> &[u8; BLOCK_SIZE] {
            &self.plaintext
        }

        fn plaintext_mut(&mut self) -> &mut [u8; BLOCK_SIZE] {
            &mut self.plaintext
        }

        fn plaintext_mut_ciphertext(&mut self) -> (&mut [u8; BLOCK_SIZE], &[u8; BLOCK_SIZE]) {
            (&mut self.plaintext, &self.ciphertext)
        }

        fn encrypt(&mut self) {
            self.cipher
                .encrypt_block(&self.plaintext, &mut self.ciphertext);
        }

        fn ciphertext(&self) -> &[u8; BLOCK_SIZE] {
            &self.ciphertext
        }
    }

    // Test vectors from the RFC
    #[test]
    fn works() {
        let key = common::hex::decode("C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF").unwrap();
        let nonce = common::hex::decode("00000003020100A0A1A2A3A4A5").unwrap();
        let mut data =
            common::hex::decode("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E")
                .unwrap();
        let tag_size = 8;
        let length_size = 2;

        let expected_ciphertext =
            common::hex::decode("588C979A61C663D2F066D0C2C0F989806D5F6B61DAC38417E8D12CFDF926E0")
                .unwrap();

        let aad = &data[0..8];
        let mut plaintext = data[8..].to_vec();
        plaintext.resize(plaintext.len() + tag_size, 0);

        let mut ccm = CCM::new(
            AES128BlockEncryptor::new(&key),
            tag_size,
            length_size,
            array_ref![&nonce, 0, 13],
        );
        ccm.encrypt_inplace(&mut plaintext, &aad);

        assert_eq!(&plaintext, &expected_ciphertext);

        println!("{:02x?}", &plaintext);
    }
}
