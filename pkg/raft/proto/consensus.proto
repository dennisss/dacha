syntax = "proto3";

package raft;

import "google/protobuf/empty.proto";
import "pkg/raft/proto/ident.proto";
import "pkg/raft/proto/consensus_state.proto";
import "pkg/protobuf/compiler/proto/extensions.proto";

// Internal RPC Server between servers participating in the consensus protocol
service Consensus {
	rpc PreVote (RequestVoteRequest) returns (RequestVoteResponse);

	// Sent from a candiate server to all other servers to request a vote for the candidate
	// to become the new leader. 
	rpc RequestVote (RequestVoteRequest) returns (RequestVoteResponse);
	
	// Sent from the current leader to followers to replicate new log entries.
	//
	// Requests are ordered and generally only one stream should be opened between a leader and
	// follower as log entries can only be appended in ascending order.
	rpc AppendEntries (stream AppendEntriesRequest) returns (stream AppendEntriesResponse);
	
	// Non-data carrying version of AppendEntries used to maintain leadership without blocking on
	// storage writes.
	//
	// In the case of a Heartbeat request is made concurrently to an AppendEntries request, it
	// should be prioritized for network bandwidth and processing time.
	rpc Heartbeat (HeartbeatRequest) returns (HeartbeatResponse);

	rpc InstallSnapshot (stream InstallSnapshotRequest) returns (InstallSnapshotResponse);

    // This is the odd ball out internal client method
    // NOTE: 'AddServer' and 'RemoveServer' will be implemented by clients in
    // terms of this method
	rpc Propose (ProposeRequest) returns (ProposeResponse);

	// Lookups up the current status of this server.
	rpc CurrentStatus (google.protobuf.Empty) returns (Status);
}

message RequestVoteRequest {
	// Candidate's term.
	// This will be the term in which the candidate is elected to be leader (if successful). This
	// should be selected to be greater than all previously seen terms.  
	// REQUIRED
    Term term = 1;

	// REQUIRED
    ServerId candidate_id = 2; /* < TODO: This doesn't 'need' to be sent if we pre-establish
                                 * this server's identity and on the connection layer and we are
                                 * not proxying a request for someone else */
    
	// REQUIRED
	LogIndex last_log_index = 3;
	
	// REQUIRED
	Term last_log_term = 4;

	// If present, is the term of a leader which granted us approval to overthrow it as the
	// new leader.
	Term leader_approval = 6;

	reserved 5;
}

message RequestVoteResponse {
	// REQUIRED
	Term term = 1; /* < If granted then this is redundant as it will only ever grant a vote for
                     * the same up-to-date term */

	// REQUIRED
	bool vote_granted = 2;

	// Returned in response to PreVote requests when the server being called doesn't believe
	// that the caller is in the set of full members. In response, the caller (the server requesting
	// votes) should update its config based on this hint (if the hint is commited at a higher log
	// index). This may trigger the caller to stop requesting votes upon noticing it isn't a voting
	// member.
	//
	// This feature is used to ensure that servers which are removed from the follower pool
	// eventually learn (in a graceful way) that they are no longer in the config so they shouldn't
	// disrupt other servers.
	ConfigurationSnapshot last_config_hint = 4;

	reserved 3;
}

// Represents a change to the cluster configuration in some configuration (in
// particular, this is for the case of membership changes one server at a time)
// If a change references a server already having some role in the cluster,
// then it is invalid
// In order for a config change to be appended to the leader's log for
// replication, all previous config changes in the log must also commited
// (although this is realistically only necessary if the change is to or from
// that of a full voting member)
message ConfigChange {
	oneof type {
		ServerId AddMember = 1;

		// Adds a server as a learner: meaning that entries will be replicated to
		// this server but it will not be considered for the purposes of elections
		// and counting votes.
		ServerId AddLearner = 2;

		// Removes a server completely from either the learners or members pools
		ServerId RemoveServer = 3;

		ServerId AddAspiring = 4;
	}
}

message LogPosition {
	// REQUIRED
    LogIndex index = 1;

	// REQUIRED
    Term term = 2;
}

// The format of a single log entry that will be appended to every server's
// append-only log
//
// Each entry represents an increment by one of the current log index
//
// TODO: Over the wire, the term number can be skipped if it is the same as the
// current term of the whole message of is the same as a previous entry
message LogEntry {
	// REQUIRED
	LogPosition pos = 1;

	// REQUIRED
	LogEntryData data = 2;
}

message LogEntryData {
	oneof type {
		// Does nothing but occupies a single log index
		// Currently this is used for getting a unique marker from the log index
		// used to commit this entry
		// In particular, we use these log indexes to allocate new server ids
		bool noop = 1;

		// Used internally for managing changes to the configuration of the cluster
		ConfigChange config = 2;

		// Represents some opaque data to be executed on the state machine
		bytes command = 3; /* TODO: Other potentially useful operations
                       * Commit, VoteFor, ObserveTerm <- These would be just for potentially
                       * optimizing out writes to the config/meta files and only ever writing
                       * consistently to the log file */
	}
}

message HeartbeatRequest {
	// Term in which the leader generating this request was elected.
	// REQUIRED
	Term term = 1;

	// Id of the leader server.
	// Generally this will be the id of the server than sent this request.
	// REQUIRED
	ServerId leader_id = 2;
}

message HeartbeatResponse {
	Term term = 1;
}

message AppendEntriesRequest {
	// Term in which the leader generating this request was elected.
	// REQUIRED
	Term term = 1;

	// Id of the leader server.
	// Generally this will be the id of the server than sent this request.
	// REQUIRED
	ServerId leader_id = 2; // < NOTE: For the bootstrapping process, this will be 0
	
	// Index of the log entry immediately before the first entry in 'entries'.
	// If 'entries' is empty, then this will be the index of the last entry appended to the
	// leader's log as of sending this request.
    // REQUIRED
	LogIndex prev_log_index = 3;
    
	// The term corresponding to the above prev_log_index.
	// REQUIRED
	Term prev_log_term = 4;

	// Entries to store in the recipient's log immediately after the entry at 'prev_log_index'.
	//
	// The recipient can ignore any entries already in it's local log at the same index and term,
	// then they can be ignored. 
	//
	// Assumptions:
	// The terms of these entries should be monotonic and the indexes should be sequential:
	// - prev_log_term <= entries[i].position.term <= term
	// - entries[0].position.index == prev_log_index + 1
	// - entries[i].position.index + 1 == entries[i+1].position.index
    repeated LogEntry entries = 5;
    
	// Index of the newest log index which has been commited by the leader (has been durably
	// flushed to a quorem of replicas).
	//
	// REQUIRED
	LogIndex leader_commit = 6;

	// After all entries in this request have been added at least to the in-memory log of the
	// recipient follower, the follower should start an election to take over as leader. 
	bool timeout_now = 8;

	reserved 7;
}

message AppendEntriesResponse {
	// Current term of the server producing this response.
	//
	// REQUIRED
	Term term = 1;

	// Whether or not all the entries in the corresponding AppendEntriesRequest were able to be
	// successfully flushed to the server's log.
	//
	// REQUIRED
	bool success = 2;

	// Index of the last log index in the server's log.
	//
	// When success = false, this informs the leader that we can't send any entries with index
	// '> last_log_index + 1'.
	//
    // This is an addon to what is mentioned in the original research paper so
    // that the leader knows what it needs to replicate to this server
	//
	// OPTIONAL
    LogIndex last_log_index = 3;

	reserved 4;
}

// Asks the server to propose a single entry to the state machine
message ProposeRequest {
	// REQUIRED
    LogEntryData data = 1;

    // If set, then this operation will block until the proposal has been
    // fulfilled or rejected
    // Otherwise the default behavior is to return a proposal that may
    // eventually get comitted or rejected
	//
	// REQUIRED
    bool wait = 2;
}

// XXX: Ideally should only be given as a response once the entries have been
// comitted
message ProposeResponse {
	oneof result {
		LogPosition proposal = 1;
		ProposeErrorProto error = 2;
	}
}

message LeaderHint {
	// REQUIRED
	Term term = 1;

	// OPTIONAL
	ServerId leader_id = 2;
}


message NotLeaderErrorProto {
	// REQUIRED
	Term term = 1;

	// OPTIONAL
	ServerId leader_hint = 2;
}

message ProposeErrorProto {
	oneof type {
		NotLeaderErrorProto not_leader = 1;
		bool command_too_large = 2;
	}
}

// TODO: Assert that no server is ever both in the members and learners list at
// the same time (possibly convert to one single list and make the two
// categories purely getter methods for iterators)
message Configuration {
	enum ServerRole {
		UNKNOWN = 0;

		// The server receives log entries actively but doesn't participate in elections.
		LEARNER = 1;

		// Same as LEARNER except that the server will be promoted to a VOTER once it is caught up
		// and stable. 
		ASPIRING = 2;

		// The server can participate in leader elections through voting or starting its own
		// election.
		MEMBER = 3;
	}

	message Server {
		ServerId id = 1;
		ServerRole role = 2;
	}

	repeated Server servers = 1;
}

// Represents a configuration at a single index
message ConfigurationSnapshot {
    // Index of the last log entry applied to this configuration
    // REQUIRED
    LogIndex last_applied = 1;

    // Value of the snapshot at the given index (TODO: This is the only type
    // that actually needs to be serializiable, so it could be more verbose
    // for all I care)
    // REQUIRED
    Configuration data = 2;
}

message InstallSnapshotRequest {
	// Current term of the leader sending this request.
	// REQUIRED
	Term term = 1;

	// Id of the leader. Used to inform the follower of the current leader.
	// Currently this will always be set to the id of the server sending the request.
	// 
	// TODO: Eventually send snapshots from non-leaders (/followers if available) as they are
	// likely less overloaded than the leader.
	//
	// REQUIRED
	ServerId leader_id = 2; 

	// Position of the last log entry applied to the snapshot.
	//
	// NOTE: This is sent only with the first chunk/request. 
	// REQUIRED
	LogPosition last_applied = 3;

	// Current configuration snapshot which is at least as far ahead as the state machine snapshot.
	//
	// NOTE: This is sent only with the first chunk/request (REQUIRED in that request).
	ConfigurationSnapshot last_config = 4;

	// Chunk of data in the snapshot starting at 'offset' and ending at 'offset + data.len()'.
	//
	// REQUIRED
	bytes data = 6;

	// If this is the final chunk in the snapshot, this is set to true, else false.
	// REQUIRED
	bool done = 7;

	// Approximate size of the entire snapshot.
	//
	// NOTE: This is only send with the first chunk/request.
	// REQUIRED
	uint64 approximate_size = 8;

	reserved 5;
}

message InstallSnapshotResponse {
	// Current term of the server receiving the snapshot.
	// REQUIRED
	Term term = 1;
}

message Status {
	ServerId id = 1;

	enum Role {
		UNKNOWN = 0;
		CANDIDATE = 1;
		FOLLOWER = 2;
		LEADER = 3;
	}
	Role role = 2;

	Metadata metadata = 3;

	Configuration configuration = 4;

	message FollowerProgress {
		ServerId id = 1;
		
		LogIndex match_index = 2;

		bool synchronized = 3;
	}

	// Only present if this is the leader.
	repeated FollowerProgress followers = 5;

	// Id of the leader of the current term (if known).
	// OPTIONAL
	ServerId leader_hint = 6;

	message DrainingStatus {
		Term term = 1;
		ServerId next_leader_id = 2;
	}

	// If present, this server is currently being drained.
	DrainingStatus draining = 7;
}
