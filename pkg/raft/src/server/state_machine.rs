use common::errors::*;
use common::io::Readable;

use crate::proto::consensus::*;

// Also good to know is when the last config snapshot happened
//

// TODO: Consider changing all of these methods to have an '&mut self' signature
// given that most of these methods only make sense to be called in a certain
// total order by a single calling thread.

#[async_trait]
pub trait StateMachine<R> {
    // TODO: Should probably have a check operation that validates an operation is
    // good before a leader decide to commit them (either way we will still be
    // consistent )

    // ^ issue being that because operations are not independent, this would need to
    // be checked per operation So the alternative would be to require the
    // StateMachine to implement an apply, revert, and commit

    /// Should apply the given operation to the state machine immediately
    /// integrating it
    /// If successful, then some result type can be output that is persisted to
    /// disk but is made available to the task that proposed this change to
    /// receive feedback on how the operation performed
    async fn apply(&self, index: LogIndex, op: &[u8]) -> Result<R>;

    /// Gets the index of the last log entry which has been persisted to disk.
    /// Future calls to snapshot() should return a snapshot with at least this
    /// index.
    async fn last_flushed(&self) -> LogIndex;

    /// Blocks until the state machine has been flushed since the last call to
    /// wait_for_flush().
    async fn wait_for_flush(&self);

    /// Retrieves the latest persisted snapshot of the state machine.
    ///
    /// TODO: While a snapshot is checked out, we should avoid deleting entries
    /// following it.
    ///
    /// The implementation of this will likely lock the in-memory or on-disk
    /// resources being used to store the snapshot so the caller should only
    /// retain the returned snapshots for a short period of time (while
    /// transferring the snapshot to another server).
    async fn snapshot(&self) -> Option<StateMachineSnapshot>;

    /// Resets the state machine to a state defined by the given snapshot.
    ///
    /// The caller is responsible for only providing a snapshot generated by
    /// another instance of the same type of state machine (or one with a
    /// compatible snapshot format).
    async fn restore(&self, data: StateMachineSnapshot) -> Result<()>;

    // Triggers a new snapshot to begin being created and persisted to disk
    // The index of the last entry applied to the state machine is given as an
    // argument to be stored alongside the snapshot Returns a receiver which
    // resolves once the snapshot has been created or has failed to be created
    // NOTE: Snapshotting should be sufficiently robust that old data is not lost on
    // failed snapshots fn perform_snapshot(&self, last_applied: u64) ->
    // Result<oneshot::Receiver<()>>;

    // simple method
    // We will trigger the matching process during the matching process
    /*
        From the matching process, acquire a snapshot and freeze the log
        - As soon as the log offset has passed, we will be able to commit all of the records properly

        - We will not implement truncate of records
        -  We will only implement truncation and appending after that fac


        RecordIO format:
        - Starts with one super block
            - Specifies the index of the previous log entry
            - Then the rest of the entries are sequential entries in the log
            - Appending a new entry with a lower commit index will be the method of handling truncatations
            -

    */
}

/*
    A Read interface will not work

    -> General idea:
        -> While reading a snapshot, can't snapshot?
        -> Yes, I can snapshot in the case of

    If we use a single file for snapshots:
        ->

    -> To do a file read or write, we need to acquire a write-lock on the file

    -> suppose

    -> Not all data may fit in memory
        - There do exists files on disk such that if we copy those files, it will result in us having a set of

*/

pub struct StateMachineSnapshot {
    /// Index of the last log entry in this snapshot (same value originally
    /// given to the perform_snapshot that created this snapshot )
    pub last_applied: LogIndex,

    /// Number of bytes needed to store this snapshot
    pub size: u64,

    /// A reader for retrieving the contents of the snapshot
    pub data: Box<dyn Readable>,
}
