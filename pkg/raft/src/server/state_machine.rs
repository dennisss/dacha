use common::errors::*;
use common::io::Readable;

use crate::proto::consensus::*;
use crate::proto::ident::*;

/// A state machine which evolves through a series by having operations applied
/// to it. Applying operations to the state machine should be deterministic for
/// a consistent ordering of the operations.
///
/// Because replaying a long log of operations to get back to a known state is
/// impracticle, the state machine should support periodically snapshotting its
/// latest internal state in a complete format to some persistent location
/// (usually to disk).
///
/// NOTE: The state machine is responsible for internally determining when the
/// best test to create a snapshot is and should handle any necessary persisting
/// to disk itself.
///
/// TODO: Consider making some of these methods take '&mut self' given that the
/// raft::Server should generally be the only user of these methods.
///
/// TODO: Consider supporting offering a snapshot hint to the state machine
/// (such as feeding in the current size of the log).
#[async_trait]
pub trait StateMachine<R> {
    /// Should apply the given operation to the state machine immediately
    /// integrating it.
    ///
    /// If this fails, then the user will assume that the state machine is in a
    /// corrupt/invalid state and the server should die.
    ///
    /// If successful, the state machine can return an arbitrary value which
    /// will be fed back to the original creator of the given operation. No
    /// gurantees are made that the creator actually gets back the returned
    /// value.
    async fn apply(&self, index: LogIndex, op: &[u8]) -> Result<R>;

    /// Gets the index of the last log entry which has been persisted to disk.
    /// Future calls to snapshot() should return a snapshot with at least this
    /// index.
    async fn last_flushed(&self) -> LogIndex;

    /// Blocks until the state machine has been flushed since the last call to
    /// wait_for_flush().
    async fn wait_for_flush(&self);

    /// Retrieves the latest persisted snapshot of the state machine.
    ///
    /// NOTE: This should not necessarily trigger the creation of a new
    /// snapshot. Rather it should lookup the latest already existing
    /// snapshot cheaply.
    ///
    /// The implementation of this will likely lock the in-memory or on-disk
    /// resources being used to store the snapshot so the caller should only
    /// retain the returned snapshots for a short period of time (while
    /// transferring the snapshot to another server).
    ///
    /// TODO: While a client calls ::snapshot() for transferring it to a remote
    /// server, it should ensure that no local log entries are deleted beyond
    /// the last_applied index of the snapshot as the remote server will need
    /// them to catch up after the snapshot is installed.
    async fn snapshot(&self) -> Option<StateMachineSnapshot>;

    /// Resets the state machine to a state defined by the given snapshot.
    ///
    /// The caller is responsible for only providing a snapshot generated by
    /// another instance of the same type of state machine (or one with a
    /// compatible snapshot format).
    ///
    /// NOTE: It is illegal to call ::restore(::snapshot()) on a single state
    /// machine instance.
    async fn restore(&self, data: StateMachineSnapshot) -> Result<()>;
}

pub struct StateMachineSnapshot {
    /// Index of the last log entry in this snapshot (same value originally
    /// given to the perform_snapshot that created this snapshot )
    pub last_applied: LogIndex,

    /// Number of bytes needed to store this snapshot.
    pub size: u64,

    /// A reader for retrieving the contents of the snapshot.
    ///
    /// This can only be traversed once. If an error is encountered while
    /// reading from this in StateMachine::restore(), the restore should be
    /// reliably cancelled.
    pub data: Box<dyn Readable>,
}
