use common::errors::*;
use common::io::SharedReadable;

use crate::proto::*;

/// A state machine which evolves through a series by having operations applied
/// to it. Applying operations to the state machine should be deterministic for
/// a consistent ordering of the operations.
///
/// Because replaying a long log of operations to get back to a known state is
/// impracticle, the state machine should support periodically snapshotting its
/// latest internal state in a complete format to some persistent location
/// (usually to disk).
///
/// NOTE: The state machine is responsible for internally determining when the
/// best test to create a snapshot is and should handle any necessary persisting
/// to disk itself.
///
/// TODO: Consider making some of these methods take '&mut self' given that the
/// raft::Server should generally be the only user of these methods.
///
/// TODO: Consider supporting offering a snapshot hint to the state machine
/// (such as feeding in the current size of the log).
#[async_trait]
pub trait StateMachine<R> {
    /// Should apply the given operation to the state machine immediately
    /// integrating it.
    ///
    /// If this fails, then the user will assume that the state machine is in a
    /// corrupt/invalid state and the server should shutdown.
    ///
    /// If successful, the state machine can return an arbitrary value which
    /// will be fed back to the original creator of the given operation. No
    /// gurantees are made that the creator actually gets back the returned
    /// value.
    async fn apply(&self, index: LogIndex, op: &[u8]) -> Result<R>;

    /// Last log index applied to the state machine.
    async fn last_applied(&self) -> LogIndex;

    /// Gets the index of the last log entry which has been persisted to disk.
    /// Future calls to snapshot() should return a snapshot with at least this
    /// index.
    async fn last_flushed(&self) -> LogIndex;

    /// Blocks until the state machine has been flushed since the last call to
    /// wait_for_flush().
    async fn wait_for_flush(&self);

    /// Retrieves the latest persisted snapshot of the state machine.
    ///
    /// NOTE: This should not necessarily trigger the creation of a new
    /// snapshot. Rather it should lookup the latest already existing
    /// snapshot cheaply.
    ///
    /// The implementation of this will likely lock the in-memory or on-disk
    /// resources being used to store the snapshot so the caller should only
    /// retain the returned snapshots for a short period of time (while
    /// transferring the snapshot to another server).
    ///
    /// TODO: While a client calls ::snapshot() for transferring it to a remote
    /// server, it should ensure that no local log entries are deleted beyond
    /// the last_applied index of the snapshot as the remote server will need
    /// them to catch up after the snapshot is installed.
    async fn snapshot(&self) -> Result<Option<StateMachineSnapshot>>;

    /// Resets the state machine to a state defined by the given snapshot.
    ///
    /// The caller is responsible for only providing a snapshot generated by
    /// another instance of the same type of state machine (or one with a
    /// compatible snapshot format).
    ///
    /// NOTE: It is illegal to call ::restore(::snapshot()) on a single state
    /// machine instance.
    ///
    /// Returns whether or not the restore was successfully applied or not
    /// applied. A snapshot is 'applied' if we were able to advance last_flushed
    /// in one way or another to >= data.last_flushed. Note that the
    /// last_applied index MUST NOT ever decrease after calling this. To
    /// succeed, the state machine may need to flush the current state to
    /// disk rather than taking the newly given snapshot. An error should
    /// only be returned if the state machine has entered an unrecoverable
    /// state.
    async fn restore(&self, data: StateMachineSnapshot) -> Result<bool>;
}

pub struct StateMachineSnapshot {
    /// Index of the last log entry in this snapshot.
    ///
    /// This is mainly used for early rejection. The state machine should do its
    /// own checks as well to verify that we don't accept any old snapshots
    /// during restore().
    pub last_applied: LogIndex,

    /// A reader for retrieving the contents of the snapshot.
    ///
    /// This can only be traversed once. If an error is encountered while
    /// reading from this in StateMachine::restore(), the restore should be
    /// reliably cancelled.
    pub data: Box<dyn SharedReadable>,
    // TODO: Provide an estimate of how big the snapshot is for progress tracking purposes.
}
