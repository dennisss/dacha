syntax = "proto3";


// Type used to uniquely identify each server. These are assigned automatically
// and increment monotonically starting with the first server having an id of
// 1 and will never repeat with new servers
//
// NOTE: A value of 0 is used to specify the 'NULL' server id.
message ServerId {
	option typed_num = true;
	uint64 value = 1;
}

message Term {
	option typed_num = true;
	uint64 value = 2;
}

message LogIndex {
	option typed_num = true;
	uint64 value = 3;
}

// Internal RPC Server between servers participating in the consensus protocol
service Consensus {
	rpc PreVote (RequestVoteRequest) returns (RequestVoteResponse);

	// Sent from a candiate server to all other servers to request a vote for the candidate
	// to become the new leader. 
	rpc RequestVote (RequestVoteRequest) returns (RequestVoteResponse);
	
	// Sent from the current leader to followers to replicate new log entries.
	rpc AppendEntries (AppendEntriesRequest) returns (AppendEntriesResponse);
	
	rpc TimeoutNow (TimeoutNow) returns (EmptyMessage);

	// Also InstallSnapshot

    // This is the odd ball out internal client method
    // NOTE: 'AddServer' and 'RemoveServer' will be implemented by clients in
    // terms of this method
	rpc Propose (ProposeRequest) returns (ProposeResponse);
}

message RequestVoteRequest {
	// Candidate's term.
	// This will be the term in which the candidate is elected to be leader (if successful). This
	// should be selected to be greater than all previously seen terms.  
	// REQUIRED
    Term term = 1;

	// REQUIRED
    ServerId candidate_id = 2; /* < TODO: This doesn't 'need' to be sent if we pre-establish
                                 * this server's identity and on the connection layer and we are
                                 * not proxying a request for someone else */
    
	// REQUIRED
	LogIndex last_log_index = 3;
	
	// REQUIRED
	Term last_log_term = 4;
}

message RequestVoteResponse {
	// REQUIRED
	Term term = 1; /* < If granted then this is redundant as it will only ever grant a vote for
                     * the same up-to-date term */

	// REQUIRED
	bool vote_granted = 2;
}

// Represents a change to the cluster configuration in some configuration (in
// particular, this is for the case of membership changes one server at a time)
// If a change references a server already having some role in the cluster,
// then it is invalid
// In order for a config change to be appended to the leader's log for
// replication, all previous config changes in the log must also commited
// (although this is realistically only necessary if the change is to or from
// that of a full voting member)
message ConfigChange {
	oneof type {
		ServerId AddMember = 1;

		// Adds a server as a learner: meaning that entries will be replicated to
		// this server but it will not be considered for the purposes of elections
		// and counting votes
		ServerId AddLearner = 2;

		// Removes a server completely from either the learners or members pools
		ServerId RemoveServer = 3;
	}
}

message LogPosition {
	// REQUIRED
    LogIndex index = 1;

	// REQUIRED
    Term term = 2;
}

// The format of a single log entry that will be appended to every server's
// append-only log
//
// Each entry represents an increment by one of the current log index
//
// TODO: Over the wire, the term number can be skipped if it is the same as the
// current term of the whole message of is the same as a previous entry
message LogEntry {
	// REQUIRED
	LogPosition pos = 1;

	// REQUIRED
	LogEntryData data = 2;
}

message LogEntryData {
	oneof type {
		// Does nothing but occupies a single log index
		// Currently this is used for getting a unique marker from the log index
		// used to commit this entry
		// In particular, we use these log indexes to allocate new server ids
		bool noop = 1;

		// Used internally for managing changes to the configuration of the cluster
		ConfigChange config = 2;

		// Represents some opaque data to be executed on the state machine
		bytes command = 3; /* TODO: Other potentially useful operations
                       * Commit, VoteFor, ObserveTerm <- These would be just for potentially
                       * optimizing out writes to the config/meta files and only ever writing
                       * consistently to the log file */
	}
}


message AppendEntriesRequest {
	// Term in which the leader generating this request was elected.
	// REQUIRED
	Term term = 1;

	// Id of the leader server.
	// Generally this will be the id of the server than sent this request.
	// REQUIRED
	ServerId leader_id = 2; // < NOTE: For the bootstrapping process, this will be 0
	
	// Index of the log entry immediately before the first entry in 'entries'.
	// If 'entries' is empty, then this will be the index of the last entry appended to the
	// leader's log as of sending this request.
    // REQUIRED
	LogIndex prev_log_index = 3;
    
	// The term corresponding to the above prev_log_index.
	// REQUIRED
	Term prev_log_term = 4;

	// Entries to store in the recipient's log immediately after the entry at 'prev_log_index'.
	//
	// The recipient can ignore any entries already in it's local log at the same index and term,
	// then they can be ignored. 
	//
	// Assumptions:
	// The terms of these entries should be monotonic and the indexes should be sequential:
	// - prev_log_term <= entries[i].position.term <= term
	// - entries[0].position.index == prev_log_index + 1
	// - entries[i].position.index + 1 == entries[i+1].position.index
    repeated LogEntry entries = 5;
    
	// Index of the newest log index which has been commited by the leader (has been durably
	// flushed to a quorem of replicas).
	//
	// REQUIRED
	LogIndex leader_commit = 6;
}

message AppendEntriesResponse {
	// Current term of the server producing this response.
	// REQUIRED
	Term term = 1;

	// Whether or not all the entries in the corresponding AppendEntriesRequest were able to be successfully 
	// REQUIRED
	bool success = 2;

    // this is an addon to what is mentioned in the original research paper so
    // that the leader knows what it needs to replicate to this server
	//
	// OPTIONAL
    LogIndex last_log_index = 3;
}


// Upon being received a server should immediatley timeout and start its own
// election
message TimeoutNow {}

message EmptyMessage {}

// Asks the server to propose a single entry to the state machine
message ProposeRequest {
	// REQUIRED
    LogEntryData data = 1;

    // If set, then this operation will block until the proposal has been
    // fulfilled or rejected
    // Otherwise the default behavior is to return a proposal that may
    // eventually get comitted or rejected
	//
	// REQUIRED
    bool wait = 2;
}

// XXX: Ideally should only be given as a response once the entries have been
// comitted
message ProposeResponse {
	// REQUIRED
    Term term = 1;

	// REQUIRED
    LogIndex index = 2;
}
