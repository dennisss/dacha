syntax = "proto3";


// Type used to uniquely identify each server. These are assigned automatically
// and increment monotonically starting with the first server having an id of
// 1 and will never repeat with new servers
//
// NOTE: A value of 0 is used to specify the 'NULL' server id.
message ServerId {
	option typed_num = true;
	uint64 value = 1;
}

message Term {
	option typed_num = true;
	uint64 value = 2;
}

message LogIndex {
	option typed_num = true;
	uint64 value = 3;
}

// Internal RPC Server between servers participating in the consensus protocol
service Consensus {
	rpc PreVote (RequestVoteRequest) returns (RequestVoteResponse);
	rpc RequestVote (RequestVoteRequest) returns (RequestVoteResponse);
	rpc AppendEntries (AppendEntriesRequest) returns (AppendEntriesResponse);
	rpc TimeoutNow (TimeoutNow) returns (EmptyMessage);

	// Also InstallSnapshot

    // This is the odd ball out internal client method
    // NOTE: 'AddServer' and 'RemoveServer' will be implemented by clients in
    // terms of this method
	rpc Propose (ProposeRequest) returns (ProposeResponse);
}

message RequestVoteRequest {
	// REQUIRED
    Term term = 1;

	// REQUIRED
    ServerId candidate_id = 2; /* < TODO: This doesn't 'need' to be sent if we pre-establish
                                 * this server's identity and on the connection layer and we are
                                 * not proxying a request for someone else */
    
	// REQUIRED
	LogIndex last_log_index = 3;
	
	// REQUIRED
	Term last_log_term = 4;
}

message RequestVoteResponse {
	// REQUIRED
	Term term = 1; /* < If granted then this is redundant as it will only ever grant a vote for
                     * the same up-to-date term */

	// REQUIRED
	bool vote_granted = 2;
}

// Represents a change to the cluster configuration in some configuration (in
// particular, this is for the case of membership changes one server at a time)
// If a change references a server already having some role in the cluster,
// then it is invalid
// In order for a config change to be appended to the leader's log for
// replication, all previous config changes in the log must also commited
// (although this is realistically only necessary if the change is to or from
// that of a full voting member)
message ConfigChange {
	oneof type {
		ServerId AddMember = 1;

		// Adds a server as a learner: meaning that entries will be replicated to
		// this server but it will not be considered for the purposes of elections
		// and counting votes
		ServerId AddLearner = 2;

		// Removes a server completely from either the learners or members pools
		ServerId RemoveServer = 3;
	}
}

message LogPosition {
	// REQUIRED
    LogIndex index = 1;

	// REQUIRED
    Term term = 2;
}

// The format of a single log entry that will be appended to every server's
// append-only log
// Each entry represents an increment by one of the current log index
// TODO: Over the wire, the term number can be skipped if it is the same as the
// current term of the whole message of is the same as a previous entry
message LogEntry {
	// REQUIRED
	LogPosition pos = 1;

	// REQUIRED
	LogEntryData data = 2;
}

message LogEntryData {
	oneof type {
		// Does nothing but occupies a single log index
		// Currently this is used for getting a unique marker from the log index
		// used to commit this entry
		// In particular, we use these log indexes to allocate new server ids
		bool noop = 1;

		// Used internally for managing changes to the configuration of the cluster
		ConfigChange config = 2;

		// Represents some opaque data to be executed on the state machine
		bytes command = 3; /* TODO: Other potentially useful operations
                       * Commit, VoteFor, ObserveTerm <- These would be just for potentially
                       * optimizing out writes to the config/meta files and only ever writing
                       * consistently to the log file */
	}
}


message AppendEntriesRequest {
	// REQUIRED
	Term term = 1;

	// REQUIRED
	ServerId leader_id = 2; // < NOTE: For the bootstrapping process, this will be 0
	
	// This should be basically for all that are immediately before us
    // REQUIRED
	LogIndex prev_log_index = 3;
    
	// REQUIRED
	Term prev_log_term = 4;

    repeated LogEntry entries = 5; /* < We will assume that these all have sequential indexes and
                                 * don't need to be explicitly mentioned */
    
	// REQUIRED
	LogIndex leader_commit = 6;
}

message AppendEntriesResponse {
	// REQUIRED
	Term term = 1;

	// REQUIRED
	bool success = 2;

    // this is an addon to what is mentioned in the original research paper so
    // that the leader knows what it needs to replicate to this server
	//
	// OPTIONAL
    LogIndex last_log_index = 3;
}


// Upon being received a server should immediatley timeout and start its own
// election
message TimeoutNow {}

message EmptyMessage {}

// Asks the server to propose a single entry to the state machine
message ProposeRequest {
	// REQUIRED
    LogEntryData data = 1;

    // If set, then this operation will block until the proposal has been
    // fulfilled or rejected
    // Otherwise the default behavior is to return a proposal that may
    // eventually get comitted or rejected
	//
	// REQUIRED
    bool wait = 2;
}

// XXX: Ideally should only be given as a response once the entries have been
// comitted
message ProposeResponse {
	// REQUIRED
    Term term = 1;

	// REQUIRED
    LogIndex index = 2;
}


// Used by the SimpleLog to implement a single file log. 
message SimpleLogValue {
	repeated LogEntry entries = 1;
}