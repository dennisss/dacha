syntax = "proto3";

package cnc;

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "pkg/cnc/monitor/proto/machine_config.proto";
import "pkg/cnc/monitor/proto/file.proto";
import "pkg/cnc/monitor/proto/run.proto";

message MachineProto {
    fixed64 id = 1;

    MachineConfig config = 2;

    MachineStateProto state = 3;
}

message MachineStateProto {
    enum ConnectionState {
        UNKNOWN = 0;

        // We can't connect to this machine because the main serial device used to connect to it is
        // not available (e.g. USB cable is unplugged).
        MISSING = 1;

        // The machine has been detected as available for connection but we won't connect to it
        DISCONNECTED = 2;

        // The serial port is being configured or initialize commands are still being sent. 
        CONNECTING = 3;

        // TODO: Need a DISCONNECTING state.

        // The link to the machine is fully setup and the machine is believed to be healthy
        // (responding to keep alives).
        //
        // Most other fields in the MachineStateProto are only valid in this state.
        CONNECTED = 4;

        // Something failed while communicating with this machine.
        // If auto_connect is enabled, we will retry connecting after a backoff.
        ERROR = 5;
    }

    ConnectionState connection_state = 1;

    // Error message from the last time the machine entered the ERROR state.
    string last_connection_error = 2;

    // Verbose set of information on what device was selected to use for connecting to this
    // machine. If the machine is not a CONNECTED|CONNECTING state, then this will instead contain
    // information on the candidate device which can be connected to.
    DeviceSelector connection_device = 5;

    repeated AxisValue axis_values = 3;

    LoadedProgramState loaded_program = 6;

    // Information about the currently running program on the machine.
    //
    // If not set, then there is no program running.
    //
    // After a program finished (either into the DONE, STOPPED, or ERROR state), running_program will stay
    // set to capture the final state. New files can be loaded only when this is not set or it is a
    // terminal state.
    //
    // TODO: Eventually don't keep this set and instead just refer to the last recorded run on
    // the machine.
    // 
    //
    //
    // If set, then there is currently a program running on the machine.
    //
    // 
    //
    ProgramRun running_program = 4;

    repeated CameraState cameras = 7;
}


message AxisValue {
    string id = 1;

    // For heaters, this will contain two elements [current_temperature, target_temperature]
    repeated float value = 2;

    // Last time we got the value of this axis from the machine.
    google.protobuf.Timestamp last_reported = 3;
}

message LoadedProgramState {
    FileProto file = 1;
}

message CameraState {
    fixed64 camera_id = 1;

    enum State {
        UNKNOWN = 0;
        
        // The camera is not physically connected.
        MISSING = 1;

        // This camera is still initializing. It can't be actively 
        SETUP = 2;
        
        IDLE = 3;
        
        STARTING = 4;
        
        RECORDING = 5;
        
        ERROR = 6;
    }

    State status = 2;

    // If present, the full set of information on the connected camera.
    // If not present, then the camera isn't connected. 
    DeviceSelector device = 3;

    // Error from the last attempt to record using this camera.
    string last_error = 4;
}


