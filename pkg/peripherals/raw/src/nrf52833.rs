// AUTOGENERATED BY THE CMSIS SVD COMPILER

#![allow(
    dead_code,
    non_snake_case,
    non_camel_case_types,
    unused_imports,
    unused_variables
)]

use core::ops::{Deref, DerefMut};

use common::register::*;

pub struct Peripherals {
    _hidden: (),
    pub ficr: ficr::FICR,
    pub uicr: uicr::UICR,
    pub approtect: approtect::APPROTECT,
    pub clock: clock::CLOCK,
    pub power: power::POWER,
    pub p0: p0::P0,
    pub p1: p1::P1,
    pub radio: radio::RADIO,
    pub uart0: uart0::UART0,
    pub uarte0: uarte0::UARTE0,
    pub spi0: spi0::SPI0,
    pub spim0: spim0::SPIM0,
    pub spis0: spis0::SPIS0,
    pub twi0: twi0::TWI0,
    pub twim0: twim0::TWIM0,
    pub twis0: twis0::TWIS0,
    pub spi1: spi1::SPI1,
    pub spim1: spim1::SPIM1,
    pub spis1: spis1::SPIS1,
    pub twi1: twi1::TWI1,
    pub twim1: twim1::TWIM1,
    pub twis1: twis1::TWIS1,
    pub nfct: nfct::NFCT,
    pub gpiote: gpiote::GPIOTE,
    pub saadc: saadc::SAADC,
    pub timer0: timer0::TIMER0,
    pub timer1: timer1::TIMER1,
    pub timer2: timer2::TIMER2,
    pub rtc0: rtc0::RTC0,
    pub temp: temp::TEMP,
    pub rng: rng::RNG,
    pub ecb: ecb::ECB,
    pub aar: aar::AAR,
    pub ccm: ccm::CCM,
    pub wdt: wdt::WDT,
    pub rtc1: rtc1::RTC1,
    pub qdec: qdec::QDEC,
    pub comp: comp::COMP,
    pub lpcomp: lpcomp::LPCOMP,
    pub egu0: egu0::EGU0,
    pub swi0: swi0::SWI0,
    pub egu1: egu1::EGU1,
    pub swi1: swi1::SWI1,
    pub egu2: egu2::EGU2,
    pub swi2: swi2::SWI2,
    pub egu3: egu3::EGU3,
    pub swi3: swi3::SWI3,
    pub egu4: egu4::EGU4,
    pub swi4: swi4::SWI4,
    pub egu5: egu5::EGU5,
    pub swi5: swi5::SWI5,
    pub timer3: timer3::TIMER3,
    pub timer4: timer4::TIMER4,
    pub pwm0: pwm0::PWM0,
    pub pdm: pdm::PDM,
    pub acl: acl::ACL,
    pub nvmc: nvmc::NVMC,
    pub ppi: ppi::PPI,
    pub mwu: mwu::MWU,
    pub pwm1: pwm1::PWM1,
    pub pwm2: pwm2::PWM2,
    pub spi2: spi2::SPI2,
    pub spim2: spim2::SPIM2,
    pub spis2: spis2::SPIS2,
    pub rtc2: rtc2::RTC2,
    pub i2s: i2s::I2S,
    pub fpu: fpu::FPU,
    pub usbd: usbd::USBD,
    pub uarte1: uarte1::UARTE1,
    pub pwm3: pwm3::PWM3,
    pub spim3: spim3::SPIM3,
}

impl Peripherals {
    pub fn new() -> Self {
        unsafe {
            Self {
                _hidden: (),
                ficr: ficr::FICR::new(),
                uicr: uicr::UICR::new(),
                approtect: approtect::APPROTECT::new(),
                clock: clock::CLOCK::new(),
                power: power::POWER::new(),
                p0: p0::P0::new(),
                p1: p1::P1::new(),
                radio: radio::RADIO::new(),
                uart0: uart0::UART0::new(),
                uarte0: uarte0::UARTE0::new(),
                spi0: spi0::SPI0::new(),
                spim0: spim0::SPIM0::new(),
                spis0: spis0::SPIS0::new(),
                twi0: twi0::TWI0::new(),
                twim0: twim0::TWIM0::new(),
                twis0: twis0::TWIS0::new(),
                spi1: spi1::SPI1::new(),
                spim1: spim1::SPIM1::new(),
                spis1: spis1::SPIS1::new(),
                twi1: twi1::TWI1::new(),
                twim1: twim1::TWIM1::new(),
                twis1: twis1::TWIS1::new(),
                nfct: nfct::NFCT::new(),
                gpiote: gpiote::GPIOTE::new(),
                saadc: saadc::SAADC::new(),
                timer0: timer0::TIMER0::new(),
                timer1: timer1::TIMER1::new(),
                timer2: timer2::TIMER2::new(),
                rtc0: rtc0::RTC0::new(),
                temp: temp::TEMP::new(),
                rng: rng::RNG::new(),
                ecb: ecb::ECB::new(),
                aar: aar::AAR::new(),
                ccm: ccm::CCM::new(),
                wdt: wdt::WDT::new(),
                rtc1: rtc1::RTC1::new(),
                qdec: qdec::QDEC::new(),
                comp: comp::COMP::new(),
                lpcomp: lpcomp::LPCOMP::new(),
                egu0: egu0::EGU0::new(),
                swi0: swi0::SWI0::new(),
                egu1: egu1::EGU1::new(),
                swi1: swi1::SWI1::new(),
                egu2: egu2::EGU2::new(),
                swi2: swi2::SWI2::new(),
                egu3: egu3::EGU3::new(),
                swi3: swi3::SWI3::new(),
                egu4: egu4::EGU4::new(),
                swi4: swi4::SWI4::new(),
                egu5: egu5::EGU5::new(),
                swi5: swi5::SWI5::new(),
                timer3: timer3::TIMER3::new(),
                timer4: timer4::TIMER4::new(),
                pwm0: pwm0::PWM0::new(),
                pdm: pdm::PDM::new(),
                acl: acl::ACL::new(),
                nvmc: nvmc::NVMC::new(),
                ppi: ppi::PPI::new(),
                mwu: mwu::MWU::new(),
                pwm1: pwm1::PWM1::new(),
                pwm2: pwm2::PWM2::new(),
                spi2: spi2::SPI2::new(),
                spim2: spim2::SPIM2::new(),
                spis2: spis2::SPIS2::new(),
                rtc2: rtc2::RTC2::new(),
                i2s: i2s::I2S::new(),
                fpu: fpu::FPU::new(),
                usbd: usbd::USBD::new(),
                uarte1: uarte1::UARTE1::new(),
                pwm3: pwm3::PWM3::new(),
                spim3: spim3::SPIM3::new(),
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq)]
pub enum Interrupt {
    POWER_CLOCK = 0,
    RADIO = 1,
    UARTE0_UART0 = 2,
    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0 = 3,
    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1 = 4,
    NFCT = 5,
    GPIOTE = 6,
    SAADC = 7,
    TIMER0 = 8,
    TIMER1 = 9,
    TIMER2 = 10,
    RTC0 = 11,
    TEMP = 12,
    RNG = 13,
    ECB = 14,
    CCM_AAR = 15,
    WDT = 16,
    RTC1 = 17,
    QDEC = 18,
    COMP_LPCOMP = 19,
    SWI0_EGU0 = 20,
    SWI1_EGU1 = 21,
    SWI2_EGU2 = 22,
    SWI3_EGU3 = 23,
    SWI4_EGU4 = 24,
    SWI5_EGU5 = 25,
    TIMER3 = 26,
    TIMER4 = 27,
    PWM0 = 28,
    PDM = 29,
    MWU = 32,
    PWM1 = 33,
    PWM2 = 34,
    SPIM2_SPIS2_SPI2 = 35,
    RTC2 = 36,
    I2S = 37,
    FPU = 38,
    USBD = 39,
    UARTE1 = 40,
    PWM3 = 45,
    SPIM3 = 47,
}

impl Interrupt {
    pub const MAX: usize = 47;
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] TaskTrigger u32 =>
    // Trigger task
    Trigger = 1

);

impl TaskTrigger {
    pub fn is_trigger(&self) -> bool {
        *self == Self::Trigger
    }

    pub fn set_trigger(&mut self) -> &mut Self {
        *self = Self::Trigger;
        self
    }
}

#[allow(non_camel_case_types)]
#[repr(transparent)]
pub struct TaskRegister {
    raw: RawRegister<u32>,
}

impl TaskRegister {
    pub fn write_trigger(&mut self) {
        self.write(TaskTrigger::Trigger)
    }
}

impl RegisterWrite for TaskRegister {
    type Value = TaskTrigger;

    #[inline(always)]
    fn write(&mut self, value: Self::Value) {
        let old_raw = 0;
        let raw = value.to_value();
        self.raw.write(raw);
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] EventState u32 =>
                // Event not generated
                NotGenerated = 0,
// Event generated
                Generated = 1

            );

impl EventState {
    pub fn is_notgenerated(&self) -> bool {
        *self == Self::NotGenerated
    }

    pub fn set_notgenerated(&mut self) -> &mut Self {
        *self = Self::NotGenerated;
        self
    }

    pub fn is_generated(&self) -> bool {
        *self == Self::Generated
    }

    pub fn set_generated(&mut self) -> &mut Self {
        *self = Self::Generated;
        self
    }
}

#[allow(non_camel_case_types)]
#[repr(transparent)]
pub struct EventRegister {
    raw: RawRegister<u32>,
}

impl EventRegister {
    pub fn write_notgenerated(&mut self) {
        self.write(EventState::NotGenerated)
    }

    pub fn write_generated(&mut self) {
        self.write(EventState::Generated)
    }
}

impl RegisterRead for EventRegister {
    type Value = EventState;

    #[inline(always)]
    fn read(&self) -> Self::Value {
        let raw = self.raw.read();
        EventState::from_value((raw & 0x00000001) >> 0)
    }
}

impl RegisterWrite for EventRegister {
    type Value = EventState;

    #[inline(always)]
    fn write(&mut self, value: Self::Value) {
        let old_raw = 0;
        let raw = value.to_value();
        self.raw.write(raw);
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] InterruptState u32 =>
                // Read: Disabled
                Disabled = 0,
// Read: Enabled
                Enabled = 1

            );

impl InterruptState {
    pub fn is_disabled(&self) -> bool {
        *self == Self::Disabled
    }

    pub fn set_disabled(&mut self) -> &mut Self {
        *self = Self::Disabled;
        self
    }

    pub fn is_enabled(&self) -> bool {
        *self == Self::Enabled
    }

    pub fn set_enabled(&mut self) -> &mut Self {
        *self = Self::Enabled;
        self
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] InterruptSet u32 =>
    // Enable
    Set = 1

);

impl InterruptSet {
    pub fn is_set(&self) -> bool {
        *self == Self::Set
    }

    pub fn set_set(&mut self) -> &mut Self {
        *self = Self::Set;
        self
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] InterruptClear u32 =>
    // Disable
    Clear = 1

);

impl InterruptClear {
    pub fn is_clear(&self) -> bool {
        *self == Self::Clear
    }

    pub fn set_clear(&mut self) -> &mut Self {
        *self = Self::Clear;
        self
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] PinLevel u32 =>
                // Pin driver is low
                Low = 0,
// Pin driver is high
                High = 1

            );

impl PinLevel {
    pub fn is_low(&self) -> bool {
        *self == Self::Low
    }

    pub fn set_low(&mut self) -> &mut Self {
        *self = Self::Low;
        self
    }

    pub fn is_high(&self) -> bool {
        *self == Self::High
    }

    pub fn set_high(&mut self) -> &mut Self {
        *self = Self::High;
        self
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] PinDirection u32 =>
                // Pin set as input
                Input = 0,
// Pin set as output
                Output = 1

            );

impl PinDirection {
    pub fn is_input(&self) -> bool {
        *self == Self::Input
    }

    pub fn set_input(&mut self) -> &mut Self {
        *self = Self::Input;
        self
    }

    pub fn is_output(&self) -> bool {
        *self == Self::Output
    }

    pub fn set_output(&mut self) -> &mut Self {
        *self = Self::Output;
        self
    }
}

#[allow(non_camel_case_types)]
#[repr(transparent)]
pub struct PinSelectRegister {
    raw: RawRegister<u32>,
}

impl PinSelectRegister {
    pub fn write_with<F: Fn(&mut PinSelectRegister_VALUE) -> &mut PinSelectRegister_VALUE>(
        &mut self,
        f: F,
    ) {
        let mut v = PinSelectRegister_VALUE::new();
        f(&mut v);
        self.write(v);
    }
}

impl RegisterRead for PinSelectRegister {
    type Value = PinSelectRegister_VALUE;

    #[inline(always)]
    fn read(&self) -> Self::Value {
        let v = self.raw.read();
        PinSelectRegister_VALUE::from_raw(v)
    }
}

impl RegisterWrite for PinSelectRegister {
    type Value = PinSelectRegister_VALUE;

    #[inline(always)]
    fn write(&mut self, value: Self::Value) {
        self.raw.write(value.to_raw());
    }
}

#[derive(Clone, Copy, PartialEq)]
pub struct PinSelectRegister_VALUE {
    raw: u32,
}

impl PinSelectRegister_VALUE {
    pub fn new() -> Self {
        Self { raw: 0 }
    }

    #[inline(always)]
    pub fn from_raw(raw: u32) -> Self {
        Self { raw }
    }

    #[inline(always)]
    pub fn to_raw(&self) -> u32 {
        self.raw
    }

    pub fn pin(&self) -> u32 {
        let raw = self.raw;
        (raw & 0x0000001f) >> 0
    }

    pub fn set_pin(&mut self, value: u32) -> &mut Self {
        let old_raw = self.raw;
        self.raw = (old_raw & !0x0000001f) | (value << 0);
        self
    }

    pub fn port(&self) -> u32 {
        let raw = self.raw;
        (raw & 0x00000020) >> 5
    }

    pub fn set_port(&mut self, value: u32) -> &mut Self {
        let old_raw = self.raw;
        self.raw = (old_raw & !0x00000020) | (value << 5);
        self
    }

    pub fn connect(&self) -> CONNECT_FIELD {
        let raw = self.raw;
        CONNECT_FIELD::from_value((raw & 0x80000000) >> 31)
    }

    pub fn set_connect(&mut self, value: CONNECT_FIELD) -> &mut Self {
        let value = value.to_value();
        let old_raw = self.raw;
        self.raw = (old_raw & !0x80000000) | (value << 31);
        self
    }

    pub fn set_connect_with<F: Fn(&mut CONNECT_FIELD) -> &mut CONNECT_FIELD>(
        &mut self,
        f: F,
    ) -> &mut Self {
        let mut value = self.connect();
        f(&mut value);
        self.set_connect(value)
    }
}

enum_def_with_unknown!(#[allow(non_camel_case_types)] CONNECT_FIELD u32 =>
                // Disconnect
                Disconnected = 1,
// Connect
                Connected = 0

            );

impl CONNECT_FIELD {
    pub fn is_disconnected(&self) -> bool {
        *self == Self::Disconnected
    }

    pub fn set_disconnected(&mut self) -> &mut Self {
        *self = Self::Disconnected;
        self
    }

    pub fn is_connected(&self) -> bool {
        *self == Self::Connected
    }

    pub fn set_connected(&mut self) -> &mut Self {
        *self = Self::Connected;
        self
    }
}

pub mod ficr {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct FICR {
        _hidden: (),
    }

    impl FICR {
        const BASE_ADDRESS: u32 = 0x10000000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for FICR {
        type Target = FICR_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for FICR {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct FICR_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 16],
        /// Code memory page size
        pub codepagesize: codepagesize::CODEPAGESIZE,
        /// Code memory size
        pub codesize: codesize::CODESIZE,
        _padding_24: [u8; 72],
        /// Description collection: Device identifier
        pub deviceid: [deviceid::DEVICEID; 2],
        _padding_104: [u8; 24],
        /// Description collection: Encryption root, word n
        pub er: [er::ER; 4],
        /// Description collection: Identity Root, word n
        pub ir: [ir::IR; 4],
        /// Device address type
        pub deviceaddrtype: deviceaddrtype::DEVICEADDRTYPE,
        /// Description collection: Device address n
        pub deviceaddr: [deviceaddr::DEVICEADDR; 2],
        _padding_172: [u8; 84],
        pub info: info::INFO,
        _padding_276: [u8; 572],
        /// Description collection: Production test signature n
        pub prodtest: [prodtest::PRODTEST; 3],
        _padding_860: [u8; 168],
        pub temp: temp::TEMP,
        _padding_1096: [u8; 8],
        pub nfc: nfc::NFC,
    }

    pub mod codepagesize {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CODEPAGESIZE {
            raw: RawRegister<u32>,
        }

        impl CODEPAGESIZE {}

        impl RegisterRead for CODEPAGESIZE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod codesize {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CODESIZE {
            raw: RawRegister<u32>,
        }

        impl CODESIZE {}

        impl RegisterRead for CODESIZE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod deviceid {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DEVICEID {
            raw: RawRegister<u32>,
        }

        impl DEVICEID {}

        impl RegisterRead for DEVICEID {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod er {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ER {
            raw: RawRegister<u32>,
        }

        impl ER {}

        impl RegisterRead for ER {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod ir {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct IR {
            raw: RawRegister<u32>,
        }

        impl IR {}

        impl RegisterRead for IR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod deviceaddrtype {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DEVICEADDRTYPE {
            raw: RawRegister<u32>,
        }

        impl DEVICEADDRTYPE {}

        impl RegisterRead for DEVICEADDRTYPE {
            type Value = DEVICEADDRTYPE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                DEVICEADDRTYPE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DEVICEADDRTYPE_FIELD u32 =>
                        // Public address
                        Public = 0,
        // Random address
                        Random = 1

                    );

        impl DEVICEADDRTYPE_FIELD {
            pub fn is_public(&self) -> bool {
                *self == Self::Public
            }

            pub fn set_public(&mut self) -> &mut Self {
                *self = Self::Public;
                self
            }

            pub fn is_random(&self) -> bool {
                *self == Self::Random
            }

            pub fn set_random(&mut self) -> &mut Self {
                *self = Self::Random;
                self
            }
        }
    }

    pub mod deviceaddr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DEVICEADDR {
            raw: RawRegister<u32>,
        }

        impl DEVICEADDR {}

        impl RegisterRead for DEVICEADDR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod info {
        #[allow(unused_imports)]
        use super::*;

        /// Device info
        #[repr(C)]
        pub struct INFO {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Part code
            pub part: part::PART,
            /// Build code (hardware version and production configuration)
            pub variant: variant::VARIANT,
            /// Package option
            pub package: package::PACKAGE,
            /// RAM variant
            pub ram: ram::RAM,
            /// Flash variant
            pub flash: flash::FLASH,
        }

        pub mod part {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PART {
                raw: RawRegister<u32>,
            }

            impl PART {}

            impl RegisterRead for PART {
                type Value = PART_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    PART_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PART_FIELD u32 =>
                            // nRF52820
                            N52820 = 337952,
            // nRF52833
                            N52833 = 337971,
            // nRF52840
                            N52840 = 337984,
            // Unspecified
                            Unspecified = 4294967295

                        );

            impl PART_FIELD {
                pub fn is_n52820(&self) -> bool {
                    *self == Self::N52820
                }

                pub fn set_n52820(&mut self) -> &mut Self {
                    *self = Self::N52820;
                    self
                }

                pub fn is_n52833(&self) -> bool {
                    *self == Self::N52833
                }

                pub fn set_n52833(&mut self) -> &mut Self {
                    *self = Self::N52833;
                    self
                }

                pub fn is_n52840(&self) -> bool {
                    *self == Self::N52840
                }

                pub fn set_n52840(&mut self) -> &mut Self {
                    *self = Self::N52840;
                    self
                }

                pub fn is_unspecified(&self) -> bool {
                    *self == Self::Unspecified
                }

                pub fn set_unspecified(&mut self) -> &mut Self {
                    *self = Self::Unspecified;
                    self
                }
            }
        }

        pub mod variant {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct VARIANT {
                raw: RawRegister<u32>,
            }

            impl VARIANT {}

            impl RegisterRead for VARIANT {
                type Value = VARIANT_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    VARIANT_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] VARIANT_FIELD u32 =>
                            // AAAA
                            AAAA = 1094795585,
            // AAAB
                            AAAB = 1094795586,
            // AAA0
                            AAA0 = 1094795568,
            // AAA1
                            AAA1 = 1094795569,
            // AAB0
                            AAB0 = 1094795824,
            // Unspecified
                            Unspecified = 4294967295

                        );

            impl VARIANT_FIELD {
                pub fn is_aaaa(&self) -> bool {
                    *self == Self::AAAA
                }

                pub fn set_aaaa(&mut self) -> &mut Self {
                    *self = Self::AAAA;
                    self
                }

                pub fn is_aaab(&self) -> bool {
                    *self == Self::AAAB
                }

                pub fn set_aaab(&mut self) -> &mut Self {
                    *self = Self::AAAB;
                    self
                }

                pub fn is_aaa0(&self) -> bool {
                    *self == Self::AAA0
                }

                pub fn set_aaa0(&mut self) -> &mut Self {
                    *self = Self::AAA0;
                    self
                }

                pub fn is_aaa1(&self) -> bool {
                    *self == Self::AAA1
                }

                pub fn set_aaa1(&mut self) -> &mut Self {
                    *self = Self::AAA1;
                    self
                }

                pub fn is_aab0(&self) -> bool {
                    *self == Self::AAB0
                }

                pub fn set_aab0(&mut self) -> &mut Self {
                    *self = Self::AAB0;
                    self
                }

                pub fn is_unspecified(&self) -> bool {
                    *self == Self::Unspecified
                }

                pub fn set_unspecified(&mut self) -> &mut Self {
                    *self = Self::Unspecified;
                    self
                }
            }
        }

        pub mod package {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PACKAGE {
                raw: RawRegister<u32>,
            }

            impl PACKAGE {}

            impl RegisterRead for PACKAGE {
                type Value = PACKAGE_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    PACKAGE_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PACKAGE_FIELD u32 =>
                            // QDxx - 5x5 40-pin QFN
                            QD = 8199,
            // QIxx - 7x7 73-pin aQFN
                            QI = 8196,
            // CJxx - 3.175 x 3.175 WLCSP
                            CJ = 8200,
            // Unspecified
                            Unspecified = 4294967295

                        );

            impl PACKAGE_FIELD {
                pub fn is_qd(&self) -> bool {
                    *self == Self::QD
                }

                pub fn set_qd(&mut self) -> &mut Self {
                    *self = Self::QD;
                    self
                }

                pub fn is_qi(&self) -> bool {
                    *self == Self::QI
                }

                pub fn set_qi(&mut self) -> &mut Self {
                    *self = Self::QI;
                    self
                }

                pub fn is_cj(&self) -> bool {
                    *self == Self::CJ
                }

                pub fn set_cj(&mut self) -> &mut Self {
                    *self = Self::CJ;
                    self
                }

                pub fn is_unspecified(&self) -> bool {
                    *self == Self::Unspecified
                }

                pub fn set_unspecified(&mut self) -> &mut Self {
                    *self = Self::Unspecified;
                    self
                }
            }
        }

        pub mod ram {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct RAM {
                raw: RawRegister<u32>,
            }

            impl RAM {}

            impl RegisterRead for RAM {
                type Value = RAM_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    RAM_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] RAM_FIELD u32 =>
                            // 16 kByte RAM
                            K16 = 16,
            // 32 kByte RAM
                            K32 = 32,
            // 64 kByte RAM
                            K64 = 64,
            // 128 kByte RAM
                            K128 = 128,
            // 256 kByte RAM
                            K256 = 256,
            // Unspecified
                            Unspecified = 4294967295

                        );

            impl RAM_FIELD {
                pub fn is_k16(&self) -> bool {
                    *self == Self::K16
                }

                pub fn set_k16(&mut self) -> &mut Self {
                    *self = Self::K16;
                    self
                }

                pub fn is_k32(&self) -> bool {
                    *self == Self::K32
                }

                pub fn set_k32(&mut self) -> &mut Self {
                    *self = Self::K32;
                    self
                }

                pub fn is_k64(&self) -> bool {
                    *self == Self::K64
                }

                pub fn set_k64(&mut self) -> &mut Self {
                    *self = Self::K64;
                    self
                }

                pub fn is_k128(&self) -> bool {
                    *self == Self::K128
                }

                pub fn set_k128(&mut self) -> &mut Self {
                    *self = Self::K128;
                    self
                }

                pub fn is_k256(&self) -> bool {
                    *self == Self::K256
                }

                pub fn set_k256(&mut self) -> &mut Self {
                    *self = Self::K256;
                    self
                }

                pub fn is_unspecified(&self) -> bool {
                    *self == Self::Unspecified
                }

                pub fn set_unspecified(&mut self) -> &mut Self {
                    *self = Self::Unspecified;
                    self
                }
            }
        }

        pub mod flash {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct FLASH {
                raw: RawRegister<u32>,
            }

            impl FLASH {}

            impl RegisterRead for FLASH {
                type Value = FLASH_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    FLASH_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] FLASH_FIELD u32 =>
                            // 128 kByte FLASH
                            K128 = 128,
            // 256 kByte FLASH
                            K256 = 256,
            // 512 kByte FLASH
                            K512 = 512,
            // 1 MByte FLASH
                            K1024 = 1024,
            // 2 MByte FLASH
                            K2048 = 2048,
            // Unspecified
                            Unspecified = 4294967295

                        );

            impl FLASH_FIELD {
                pub fn is_k128(&self) -> bool {
                    *self == Self::K128
                }

                pub fn set_k128(&mut self) -> &mut Self {
                    *self = Self::K128;
                    self
                }

                pub fn is_k256(&self) -> bool {
                    *self == Self::K256
                }

                pub fn set_k256(&mut self) -> &mut Self {
                    *self = Self::K256;
                    self
                }

                pub fn is_k512(&self) -> bool {
                    *self == Self::K512
                }

                pub fn set_k512(&mut self) -> &mut Self {
                    *self = Self::K512;
                    self
                }

                pub fn is_k1024(&self) -> bool {
                    *self == Self::K1024
                }

                pub fn set_k1024(&mut self) -> &mut Self {
                    *self = Self::K1024;
                    self
                }

                pub fn is_k2048(&self) -> bool {
                    *self == Self::K2048
                }

                pub fn set_k2048(&mut self) -> &mut Self {
                    *self = Self::K2048;
                    self
                }

                pub fn is_unspecified(&self) -> bool {
                    *self == Self::Unspecified
                }

                pub fn set_unspecified(&mut self) -> &mut Self {
                    *self = Self::Unspecified;
                    self
                }
            }
        }
    }

    pub mod prodtest {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PRODTEST {
            raw: RawRegister<u32>,
        }

        impl PRODTEST {}

        impl RegisterRead for PRODTEST {
            type Value = PRODTEST_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                PRODTEST_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRODTEST_FIELD u32 =>
                        // Production tests done
                        Done = 3141677471,
        // Production tests not done
                        NotDone = 4294967295

                    );

        impl PRODTEST_FIELD {
            pub fn is_done(&self) -> bool {
                *self == Self::Done
            }

            pub fn set_done(&mut self) -> &mut Self {
                *self = Self::Done;
                self
            }

            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }
        }
    }

    pub mod temp {
        #[allow(unused_imports)]
        use super::*;

        /// Registers storing factory TEMP module linearization coefficients
        #[repr(C)]
        pub struct TEMP {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Slope definition A0
            pub a0: a0::A0,
            /// Slope definition A1
            pub a1: a1::A1,
            /// Slope definition A2
            pub a2: a2::A2,
            /// Slope definition A3
            pub a3: a3::A3,
            /// Slope definition A4
            pub a4: a4::A4,
            /// Slope definition A5
            pub a5: a5::A5,
            /// Y-intercept B0
            pub b0: b0::B0,
            /// Y-intercept B1
            pub b1: b1::B1,
            /// Y-intercept B2
            pub b2: b2::B2,
            /// Y-intercept B3
            pub b3: b3::B3,
            /// Y-intercept B4
            pub b4: b4::B4,
            /// Y-intercept B5
            pub b5: b5::B5,
            /// Segment end T0
            pub t0: t0::T0,
            /// Segment end T1
            pub t1: t1::T1,
            /// Segment end T2
            pub t2: t2::T2,
            /// Segment end T3
            pub t3: t3::T3,
            /// Segment end T4
            pub t4: t4::T4,
        }

        pub mod a0 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A0 {
                raw: RawRegister<u32>,
            }

            impl A0 {}

            impl RegisterRead for A0 {
                type Value = A0_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A0_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A0_READ_VALUE {
                raw: u32,
            }

            impl A0_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod a1 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A1 {
                raw: RawRegister<u32>,
            }

            impl A1 {}

            impl RegisterRead for A1 {
                type Value = A1_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A1_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A1_READ_VALUE {
                raw: u32,
            }

            impl A1_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod a2 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A2 {
                raw: RawRegister<u32>,
            }

            impl A2 {}

            impl RegisterRead for A2 {
                type Value = A2_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A2_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A2_READ_VALUE {
                raw: u32,
            }

            impl A2_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod a3 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A3 {
                raw: RawRegister<u32>,
            }

            impl A3 {}

            impl RegisterRead for A3 {
                type Value = A3_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A3_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A3_READ_VALUE {
                raw: u32,
            }

            impl A3_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod a4 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A4 {
                raw: RawRegister<u32>,
            }

            impl A4 {}

            impl RegisterRead for A4 {
                type Value = A4_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A4_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A4_READ_VALUE {
                raw: u32,
            }

            impl A4_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod a5 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct A5 {
                raw: RawRegister<u32>,
            }

            impl A5 {}

            impl RegisterRead for A5 {
                type Value = A5_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    A5_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct A5_READ_VALUE {
                raw: u32,
            }

            impl A5_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn a(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000fff) >> 0
                }

                pub fn set_a(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b0 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B0 {
                raw: RawRegister<u32>,
            }

            impl B0 {}

            impl RegisterRead for B0 {
                type Value = B0_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B0_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B0_READ_VALUE {
                raw: u32,
            }

            impl B0_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b1 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B1 {
                raw: RawRegister<u32>,
            }

            impl B1 {}

            impl RegisterRead for B1 {
                type Value = B1_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B1_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B1_READ_VALUE {
                raw: u32,
            }

            impl B1_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b2 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B2 {
                raw: RawRegister<u32>,
            }

            impl B2 {}

            impl RegisterRead for B2 {
                type Value = B2_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B2_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B2_READ_VALUE {
                raw: u32,
            }

            impl B2_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b3 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B3 {
                raw: RawRegister<u32>,
            }

            impl B3 {}

            impl RegisterRead for B3 {
                type Value = B3_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B3_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B3_READ_VALUE {
                raw: u32,
            }

            impl B3_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b4 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B4 {
                raw: RawRegister<u32>,
            }

            impl B4 {}

            impl RegisterRead for B4 {
                type Value = B4_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B4_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B4_READ_VALUE {
                raw: u32,
            }

            impl B4_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod b5 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct B5 {
                raw: RawRegister<u32>,
            }

            impl B5 {}

            impl RegisterRead for B5 {
                type Value = B5_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    B5_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct B5_READ_VALUE {
                raw: u32,
            }

            impl B5_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn b(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00003fff) >> 0
                }

                pub fn set_b(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00003fff) | (value << 0);
                    self
                }
            }
        }

        pub mod t0 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct T0 {
                raw: RawRegister<u32>,
            }

            impl T0 {}

            impl RegisterRead for T0 {
                type Value = T0_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    T0_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct T0_READ_VALUE {
                raw: u32,
            }

            impl T0_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn t(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_t(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }
            }
        }

        pub mod t1 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct T1 {
                raw: RawRegister<u32>,
            }

            impl T1 {}

            impl RegisterRead for T1 {
                type Value = T1_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    T1_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct T1_READ_VALUE {
                raw: u32,
            }

            impl T1_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn t(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_t(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }
            }
        }

        pub mod t2 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct T2 {
                raw: RawRegister<u32>,
            }

            impl T2 {}

            impl RegisterRead for T2 {
                type Value = T2_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    T2_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct T2_READ_VALUE {
                raw: u32,
            }

            impl T2_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn t(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_t(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }
            }
        }

        pub mod t3 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct T3 {
                raw: RawRegister<u32>,
            }

            impl T3 {}

            impl RegisterRead for T3 {
                type Value = T3_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    T3_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct T3_READ_VALUE {
                raw: u32,
            }

            impl T3_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn t(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_t(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }
            }
        }

        pub mod t4 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct T4 {
                raw: RawRegister<u32>,
            }

            impl T4 {}

            impl RegisterRead for T4 {
                type Value = T4_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    T4_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct T4_READ_VALUE {
                raw: u32,
            }

            impl T4_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn t(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_t(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }
            }
        }
    }

    pub mod nfc {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct NFC {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Default header for NFC tag. Software can read these values to
            /// populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
            pub tagheader0: tagheader0::TAGHEADER0,
            /// Default header for NFC tag. Software can read these values to
            /// populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
            pub tagheader1: tagheader1::TAGHEADER1,
            /// Default header for NFC tag. Software can read these values to
            /// populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
            pub tagheader2: tagheader2::TAGHEADER2,
            /// Default header for NFC tag. Software can read these values to
            /// populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST.
            pub tagheader3: tagheader3::TAGHEADER3,
        }

        pub mod tagheader0 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TAGHEADER0 {
                raw: RawRegister<u32>,
            }

            impl TAGHEADER0 {}

            impl RegisterRead for TAGHEADER0 {
                type Value = TAGHEADER0_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    TAGHEADER0_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct TAGHEADER0_READ_VALUE {
                raw: u32,
            }

            impl TAGHEADER0_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn mfgid(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_mfgid(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }

                pub fn ud1(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000ff00) >> 8
                }

                pub fn set_ud1(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ff00) | (value << 8);
                    self
                }

                pub fn ud2(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00ff0000) >> 16
                }

                pub fn set_ud2(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ff0000) | (value << 16);
                    self
                }

                pub fn ud3(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xff000000) >> 24
                }

                pub fn set_ud3(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xff000000) | (value << 24);
                    self
                }
            }
        }

        pub mod tagheader1 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TAGHEADER1 {
                raw: RawRegister<u32>,
            }

            impl TAGHEADER1 {}

            impl RegisterRead for TAGHEADER1 {
                type Value = TAGHEADER1_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    TAGHEADER1_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct TAGHEADER1_READ_VALUE {
                raw: u32,
            }

            impl TAGHEADER1_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn ud4(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_ud4(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }

                pub fn ud5(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000ff00) >> 8
                }

                pub fn set_ud5(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ff00) | (value << 8);
                    self
                }

                pub fn ud6(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00ff0000) >> 16
                }

                pub fn set_ud6(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ff0000) | (value << 16);
                    self
                }

                pub fn ud7(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xff000000) >> 24
                }

                pub fn set_ud7(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xff000000) | (value << 24);
                    self
                }
            }
        }

        pub mod tagheader2 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TAGHEADER2 {
                raw: RawRegister<u32>,
            }

            impl TAGHEADER2 {}

            impl RegisterRead for TAGHEADER2 {
                type Value = TAGHEADER2_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    TAGHEADER2_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct TAGHEADER2_READ_VALUE {
                raw: u32,
            }

            impl TAGHEADER2_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn ud8(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_ud8(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }

                pub fn ud9(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000ff00) >> 8
                }

                pub fn set_ud9(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ff00) | (value << 8);
                    self
                }

                pub fn ud10(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00ff0000) >> 16
                }

                pub fn set_ud10(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ff0000) | (value << 16);
                    self
                }

                pub fn ud11(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xff000000) >> 24
                }

                pub fn set_ud11(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xff000000) | (value << 24);
                    self
                }
            }
        }

        pub mod tagheader3 {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TAGHEADER3 {
                raw: RawRegister<u32>,
            }

            impl TAGHEADER3 {}

            impl RegisterRead for TAGHEADER3 {
                type Value = TAGHEADER3_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    TAGHEADER3_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct TAGHEADER3_READ_VALUE {
                raw: u32,
            }

            impl TAGHEADER3_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn ud12(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000000ff) >> 0
                }

                pub fn set_ud12(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000000ff) | (value << 0);
                    self
                }

                pub fn ud13(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000ff00) >> 8
                }

                pub fn set_ud13(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ff00) | (value << 8);
                    self
                }

                pub fn ud14(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00ff0000) >> 16
                }

                pub fn set_ud14(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ff0000) | (value << 16);
                    self
                }

                pub fn ud15(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xff000000) >> 24
                }

                pub fn set_ud15(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xff000000) | (value << 24);
                    self
                }
            }
        }
    }
}

pub mod uicr {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct UICR {
        _hidden: (),
    }

    impl UICR {
        const BASE_ADDRESS: u32 = 0x10001000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for UICR {
        type Target = UICR_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for UICR {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct UICR_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 20],
        /// Description collection: Reserved for Nordic firmware design
        pub nrffw: [nrffw::NRFFW; 13],
        _padding_72: [u8; 8],
        /// Description collection: Reserved for Nordic hardware design
        pub nrfhw: [nrfhw::NRFHW; 12],
        /// Description collection: Reserved for customer
        pub customer: [customer::CUSTOMER; 32],
        _padding_256: [u8; 256],
        /// Description collection: Mapping of the nRESET function (see POWER
        /// chapter for details)
        pub pselreset: [pselreset::PSELRESET; 2],
        /// Access port protection
        pub approtect: approtect::APPROTECT,
        /// Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
        pub nfcpins: nfcpins::NFCPINS,
        /// Processor debug control
        pub debugctrl: debugctrl::DEBUGCTRL,
        _padding_532: [u8; 240],
        /// Output voltage from REG0 regulator stage. The maximum output voltage
        /// from this stage is given as VDDH - V_VDDH-VDD.
        pub regout0: regout0::REGOUT0,
    }

    pub mod nrffw {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NRFFW {
            raw: RawRegister<u32>,
        }

        impl NRFFW {}

        impl RegisterRead for NRFFW {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for NRFFW {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod nrfhw {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NRFHW {
            raw: RawRegister<u32>,
        }

        impl NRFHW {}

        impl RegisterRead for NRFHW {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for NRFHW {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod customer {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CUSTOMER {
            raw: RawRegister<u32>,
        }

        impl CUSTOMER {}

        impl RegisterRead for CUSTOMER {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for CUSTOMER {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod pselreset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PSELRESET {
            raw: RawRegister<u32>,
        }

        impl PSELRESET {
            pub fn write_with<F: Fn(&mut PSELRESET_VALUE) -> &mut PSELRESET_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = PSELRESET_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PSELRESET {
            type Value = PSELRESET_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PSELRESET_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PSELRESET {
            type Value = PSELRESET_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PSELRESET_VALUE {
            raw: u32,
        }

        impl PSELRESET_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000001f) >> 0
            }

            pub fn set_pin(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn port(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000020) >> 5
            }

            pub fn set_port(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn connect(&self) -> CONNECT_FIELD {
                let raw = self.raw;
                CONNECT_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_connect(&mut self, value: CONNECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_connect_with<F: Fn(&mut CONNECT_FIELD) -> &mut CONNECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.connect();
                f(&mut value);
                self.set_connect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CONNECT_FIELD u32 =>
                        // Disconnect
                        Disconnected = 1,
        // Connect
                        Connected = 0

                    );

        impl CONNECT_FIELD {
            pub fn is_disconnected(&self) -> bool {
                *self == Self::Disconnected
            }

            pub fn set_disconnected(&mut self) -> &mut Self {
                *self = Self::Disconnected;
                self
            }

            pub fn is_connected(&self) -> bool {
                *self == Self::Connected
            }

            pub fn set_connected(&mut self) -> &mut Self {
                *self = Self::Connected;
                self
            }
        }
    }

    pub mod approtect {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct APPROTECT {
            raw: RawRegister<u32>,
        }

        impl APPROTECT {
            pub fn write_with<F: Fn(&mut APPROTECT_VALUE) -> &mut APPROTECT_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = APPROTECT_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for APPROTECT {
            type Value = APPROTECT_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                APPROTECT_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for APPROTECT {
            type Value = APPROTECT_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct APPROTECT_VALUE {
            raw: u32,
        }

        impl APPROTECT_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pall(&self) -> PALL_FIELD {
                let raw = self.raw;
                PALL_FIELD::from_value((raw & 0x000000ff) >> 0)
            }

            pub fn set_pall(&mut self, value: PALL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn set_pall_with<F: Fn(&mut PALL_FIELD) -> &mut PALL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pall();
                f(&mut value);
                self.set_pall(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PALL_FIELD u32 =>
                        // Hardware disable of access port protection for devices where access port protection is controlled by hardware
                        Disabled = 255,
        // Hardware disable of access port protection for devices where access port protection is controlled by hardware and software
                        HwDisabled = 90,
        // Enable
                        Enabled = 0

                    );

        impl PALL_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_hwdisabled(&self) -> bool {
                *self == Self::HwDisabled
            }

            pub fn set_hwdisabled(&mut self) -> &mut Self {
                *self = Self::HwDisabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod nfcpins {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NFCPINS {
            raw: RawRegister<u32>,
        }

        impl NFCPINS {
            pub fn write_with<F: Fn(&mut NFCPINS_VALUE) -> &mut NFCPINS_VALUE>(&mut self, f: F) {
                let mut v = NFCPINS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NFCPINS {
            type Value = NFCPINS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NFCPINS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NFCPINS {
            type Value = NFCPINS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NFCPINS_VALUE {
            raw: u32,
        }

        impl NFCPINS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn protect(&self) -> PROTECT_FIELD {
                let raw = self.raw;
                PROTECT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_protect(&mut self, value: PROTECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_protect_with<F: Fn(&mut PROTECT_FIELD) -> &mut PROTECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.protect();
                f(&mut value);
                self.set_protect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PROTECT_FIELD u32 =>
                        // Operation as GPIO pins. Same protection as normal GPIO pins.
                        Disabled = 0,
        // Operation as NFC antenna pins. Configures the protection for NFC operation.
                        NFC = 1

                    );

        impl PROTECT_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_nfc(&self) -> bool {
                *self == Self::NFC
            }

            pub fn set_nfc(&mut self) -> &mut Self {
                *self = Self::NFC;
                self
            }
        }
    }

    pub mod debugctrl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DEBUGCTRL {
            raw: RawRegister<u32>,
        }

        impl DEBUGCTRL {
            pub fn write_with<F: Fn(&mut DEBUGCTRL_VALUE) -> &mut DEBUGCTRL_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = DEBUGCTRL_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DEBUGCTRL {
            type Value = DEBUGCTRL_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DEBUGCTRL_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DEBUGCTRL {
            type Value = DEBUGCTRL_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DEBUGCTRL_VALUE {
            raw: u32,
        }

        impl DEBUGCTRL_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cpuniden(&self) -> CPUNIDEN_FIELD {
                let raw = self.raw;
                CPUNIDEN_FIELD::from_value((raw & 0x000000ff) >> 0)
            }

            pub fn set_cpuniden(&mut self, value: CPUNIDEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn set_cpuniden_with<F: Fn(&mut CPUNIDEN_FIELD) -> &mut CPUNIDEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpuniden();
                f(&mut value);
                self.set_cpuniden(value)
            }

            pub fn cpufpben(&self) -> CPUFPBEN_FIELD {
                let raw = self.raw;
                CPUFPBEN_FIELD::from_value((raw & 0x0000ff00) >> 8)
            }

            pub fn set_cpufpben(&mut self, value: CPUFPBEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn set_cpufpben_with<F: Fn(&mut CPUFPBEN_FIELD) -> &mut CPUFPBEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpufpben();
                f(&mut value);
                self.set_cpufpben(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPUNIDEN_FIELD u32 =>
                        // Enable CPU ITM and ETM functionality (default behavior)
                        Enabled = 255,
        // Disable CPU ITM and ETM functionality
                        Disabled = 0

                    );

        impl CPUNIDEN_FIELD {
            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }

            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPUFPBEN_FIELD u32 =>
                        // Enable CPU FPB unit (default behavior)
                        Enabled = 255,
        // Disable CPU FPB unit. Writes into the FPB registers will be ignored.
                        Disabled = 0

                    );

        impl CPUFPBEN_FIELD {
            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }

            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }
        }
    }

    pub mod regout0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REGOUT0 {
            raw: RawRegister<u32>,
        }

        impl REGOUT0 {
            pub fn write_with<F: Fn(&mut REGOUT0_VALUE) -> &mut REGOUT0_VALUE>(&mut self, f: F) {
                let mut v = REGOUT0_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for REGOUT0 {
            type Value = REGOUT0_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                REGOUT0_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for REGOUT0 {
            type Value = REGOUT0_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGOUT0_VALUE {
            raw: u32,
        }

        impl REGOUT0_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn vout(&self) -> VOUT_FIELD {
                let raw = self.raw;
                VOUT_FIELD::from_value((raw & 0x00000007) >> 0)
            }

            pub fn set_vout(&mut self, value: VOUT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn set_vout_with<F: Fn(&mut VOUT_FIELD) -> &mut VOUT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.vout();
                f(&mut value);
                self.set_vout(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VOUT_FIELD u32 =>
                        // 1.8 V
                        _1V8 = 0,
        // 2.1 V
                        _2V1 = 1,
        // 2.4 V
                        _2V4 = 2,
        // 2.7 V
                        _2V7 = 3,
        // 3.0 V
                        _3V0 = 4,
        // 3.3 V
                        _3V3 = 5,
        // Default voltage: 1.8 V
                        DEFAULT = 7

                    );

        impl VOUT_FIELD {
            pub fn is_1v8(&self) -> bool {
                *self == Self::_1V8
            }

            pub fn set_1v8(&mut self) -> &mut Self {
                *self = Self::_1V8;
                self
            }

            pub fn is_2v1(&self) -> bool {
                *self == Self::_2V1
            }

            pub fn set_2v1(&mut self) -> &mut Self {
                *self = Self::_2V1;
                self
            }

            pub fn is_2v4(&self) -> bool {
                *self == Self::_2V4
            }

            pub fn set_2v4(&mut self) -> &mut Self {
                *self = Self::_2V4;
                self
            }

            pub fn is_2v7(&self) -> bool {
                *self == Self::_2V7
            }

            pub fn set_2v7(&mut self) -> &mut Self {
                *self = Self::_2V7;
                self
            }

            pub fn is_3v0(&self) -> bool {
                *self == Self::_3V0
            }

            pub fn set_3v0(&mut self) -> &mut Self {
                *self = Self::_3V0;
                self
            }

            pub fn is_3v3(&self) -> bool {
                *self == Self::_3V3
            }

            pub fn set_3v3(&mut self) -> &mut Self {
                *self = Self::_3V3;
                self
            }

            pub fn is_default(&self) -> bool {
                *self == Self::DEFAULT
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::DEFAULT;
                self
            }
        }
    }
}

pub mod approtect {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct APPROTECT {
        _hidden: (),
    }

    impl APPROTECT {
        const BASE_ADDRESS: u32 = 0x40000000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for APPROTECT {
        type Target = APPROTECT_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for APPROTECT {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct APPROTECT_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 1360],
        /// Software force enable APPROTECT mechanism until next reset.
        pub forceprotect: forceprotect::FORCEPROTECT,
        _padding_1364: [u8; 4],
        /// Software disable APPROTECT mechanism
        pub disable: disable::DISABLE,
    }

    pub mod forceprotect {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FORCEPROTECT {
            raw: RawRegister<u32>,
        }

        impl FORCEPROTECT {
            pub fn write_force(&mut self) {
                self.write(FORCEPROTECT_WRITE_FIELD::Force)
            }
        }

        impl RegisterRead for FORCEPROTECT {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for FORCEPROTECT {
            type Value = FORCEPROTECT_WRITE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FORCEPROTECT_WRITE_FIELD u32 =>
            // Software force enable APPROTECT mechanism
            Force = 0

        );

        impl FORCEPROTECT_WRITE_FIELD {
            pub fn is_force(&self) -> bool {
                *self == Self::Force
            }

            pub fn set_force(&mut self) -> &mut Self {
                *self = Self::Force;
                self
            }
        }
    }

    pub mod disable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DISABLE {
            raw: RawRegister<u32>,
        }

        impl DISABLE {
            pub fn write_swdisable(&mut self) {
                self.write(DISABLE_FIELD::SwDisable)
            }
        }

        impl RegisterRead for DISABLE {
            type Value = DISABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                DISABLE_FIELD::from_value((raw & 0x000000ff) >> 0)
            }
        }

        impl RegisterWrite for DISABLE {
            type Value = DISABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DISABLE_FIELD u32 =>
            // Software disable APPROTECT mechanism
            SwDisable = 90

        );

        impl DISABLE_FIELD {
            pub fn is_swdisable(&self) -> bool {
                *self == Self::SwDisable
            }

            pub fn set_swdisable(&mut self) -> &mut Self {
                *self = Self::SwDisable;
                self
            }
        }
    }
}

pub mod clock {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct CLOCK {
        _hidden: (),
    }

    impl CLOCK {
        const BASE_ADDRESS: u32 = 0x40000000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for CLOCK {
        type Target = CLOCK_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for CLOCK {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct CLOCK_REGISTERS {
        _hidden: (),
        /// Start HFXO crystal oscillator
        pub tasks_hfclkstart: TaskRegister,
        /// Stop HFXO crystal oscillator
        pub tasks_hfclkstop: TaskRegister,
        /// Start LFCLK
        pub tasks_lfclkstart: TaskRegister,
        /// Stop LFCLK
        pub tasks_lfclkstop: TaskRegister,
        /// Start calibration of LFRC
        pub tasks_cal: TaskRegister,
        /// Start calibration timer
        pub tasks_ctstart: TaskRegister,
        /// Stop calibration timer
        pub tasks_ctstop: TaskRegister,
        _padding_28: [u8; 228],
        /// HFXO crystal oscillator started
        pub events_hfclkstarted: EventRegister,
        /// LFCLK started
        pub events_lfclkstarted: EventRegister,
        _padding_264: [u8; 4],
        /// Calibration of LFRC completed
        pub events_done: EventRegister,
        /// Calibration timer timeout
        pub events_ctto: EventRegister,
        _padding_276: [u8; 20],
        /// Calibration timer has been started and is ready to process new tasks
        pub events_ctstarted: EventRegister,
        /// Calibration timer has been stopped and is ready to process new tasks
        pub events_ctstopped: EventRegister,
        _padding_304: [u8; 468],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 252],
        /// Status indicating that HFCLKSTART task has been triggered
        pub hfclkrun: hfclkrun::HFCLKRUN,
        /// HFCLK status
        pub hfclkstat: hfclkstat::HFCLKSTAT,
        _padding_1040: [u8; 4],
        /// Status indicating that LFCLKSTART task has been triggered
        pub lfclkrun: lfclkrun::LFCLKRUN,
        /// LFCLK status
        pub lfclkstat: lfclkstat::LFCLKSTAT,
        /// Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
        pub lfclksrccopy: lfclksrccopy::LFCLKSRCCOPY,
        _padding_1056: [u8; 248],
        /// Clock source for the LFCLK
        pub lfclksrc: lfclksrc::LFCLKSRC,
        _padding_1308: [u8; 12],
        /// HFXO debounce time. The HFXO is started by triggering the
        /// TASKS_HFCLKSTART task.
        pub hfxodebounce: hfxodebounce::HFXODEBOUNCE,
        /// LFXO debounce time. The LFXO is started by triggering the
        /// TASKS_LFCLKSTART task when the LFCLKSRC register is configured for
        /// Xtal.
        pub lfxodebounce: lfxodebounce::LFXODEBOUNCE,
        _padding_1328: [u8; 8],
        /// Calibration timer interval
        pub ctiv: ctiv::CTIV,
        _padding_1340: [u8; 32],
        /// Clocking options for the trace port debug interface
        pub traceconfig: traceconfig::TRACECONFIG,
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn hfclkstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_hfclkstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_hfclkstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.hfclkstarted();
                f(&mut value);
                self.set_hfclkstarted(value)
            }

            pub fn lfclkstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_lfclkstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_lfclkstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lfclkstarted();
                f(&mut value);
                self.set_lfclkstarted(value)
            }

            pub fn done(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_done(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_done_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.done();
                f(&mut value);
                self.set_done(value)
            }

            pub fn ctto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ctto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ctto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctto();
                f(&mut value);
                self.set_ctto(value)
            }

            pub fn ctstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ctstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ctstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctstarted();
                f(&mut value);
                self.set_ctstarted(value)
            }

            pub fn ctstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ctstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ctstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctstopped();
                f(&mut value);
                self.set_ctstopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_hfclkstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_lfclkstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_done(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ctto(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ctstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ctstopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn hfclkstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_hfclkstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_hfclkstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.hfclkstarted();
                f(&mut value);
                self.set_hfclkstarted(value)
            }

            pub fn lfclkstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_lfclkstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_lfclkstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lfclkstarted();
                f(&mut value);
                self.set_lfclkstarted(value)
            }

            pub fn done(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_done(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_done_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.done();
                f(&mut value);
                self.set_done(value)
            }

            pub fn ctto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ctto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ctto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctto();
                f(&mut value);
                self.set_ctto(value)
            }

            pub fn ctstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ctstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ctstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctstarted();
                f(&mut value);
                self.set_ctstarted(value)
            }

            pub fn ctstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ctstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ctstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctstopped();
                f(&mut value);
                self.set_ctstopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_hfclkstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_lfclkstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_done(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ctto(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ctstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ctstopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }
        }
    }

    pub mod hfclkrun {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HFCLKRUN {
            raw: RawRegister<u32>,
        }

        impl HFCLKRUN {}

        impl RegisterRead for HFCLKRUN {
            type Value = HFCLKRUN_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                HFCLKRUN_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct HFCLKRUN_READ_VALUE {
            raw: u32,
        }

        impl HFCLKRUN_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn status(&self) -> STATUS_FIELD {
                let raw = self.raw;
                STATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_status(&mut self, value: STATUS_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_status_with<F: Fn(&mut STATUS_FIELD) -> &mut STATUS_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.status();
                f(&mut value);
                self.set_status(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATUS_FIELD u32 =>
                        // Task not triggered
                        NotTriggered = 0,
        // Task triggered
                        Triggered = 1

                    );

        impl STATUS_FIELD {
            pub fn is_nottriggered(&self) -> bool {
                *self == Self::NotTriggered
            }

            pub fn set_nottriggered(&mut self) -> &mut Self {
                *self = Self::NotTriggered;
                self
            }

            pub fn is_triggered(&self) -> bool {
                *self == Self::Triggered
            }

            pub fn set_triggered(&mut self) -> &mut Self {
                *self = Self::Triggered;
                self
            }
        }
    }

    pub mod hfclkstat {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HFCLKSTAT {
            raw: RawRegister<u32>,
        }

        impl HFCLKSTAT {}

        impl RegisterRead for HFCLKSTAT {
            type Value = HFCLKSTAT_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                HFCLKSTAT_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct HFCLKSTAT_READ_VALUE {
            raw: u32,
        }

        impl HFCLKSTAT_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn src(&self) -> SRC_FIELD {
                let raw = self.raw;
                SRC_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_src(&mut self, value: SRC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_src_with<F: Fn(&mut SRC_FIELD) -> &mut SRC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.src();
                f(&mut value);
                self.set_src(value)
            }

            pub fn state(&self) -> STATE_FIELD {
                let raw = self.raw;
                STATE_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_state(&mut self, value: STATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_state_with<F: Fn(&mut STATE_FIELD) -> &mut STATE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.state();
                f(&mut value);
                self.set_state(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SRC_FIELD u32 =>
                        // 64 MHz internal oscillator (HFINT)
                        RC = 0,
        // 64 MHz crystal oscillator (HFXO)
                        Xtal = 1

                    );

        impl SRC_FIELD {
            pub fn is_rc(&self) -> bool {
                *self == Self::RC
            }

            pub fn set_rc(&mut self) -> &mut Self {
                *self = Self::RC;
                self
            }

            pub fn is_xtal(&self) -> bool {
                *self == Self::Xtal
            }

            pub fn set_xtal(&mut self) -> &mut Self {
                *self = Self::Xtal;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATE_FIELD u32 =>
                        // HFCLK not running
                        NotRunning = 0,
        // HFCLK running
                        Running = 1

                    );

        impl STATE_FIELD {
            pub fn is_notrunning(&self) -> bool {
                *self == Self::NotRunning
            }

            pub fn set_notrunning(&mut self) -> &mut Self {
                *self = Self::NotRunning;
                self
            }

            pub fn is_running(&self) -> bool {
                *self == Self::Running
            }

            pub fn set_running(&mut self) -> &mut Self {
                *self = Self::Running;
                self
            }
        }
    }

    pub mod lfclkrun {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LFCLKRUN {
            raw: RawRegister<u32>,
        }

        impl LFCLKRUN {}

        impl RegisterRead for LFCLKRUN {
            type Value = LFCLKRUN_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LFCLKRUN_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LFCLKRUN_READ_VALUE {
            raw: u32,
        }

        impl LFCLKRUN_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn status(&self) -> STATUS_FIELD {
                let raw = self.raw;
                STATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_status(&mut self, value: STATUS_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_status_with<F: Fn(&mut STATUS_FIELD) -> &mut STATUS_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.status();
                f(&mut value);
                self.set_status(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATUS_FIELD u32 =>
                        // Task not triggered
                        NotTriggered = 0,
        // Task triggered
                        Triggered = 1

                    );

        impl STATUS_FIELD {
            pub fn is_nottriggered(&self) -> bool {
                *self == Self::NotTriggered
            }

            pub fn set_nottriggered(&mut self) -> &mut Self {
                *self = Self::NotTriggered;
                self
            }

            pub fn is_triggered(&self) -> bool {
                *self == Self::Triggered
            }

            pub fn set_triggered(&mut self) -> &mut Self {
                *self = Self::Triggered;
                self
            }
        }
    }

    pub mod lfclkstat {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LFCLKSTAT {
            raw: RawRegister<u32>,
        }

        impl LFCLKSTAT {}

        impl RegisterRead for LFCLKSTAT {
            type Value = LFCLKSTAT_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LFCLKSTAT_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LFCLKSTAT_READ_VALUE {
            raw: u32,
        }

        impl LFCLKSTAT_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn src(&self) -> SRC_FIELD {
                let raw = self.raw;
                SRC_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_src(&mut self, value: SRC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_src_with<F: Fn(&mut SRC_FIELD) -> &mut SRC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.src();
                f(&mut value);
                self.set_src(value)
            }

            pub fn state(&self) -> STATE_FIELD {
                let raw = self.raw;
                STATE_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_state(&mut self, value: STATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_state_with<F: Fn(&mut STATE_FIELD) -> &mut STATE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.state();
                f(&mut value);
                self.set_state(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SRC_FIELD u32 =>
                        // 32.768 kHz RC oscillator (LFRC)
                        RC = 0,
        // 32.768 kHz crystal oscillator (LFXO)
                        Xtal = 1,
        // 32.768 kHz synthesized from HFCLK (LFSYNT)
                        Synth = 2

                    );

        impl SRC_FIELD {
            pub fn is_rc(&self) -> bool {
                *self == Self::RC
            }

            pub fn set_rc(&mut self) -> &mut Self {
                *self = Self::RC;
                self
            }

            pub fn is_xtal(&self) -> bool {
                *self == Self::Xtal
            }

            pub fn set_xtal(&mut self) -> &mut Self {
                *self = Self::Xtal;
                self
            }

            pub fn is_synth(&self) -> bool {
                *self == Self::Synth
            }

            pub fn set_synth(&mut self) -> &mut Self {
                *self = Self::Synth;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATE_FIELD u32 =>
                        // LFCLK not running
                        NotRunning = 0,
        // LFCLK running
                        Running = 1

                    );

        impl STATE_FIELD {
            pub fn is_notrunning(&self) -> bool {
                *self == Self::NotRunning
            }

            pub fn set_notrunning(&mut self) -> &mut Self {
                *self = Self::NotRunning;
                self
            }

            pub fn is_running(&self) -> bool {
                *self == Self::Running
            }

            pub fn set_running(&mut self) -> &mut Self {
                *self = Self::Running;
                self
            }
        }
    }

    pub mod lfclksrccopy {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LFCLKSRCCOPY {
            raw: RawRegister<u32>,
        }

        impl LFCLKSRCCOPY {}

        impl RegisterRead for LFCLKSRCCOPY {
            type Value = LFCLKSRCCOPY_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LFCLKSRCCOPY_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LFCLKSRCCOPY_READ_VALUE {
            raw: u32,
        }

        impl LFCLKSRCCOPY_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn src(&self) -> SRC_FIELD {
                let raw = self.raw;
                SRC_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_src(&mut self, value: SRC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_src_with<F: Fn(&mut SRC_FIELD) -> &mut SRC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.src();
                f(&mut value);
                self.set_src(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SRC_FIELD u32 =>
                        // 32.768 kHz RC oscillator (LFRC)
                        RC = 0,
        // 32.768 kHz crystal oscillator (LFXO)
                        Xtal = 1,
        // 32.768 kHz synthesized from HFCLK (LFSYNT)
                        Synth = 2

                    );

        impl SRC_FIELD {
            pub fn is_rc(&self) -> bool {
                *self == Self::RC
            }

            pub fn set_rc(&mut self) -> &mut Self {
                *self = Self::RC;
                self
            }

            pub fn is_xtal(&self) -> bool {
                *self == Self::Xtal
            }

            pub fn set_xtal(&mut self) -> &mut Self {
                *self = Self::Xtal;
                self
            }

            pub fn is_synth(&self) -> bool {
                *self == Self::Synth
            }

            pub fn set_synth(&mut self) -> &mut Self {
                *self = Self::Synth;
                self
            }
        }
    }

    pub mod lfclksrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LFCLKSRC {
            raw: RawRegister<u32>,
        }

        impl LFCLKSRC {
            pub fn write_with<F: Fn(&mut LFCLKSRC_VALUE) -> &mut LFCLKSRC_VALUE>(&mut self, f: F) {
                let mut v = LFCLKSRC_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for LFCLKSRC {
            type Value = LFCLKSRC_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LFCLKSRC_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for LFCLKSRC {
            type Value = LFCLKSRC_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LFCLKSRC_VALUE {
            raw: u32,
        }

        impl LFCLKSRC_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn src(&self) -> SRC_FIELD {
                let raw = self.raw;
                SRC_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_src(&mut self, value: SRC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_src_with<F: Fn(&mut SRC_FIELD) -> &mut SRC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.src();
                f(&mut value);
                self.set_src(value)
            }

            pub fn bypass(&self) -> BYPASS_FIELD {
                let raw = self.raw;
                BYPASS_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_bypass(&mut self, value: BYPASS_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_bypass_with<F: Fn(&mut BYPASS_FIELD) -> &mut BYPASS_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bypass();
                f(&mut value);
                self.set_bypass(value)
            }

            pub fn external(&self) -> EXTERNAL_FIELD {
                let raw = self.raw;
                EXTERNAL_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_external(&mut self, value: EXTERNAL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_external_with<F: Fn(&mut EXTERNAL_FIELD) -> &mut EXTERNAL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.external();
                f(&mut value);
                self.set_external(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SRC_FIELD u32 =>
                        // 32.768 kHz RC oscillator (LFRC)
                        RC = 0,
        // 32.768 kHz crystal oscillator (LFXO)
                        Xtal = 1,
        // 32.768 kHz synthesized from HFCLK (LFSYNT)
                        Synth = 2

                    );

        impl SRC_FIELD {
            pub fn is_rc(&self) -> bool {
                *self == Self::RC
            }

            pub fn set_rc(&mut self) -> &mut Self {
                *self = Self::RC;
                self
            }

            pub fn is_xtal(&self) -> bool {
                *self == Self::Xtal
            }

            pub fn set_xtal(&mut self) -> &mut Self {
                *self = Self::Xtal;
                self
            }

            pub fn is_synth(&self) -> bool {
                *self == Self::Synth
            }

            pub fn set_synth(&mut self) -> &mut Self {
                *self = Self::Synth;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BYPASS_FIELD u32 =>
                        // Disable (use with Xtal or low-swing external source)
                        Disabled = 0,
        // Enable (use with rail-to-rail external source)
                        Enabled = 1

                    );

        impl BYPASS_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EXTERNAL_FIELD u32 =>
                        // Disable external source (use with Xtal)
                        Disabled = 0,
        // Enable use of external source instead of Xtal (SRC needs to be set to Xtal)
                        Enabled = 1

                    );

        impl EXTERNAL_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod hfxodebounce {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HFXODEBOUNCE {
            raw: RawRegister<u32>,
        }

        impl HFXODEBOUNCE {
            pub fn write_db256us(&mut self) {
                self.write(HFXODEBOUNCE_FIELD::Db256us)
            }

            pub fn write_db1024us(&mut self) {
                self.write(HFXODEBOUNCE_FIELD::Db1024us)
            }
        }

        impl RegisterRead for HFXODEBOUNCE {
            type Value = HFXODEBOUNCE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                HFXODEBOUNCE_FIELD::from_value((raw & 0x000000ff) >> 0)
            }
        }

        impl RegisterWrite for HFXODEBOUNCE {
            type Value = HFXODEBOUNCE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HFXODEBOUNCE_FIELD u32 =>
                        // 256 us debounce time. Recommended for 1.6 mm x 2.0 mm crystals and larger.
                        Db256us = 16,
        // 1024 us debounce time. Recommended for 1.6 mm x 1.2 mm crystals and smaller.
                        Db1024us = 64

                    );

        impl HFXODEBOUNCE_FIELD {
            pub fn is_db256us(&self) -> bool {
                *self == Self::Db256us
            }

            pub fn set_db256us(&mut self) -> &mut Self {
                *self = Self::Db256us;
                self
            }

            pub fn is_db1024us(&self) -> bool {
                *self == Self::Db1024us
            }

            pub fn set_db1024us(&mut self) -> &mut Self {
                *self = Self::Db1024us;
                self
            }
        }
    }

    pub mod lfxodebounce {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LFXODEBOUNCE {
            raw: RawRegister<u32>,
        }

        impl LFXODEBOUNCE {
            pub fn write_normal(&mut self) {
                self.write(LFXODEBOUNCE_FIELD::Normal)
            }

            pub fn write_extended(&mut self) {
                self.write(LFXODEBOUNCE_FIELD::Extended)
            }
        }

        impl RegisterRead for LFXODEBOUNCE {
            type Value = LFXODEBOUNCE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                LFXODEBOUNCE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for LFXODEBOUNCE {
            type Value = LFXODEBOUNCE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LFXODEBOUNCE_FIELD u32 =>
                        // 8192 32.768 kHz periods, or 0.25 s. Recommended for normal Operating Temperature conditions.
                        Normal = 0,
        // 16384 32.768 kHz periods, or 0.5 s. Recommended for Extended Operating Temperature conditions.
                        Extended = 1

                    );

        impl LFXODEBOUNCE_FIELD {
            pub fn is_normal(&self) -> bool {
                *self == Self::Normal
            }

            pub fn set_normal(&mut self) -> &mut Self {
                *self = Self::Normal;
                self
            }

            pub fn is_extended(&self) -> bool {
                *self == Self::Extended
            }

            pub fn set_extended(&mut self) -> &mut Self {
                *self = Self::Extended;
                self
            }
        }
    }

    pub mod ctiv {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CTIV {
            raw: RawRegister<u32>,
        }

        impl CTIV {}

        impl RegisterRead for CTIV {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }

        impl RegisterWrite for CTIV {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000007f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod traceconfig {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TRACECONFIG {
            raw: RawRegister<u32>,
        }

        impl TRACECONFIG {
            pub fn write_with<F: Fn(&mut TRACECONFIG_VALUE) -> &mut TRACECONFIG_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = TRACECONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for TRACECONFIG {
            type Value = TRACECONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                TRACECONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for TRACECONFIG {
            type Value = TRACECONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct TRACECONFIG_VALUE {
            raw: u32,
        }

        impl TRACECONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn traceportspeed(&self) -> TRACEPORTSPEED_FIELD {
                let raw = self.raw;
                TRACEPORTSPEED_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_traceportspeed(&mut self, value: TRACEPORTSPEED_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_traceportspeed_with<
                F: Fn(&mut TRACEPORTSPEED_FIELD) -> &mut TRACEPORTSPEED_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.traceportspeed();
                f(&mut value);
                self.set_traceportspeed(value)
            }

            pub fn tracemux(&self) -> TRACEMUX_FIELD {
                let raw = self.raw;
                TRACEMUX_FIELD::from_value((raw & 0x00030000) >> 16)
            }

            pub fn set_tracemux(&mut self, value: TRACEMUX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00030000) | (value << 16);
                self
            }

            pub fn set_tracemux_with<F: Fn(&mut TRACEMUX_FIELD) -> &mut TRACEMUX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tracemux();
                f(&mut value);
                self.set_tracemux(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TRACEPORTSPEED_FIELD u32 =>
                        // 32 MHz trace port clock (TRACECLK = 16 MHz)
                        _32MHz = 0,
        // 16 MHz trace port clock (TRACECLK = 8 MHz)
                        _16MHz = 1,
        // 8 MHz trace port clock (TRACECLK = 4 MHz)
                        _8MHz = 2,
        // 4 MHz trace port clock (TRACECLK = 2 MHz)
                        _4MHz = 3

                    );

        impl TRACEPORTSPEED_FIELD {
            pub fn is_32mhz(&self) -> bool {
                *self == Self::_32MHz
            }

            pub fn set_32mhz(&mut self) -> &mut Self {
                *self = Self::_32MHz;
                self
            }

            pub fn is_16mhz(&self) -> bool {
                *self == Self::_16MHz
            }

            pub fn set_16mhz(&mut self) -> &mut Self {
                *self = Self::_16MHz;
                self
            }

            pub fn is_8mhz(&self) -> bool {
                *self == Self::_8MHz
            }

            pub fn set_8mhz(&mut self) -> &mut Self {
                *self = Self::_8MHz;
                self
            }

            pub fn is_4mhz(&self) -> bool {
                *self == Self::_4MHz
            }

            pub fn set_4mhz(&mut self) -> &mut Self {
                *self = Self::_4MHz;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TRACEMUX_FIELD u32 =>
                        // No trace signals routed to pins. All pins can be used as regular GPIOs.
                        GPIO = 0,
        // SWO trace signal routed to pin. Remaining pins can be used as regular GPIOs.
                        Serial = 1,
        // All trace signals (TRACECLK and TRACEDATA[n]) routed to pins.
                        Parallel = 2

                    );

        impl TRACEMUX_FIELD {
            pub fn is_gpio(&self) -> bool {
                *self == Self::GPIO
            }

            pub fn set_gpio(&mut self) -> &mut Self {
                *self = Self::GPIO;
                self
            }

            pub fn is_serial(&self) -> bool {
                *self == Self::Serial
            }

            pub fn set_serial(&mut self) -> &mut Self {
                *self = Self::Serial;
                self
            }

            pub fn is_parallel(&self) -> bool {
                *self == Self::Parallel
            }

            pub fn set_parallel(&mut self) -> &mut Self {
                *self = Self::Parallel;
                self
            }
        }
    }
}

pub mod power {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct POWER {
        _hidden: (),
    }

    impl POWER {
        const BASE_ADDRESS: u32 = 0x40000000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for POWER {
        type Target = POWER_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for POWER {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct POWER_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 120],
        /// Enable Constant Latency mode
        pub tasks_constlat: TaskRegister,
        /// Enable Low-power mode (variable latency)
        pub tasks_lowpwr: TaskRegister,
        _padding_128: [u8; 136],
        /// Power failure warning
        pub events_pofwarn: EventRegister,
        _padding_268: [u8; 8],
        /// CPU entered WFI/WFE sleep
        pub events_sleepenter: EventRegister,
        /// CPU exited WFI/WFE sleep
        pub events_sleepexit: EventRegister,
        /// Voltage supply detected on VBUS
        pub events_usbdetected: EventRegister,
        /// Voltage supply removed from VBUS
        pub events_usbremoved: EventRegister,
        /// USB 3.3 V supply ready
        pub events_usbpwrrdy: EventRegister,
        _padding_296: [u8; 476],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Reset reason
        pub resetreas: resetreas::RESETREAS,
        _padding_1028: [u8; 36],
        /// Deprecated register - RAM status register
        pub ramstatus: ramstatus::RAMSTATUS,
        _padding_1068: [u8; 12],
        /// USB supply status
        pub usbregstatus: usbregstatus::USBREGSTATUS,
        _padding_1084: [u8; 196],
        /// System OFF register
        pub systemoff: systemoff::SYSTEMOFF,
        _padding_1284: [u8; 12],
        /// Power-fail comparator configuration
        pub pofcon: pofcon::POFCON,
        _padding_1300: [u8; 8],
        /// General purpose retention register
        pub gpregret: gpregret::GPREGRET,
        /// General purpose retention register
        pub gpregret2: gpregret2::GPREGRET2,
        _padding_1316: [u8; 84],
        /// Enable DC/DC converter for REG1 stage
        pub dcdcen: dcdcen::DCDCEN,
        _padding_1404: [u8; 196],
        /// Main supply status
        pub mainregstatus: mainregstatus::MAINREGSTATUS,
        _padding_1604: [u8; 700],
        /// Unspecified
        pub ram: [ram::RAM; 9],
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pofwarn(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pofwarn(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pofwarn_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pofwarn();
                f(&mut value);
                self.set_pofwarn(value)
            }

            pub fn sleepenter(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_sleepenter(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_sleepenter_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sleepenter();
                f(&mut value);
                self.set_sleepenter(value)
            }

            pub fn sleepexit(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_sleepexit(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_sleepexit_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sleepexit();
                f(&mut value);
                self.set_sleepexit(value)
            }

            pub fn usbdetected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_usbdetected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_usbdetected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbdetected();
                f(&mut value);
                self.set_usbdetected(value)
            }

            pub fn usbremoved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_usbremoved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_usbremoved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbremoved();
                f(&mut value);
                self.set_usbremoved(value)
            }

            pub fn usbpwrrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_usbpwrrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_usbpwrrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbpwrrdy();
                f(&mut value);
                self.set_usbpwrrdy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pofwarn(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_sleepenter(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_sleepexit(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_usbdetected(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_usbremoved(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_usbpwrrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pofwarn(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pofwarn(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pofwarn_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pofwarn();
                f(&mut value);
                self.set_pofwarn(value)
            }

            pub fn sleepenter(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_sleepenter(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_sleepenter_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sleepenter();
                f(&mut value);
                self.set_sleepenter(value)
            }

            pub fn sleepexit(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_sleepexit(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_sleepexit_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sleepexit();
                f(&mut value);
                self.set_sleepexit(value)
            }

            pub fn usbdetected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_usbdetected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_usbdetected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbdetected();
                f(&mut value);
                self.set_usbdetected(value)
            }

            pub fn usbremoved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_usbremoved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_usbremoved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbremoved();
                f(&mut value);
                self.set_usbremoved(value)
            }

            pub fn usbpwrrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_usbpwrrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_usbpwrrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbpwrrdy();
                f(&mut value);
                self.set_usbpwrrdy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pofwarn(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_sleepenter(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_sleepexit(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_usbdetected(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_usbremoved(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_usbpwrrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }
        }
    }

    pub mod resetreas {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RESETREAS {
            raw: RawRegister<u32>,
        }

        impl RESETREAS {
            pub fn write_with<F: Fn(&mut RESETREAS_VALUE) -> &mut RESETREAS_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = RESETREAS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for RESETREAS {
            type Value = RESETREAS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                RESETREAS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for RESETREAS {
            type Value = RESETREAS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct RESETREAS_VALUE {
            raw: u32,
        }

        impl RESETREAS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn resetpin(&self) -> RESETPIN_FIELD {
                let raw = self.raw;
                RESETPIN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_resetpin(&mut self, value: RESETPIN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_resetpin_with<F: Fn(&mut RESETPIN_FIELD) -> &mut RESETPIN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resetpin();
                f(&mut value);
                self.set_resetpin(value)
            }

            pub fn dog(&self) -> DOG_FIELD {
                let raw = self.raw;
                DOG_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_dog(&mut self, value: DOG_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_dog_with<F: Fn(&mut DOG_FIELD) -> &mut DOG_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dog();
                f(&mut value);
                self.set_dog(value)
            }

            pub fn sreq(&self) -> SREQ_FIELD {
                let raw = self.raw;
                SREQ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_sreq(&mut self, value: SREQ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_sreq_with<F: Fn(&mut SREQ_FIELD) -> &mut SREQ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sreq();
                f(&mut value);
                self.set_sreq(value)
            }

            pub fn lockup(&self) -> LOCKUP_FIELD {
                let raw = self.raw;
                LOCKUP_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_lockup(&mut self, value: LOCKUP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_lockup_with<F: Fn(&mut LOCKUP_FIELD) -> &mut LOCKUP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lockup();
                f(&mut value);
                self.set_lockup(value)
            }

            pub fn off(&self) -> OFF_FIELD {
                let raw = self.raw;
                OFF_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_off(&mut self, value: OFF_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_off_with<F: Fn(&mut OFF_FIELD) -> &mut OFF_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.off();
                f(&mut value);
                self.set_off(value)
            }

            pub fn lpcomp(&self) -> LPCOMP_FIELD {
                let raw = self.raw;
                LPCOMP_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_lpcomp(&mut self, value: LPCOMP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_lpcomp_with<F: Fn(&mut LPCOMP_FIELD) -> &mut LPCOMP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lpcomp();
                f(&mut value);
                self.set_lpcomp(value)
            }

            pub fn dif(&self) -> DIF_FIELD {
                let raw = self.raw;
                DIF_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_dif(&mut self, value: DIF_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_dif_with<F: Fn(&mut DIF_FIELD) -> &mut DIF_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dif();
                f(&mut value);
                self.set_dif(value)
            }

            pub fn nfc(&self) -> NFC_FIELD {
                let raw = self.raw;
                NFC_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_nfc(&mut self, value: NFC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_nfc_with<F: Fn(&mut NFC_FIELD) -> &mut NFC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.nfc();
                f(&mut value);
                self.set_nfc(value)
            }

            pub fn vbus(&self) -> VBUS_FIELD {
                let raw = self.raw;
                VBUS_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_vbus(&mut self, value: VBUS_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_vbus_with<F: Fn(&mut VBUS_FIELD) -> &mut VBUS_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.vbus();
                f(&mut value);
                self.set_vbus(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RESETPIN_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl RESETPIN_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DOG_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl DOG_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SREQ_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl SREQ_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOCKUP_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl LOCKUP_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OFF_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl OFF_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LPCOMP_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl LPCOMP_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DIF_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl DIF_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] NFC_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl NFC_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VBUS_FIELD u32 =>
                        // Not detected
                        NotDetected = 0,
        // Detected
                        Detected = 1

                    );

        impl VBUS_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }
    }

    pub mod ramstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RAMSTATUS {
            raw: RawRegister<u32>,
        }

        impl RAMSTATUS {}

        impl RegisterRead for RAMSTATUS {
            type Value = RAMSTATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                RAMSTATUS_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct RAMSTATUS_READ_VALUE {
            raw: u32,
        }

        impl RAMSTATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ramblock0(&self) -> RAMBLOCK0_FIELD {
                let raw = self.raw;
                RAMBLOCK0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ramblock0(&mut self, value: RAMBLOCK0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ramblock0_with<F: Fn(&mut RAMBLOCK0_FIELD) -> &mut RAMBLOCK0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ramblock0();
                f(&mut value);
                self.set_ramblock0(value)
            }

            pub fn ramblock1(&self) -> RAMBLOCK1_FIELD {
                let raw = self.raw;
                RAMBLOCK1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ramblock1(&mut self, value: RAMBLOCK1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ramblock1_with<F: Fn(&mut RAMBLOCK1_FIELD) -> &mut RAMBLOCK1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ramblock1();
                f(&mut value);
                self.set_ramblock1(value)
            }

            pub fn ramblock2(&self) -> RAMBLOCK2_FIELD {
                let raw = self.raw;
                RAMBLOCK2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ramblock2(&mut self, value: RAMBLOCK2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ramblock2_with<F: Fn(&mut RAMBLOCK2_FIELD) -> &mut RAMBLOCK2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ramblock2();
                f(&mut value);
                self.set_ramblock2(value)
            }

            pub fn ramblock3(&self) -> RAMBLOCK3_FIELD {
                let raw = self.raw;
                RAMBLOCK3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ramblock3(&mut self, value: RAMBLOCK3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ramblock3_with<F: Fn(&mut RAMBLOCK3_FIELD) -> &mut RAMBLOCK3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ramblock3();
                f(&mut value);
                self.set_ramblock3(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RAMBLOCK0_FIELD u32 =>
                        // Off
                        Off = 0,
        // On
                        On = 1

                    );

        impl RAMBLOCK0_FIELD {
            pub fn is_off(&self) -> bool {
                *self == Self::Off
            }

            pub fn set_off(&mut self) -> &mut Self {
                *self = Self::Off;
                self
            }

            pub fn is_on(&self) -> bool {
                *self == Self::On
            }

            pub fn set_on(&mut self) -> &mut Self {
                *self = Self::On;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RAMBLOCK1_FIELD u32 =>
                        // Off
                        Off = 0,
        // On
                        On = 1

                    );

        impl RAMBLOCK1_FIELD {
            pub fn is_off(&self) -> bool {
                *self == Self::Off
            }

            pub fn set_off(&mut self) -> &mut Self {
                *self = Self::Off;
                self
            }

            pub fn is_on(&self) -> bool {
                *self == Self::On
            }

            pub fn set_on(&mut self) -> &mut Self {
                *self = Self::On;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RAMBLOCK2_FIELD u32 =>
                        // Off
                        Off = 0,
        // On
                        On = 1

                    );

        impl RAMBLOCK2_FIELD {
            pub fn is_off(&self) -> bool {
                *self == Self::Off
            }

            pub fn set_off(&mut self) -> &mut Self {
                *self = Self::Off;
                self
            }

            pub fn is_on(&self) -> bool {
                *self == Self::On
            }

            pub fn set_on(&mut self) -> &mut Self {
                *self = Self::On;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RAMBLOCK3_FIELD u32 =>
                        // Off
                        Off = 0,
        // On
                        On = 1

                    );

        impl RAMBLOCK3_FIELD {
            pub fn is_off(&self) -> bool {
                *self == Self::Off
            }

            pub fn set_off(&mut self) -> &mut Self {
                *self = Self::Off;
                self
            }

            pub fn is_on(&self) -> bool {
                *self == Self::On
            }

            pub fn set_on(&mut self) -> &mut Self {
                *self = Self::On;
                self
            }
        }
    }

    pub mod usbregstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct USBREGSTATUS {
            raw: RawRegister<u32>,
        }

        impl USBREGSTATUS {}

        impl RegisterRead for USBREGSTATUS {
            type Value = USBREGSTATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                USBREGSTATUS_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct USBREGSTATUS_READ_VALUE {
            raw: u32,
        }

        impl USBREGSTATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn vbusdetect(&self) -> VBUSDETECT_FIELD {
                let raw = self.raw;
                VBUSDETECT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_vbusdetect(&mut self, value: VBUSDETECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_vbusdetect_with<F: Fn(&mut VBUSDETECT_FIELD) -> &mut VBUSDETECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.vbusdetect();
                f(&mut value);
                self.set_vbusdetect(value)
            }

            pub fn outputrdy(&self) -> OUTPUTRDY_FIELD {
                let raw = self.raw;
                OUTPUTRDY_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_outputrdy(&mut self, value: OUTPUTRDY_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_outputrdy_with<F: Fn(&mut OUTPUTRDY_FIELD) -> &mut OUTPUTRDY_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.outputrdy();
                f(&mut value);
                self.set_outputrdy(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VBUSDETECT_FIELD u32 =>
                        // VBUS voltage below valid threshold
                        NoVbus = 0,
        // VBUS voltage above valid threshold
                        VbusPresent = 1

                    );

        impl VBUSDETECT_FIELD {
            pub fn is_novbus(&self) -> bool {
                *self == Self::NoVbus
            }

            pub fn set_novbus(&mut self) -> &mut Self {
                *self = Self::NoVbus;
                self
            }

            pub fn is_vbuspresent(&self) -> bool {
                *self == Self::VbusPresent
            }

            pub fn set_vbuspresent(&mut self) -> &mut Self {
                *self = Self::VbusPresent;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUTPUTRDY_FIELD u32 =>
                        // USBREG output settling time not elapsed
                        NotReady = 0,
        // USBREG output settling time elapsed (same information as USBPWRRDY event)
                        Ready = 1

                    );

        impl OUTPUTRDY_FIELD {
            pub fn is_notready(&self) -> bool {
                *self == Self::NotReady
            }

            pub fn set_notready(&mut self) -> &mut Self {
                *self = Self::NotReady;
                self
            }

            pub fn is_ready(&self) -> bool {
                *self == Self::Ready
            }

            pub fn set_ready(&mut self) -> &mut Self {
                *self = Self::Ready;
                self
            }
        }
    }

    pub mod systemoff {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SYSTEMOFF {
            raw: RawRegister<u32>,
        }

        impl SYSTEMOFF {
            pub fn write_enter(&mut self) {
                self.write(SYSTEMOFF_FIELD::Enter)
            }
        }

        impl RegisterWrite for SYSTEMOFF {
            type Value = SYSTEMOFF_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SYSTEMOFF_FIELD u32 =>
            // Enable System OFF mode
            Enter = 1

        );

        impl SYSTEMOFF_FIELD {
            pub fn is_enter(&self) -> bool {
                *self == Self::Enter
            }

            pub fn set_enter(&mut self) -> &mut Self {
                *self = Self::Enter;
                self
            }
        }
    }

    pub mod pofcon {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct POFCON {
            raw: RawRegister<u32>,
        }

        impl POFCON {
            pub fn write_with<F: Fn(&mut POFCON_VALUE) -> &mut POFCON_VALUE>(&mut self, f: F) {
                let mut v = POFCON_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for POFCON {
            type Value = POFCON_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                POFCON_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for POFCON {
            type Value = POFCON_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct POFCON_VALUE {
            raw: u32,
        }

        impl POFCON_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pof(&self) -> POF_FIELD {
                let raw = self.raw;
                POF_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pof(&mut self, value: POF_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pof_with<F: Fn(&mut POF_FIELD) -> &mut POF_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pof();
                f(&mut value);
                self.set_pof(value)
            }

            pub fn threshold(&self) -> THRESHOLD_FIELD {
                let raw = self.raw;
                THRESHOLD_FIELD::from_value((raw & 0x0000001e) >> 1)
            }

            pub fn set_threshold(&mut self, value: THRESHOLD_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001e) | (value << 1);
                self
            }

            pub fn set_threshold_with<F: Fn(&mut THRESHOLD_FIELD) -> &mut THRESHOLD_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.threshold();
                f(&mut value);
                self.set_threshold(value)
            }

            pub fn thresholdvddh(&self) -> THRESHOLDVDDH_FIELD {
                let raw = self.raw;
                THRESHOLDVDDH_FIELD::from_value((raw & 0x00000f00) >> 8)
            }

            pub fn set_thresholdvddh(&mut self, value: THRESHOLDVDDH_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000f00) | (value << 8);
                self
            }

            pub fn set_thresholdvddh_with<
                F: Fn(&mut THRESHOLDVDDH_FIELD) -> &mut THRESHOLDVDDH_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.thresholdvddh();
                f(&mut value);
                self.set_thresholdvddh(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] POF_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl POF_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] THRESHOLD_FIELD u32 =>
                        // Set threshold to 1.7 V
                        V17 = 4,
        // Set threshold to 1.8 V
                        V18 = 5,
        // Set threshold to 1.9 V
                        V19 = 6,
        // Set threshold to 2.0 V
                        V20 = 7,
        // Set threshold to 2.1 V
                        V21 = 8,
        // Set threshold to 2.2 V
                        V22 = 9,
        // Set threshold to 2.3 V
                        V23 = 10,
        // Set threshold to 2.4 V
                        V24 = 11,
        // Set threshold to 2.5 V
                        V25 = 12,
        // Set threshold to 2.6 V
                        V26 = 13,
        // Set threshold to 2.7 V
                        V27 = 14,
        // Set threshold to 2.8 V
                        V28 = 15

                    );

        impl THRESHOLD_FIELD {
            pub fn is_v17(&self) -> bool {
                *self == Self::V17
            }

            pub fn set_v17(&mut self) -> &mut Self {
                *self = Self::V17;
                self
            }

            pub fn is_v18(&self) -> bool {
                *self == Self::V18
            }

            pub fn set_v18(&mut self) -> &mut Self {
                *self = Self::V18;
                self
            }

            pub fn is_v19(&self) -> bool {
                *self == Self::V19
            }

            pub fn set_v19(&mut self) -> &mut Self {
                *self = Self::V19;
                self
            }

            pub fn is_v20(&self) -> bool {
                *self == Self::V20
            }

            pub fn set_v20(&mut self) -> &mut Self {
                *self = Self::V20;
                self
            }

            pub fn is_v21(&self) -> bool {
                *self == Self::V21
            }

            pub fn set_v21(&mut self) -> &mut Self {
                *self = Self::V21;
                self
            }

            pub fn is_v22(&self) -> bool {
                *self == Self::V22
            }

            pub fn set_v22(&mut self) -> &mut Self {
                *self = Self::V22;
                self
            }

            pub fn is_v23(&self) -> bool {
                *self == Self::V23
            }

            pub fn set_v23(&mut self) -> &mut Self {
                *self = Self::V23;
                self
            }

            pub fn is_v24(&self) -> bool {
                *self == Self::V24
            }

            pub fn set_v24(&mut self) -> &mut Self {
                *self = Self::V24;
                self
            }

            pub fn is_v25(&self) -> bool {
                *self == Self::V25
            }

            pub fn set_v25(&mut self) -> &mut Self {
                *self = Self::V25;
                self
            }

            pub fn is_v26(&self) -> bool {
                *self == Self::V26
            }

            pub fn set_v26(&mut self) -> &mut Self {
                *self = Self::V26;
                self
            }

            pub fn is_v27(&self) -> bool {
                *self == Self::V27
            }

            pub fn set_v27(&mut self) -> &mut Self {
                *self = Self::V27;
                self
            }

            pub fn is_v28(&self) -> bool {
                *self == Self::V28
            }

            pub fn set_v28(&mut self) -> &mut Self {
                *self = Self::V28;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] THRESHOLDVDDH_FIELD u32 =>
                        // Set threshold to 2.7 V
                        V27 = 0,
        // Set threshold to 2.8 V
                        V28 = 1,
        // Set threshold to 2.9 V
                        V29 = 2,
        // Set threshold to 3.0 V
                        V30 = 3,
        // Set threshold to 3.1 V
                        V31 = 4,
        // Set threshold to 3.2 V
                        V32 = 5,
        // Set threshold to 3.3 V
                        V33 = 6,
        // Set threshold to 3.4 V
                        V34 = 7,
        // Set threshold to 3.5 V
                        V35 = 8,
        // Set threshold to 3.6 V
                        V36 = 9,
        // Set threshold to 3.7 V
                        V37 = 10,
        // Set threshold to 3.8 V
                        V38 = 11,
        // Set threshold to 3.9 V
                        V39 = 12,
        // Set threshold to 4.0 V
                        V40 = 13,
        // Set threshold to 4.1 V
                        V41 = 14,
        // Set threshold to 4.2 V
                        V42 = 15

                    );

        impl THRESHOLDVDDH_FIELD {
            pub fn is_v27(&self) -> bool {
                *self == Self::V27
            }

            pub fn set_v27(&mut self) -> &mut Self {
                *self = Self::V27;
                self
            }

            pub fn is_v28(&self) -> bool {
                *self == Self::V28
            }

            pub fn set_v28(&mut self) -> &mut Self {
                *self = Self::V28;
                self
            }

            pub fn is_v29(&self) -> bool {
                *self == Self::V29
            }

            pub fn set_v29(&mut self) -> &mut Self {
                *self = Self::V29;
                self
            }

            pub fn is_v30(&self) -> bool {
                *self == Self::V30
            }

            pub fn set_v30(&mut self) -> &mut Self {
                *self = Self::V30;
                self
            }

            pub fn is_v31(&self) -> bool {
                *self == Self::V31
            }

            pub fn set_v31(&mut self) -> &mut Self {
                *self = Self::V31;
                self
            }

            pub fn is_v32(&self) -> bool {
                *self == Self::V32
            }

            pub fn set_v32(&mut self) -> &mut Self {
                *self = Self::V32;
                self
            }

            pub fn is_v33(&self) -> bool {
                *self == Self::V33
            }

            pub fn set_v33(&mut self) -> &mut Self {
                *self = Self::V33;
                self
            }

            pub fn is_v34(&self) -> bool {
                *self == Self::V34
            }

            pub fn set_v34(&mut self) -> &mut Self {
                *self = Self::V34;
                self
            }

            pub fn is_v35(&self) -> bool {
                *self == Self::V35
            }

            pub fn set_v35(&mut self) -> &mut Self {
                *self = Self::V35;
                self
            }

            pub fn is_v36(&self) -> bool {
                *self == Self::V36
            }

            pub fn set_v36(&mut self) -> &mut Self {
                *self = Self::V36;
                self
            }

            pub fn is_v37(&self) -> bool {
                *self == Self::V37
            }

            pub fn set_v37(&mut self) -> &mut Self {
                *self = Self::V37;
                self
            }

            pub fn is_v38(&self) -> bool {
                *self == Self::V38
            }

            pub fn set_v38(&mut self) -> &mut Self {
                *self = Self::V38;
                self
            }

            pub fn is_v39(&self) -> bool {
                *self == Self::V39
            }

            pub fn set_v39(&mut self) -> &mut Self {
                *self = Self::V39;
                self
            }

            pub fn is_v40(&self) -> bool {
                *self == Self::V40
            }

            pub fn set_v40(&mut self) -> &mut Self {
                *self = Self::V40;
                self
            }

            pub fn is_v41(&self) -> bool {
                *self == Self::V41
            }

            pub fn set_v41(&mut self) -> &mut Self {
                *self = Self::V41;
                self
            }

            pub fn is_v42(&self) -> bool {
                *self == Self::V42
            }

            pub fn set_v42(&mut self) -> &mut Self {
                *self = Self::V42;
                self
            }
        }
    }

    pub mod gpregret {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct GPREGRET {
            raw: RawRegister<u32>,
        }

        impl GPREGRET {}

        impl RegisterRead for GPREGRET {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for GPREGRET {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod gpregret2 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct GPREGRET2 {
            raw: RawRegister<u32>,
        }

        impl GPREGRET2 {
            pub fn write_with<F: Fn(&mut GPREGRET2_VALUE) -> &mut GPREGRET2_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = GPREGRET2_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for GPREGRET2 {
            type Value = GPREGRET2_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                GPREGRET2_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for GPREGRET2 {
            type Value = GPREGRET2_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct GPREGRET2_VALUE {
            raw: u32,
        }

        impl GPREGRET2_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn gpregret(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_gpregret(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }
        }
    }

    pub mod dcdcen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DCDCEN {
            raw: RawRegister<u32>,
        }

        impl DCDCEN {
            pub fn write_disabled(&mut self) {
                self.write(DCDCEN_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(DCDCEN_FIELD::Enabled)
            }
        }

        impl RegisterRead for DCDCEN {
            type Value = DCDCEN_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                DCDCEN_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for DCDCEN {
            type Value = DCDCEN_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DCDCEN_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl DCDCEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod mainregstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MAINREGSTATUS {
            raw: RawRegister<u32>,
        }

        impl MAINREGSTATUS {}

        impl RegisterRead for MAINREGSTATUS {
            type Value = MAINREGSTATUS_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                MAINREGSTATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MAINREGSTATUS_FIELD u32 =>
                        // Normal voltage mode. Voltage supplied on VDD.
                        Normal = 0,
        // High voltage mode. Voltage supplied on VDDH.
                        High = 1

                    );

        impl MAINREGSTATUS_FIELD {
            pub fn is_normal(&self) -> bool {
                *self == Self::Normal
            }

            pub fn set_normal(&mut self) -> &mut Self {
                *self = Self::Normal;
                self
            }

            pub fn is_high(&self) -> bool {
                *self == Self::High
            }

            pub fn set_high(&mut self) -> &mut Self {
                *self = Self::High;
                self
            }
        }
    }

    pub mod ram {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct RAM {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: RAMn power control register
            pub power: power::POWER,
            /// Description cluster: RAMn power control set register
            pub powerset: powerset::POWERSET,
            /// Description cluster: RAMn power control clear register
            pub powerclr: powerclr::POWERCLR,
            _padding_12: [u8; 4],
        }

        pub mod power {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct POWER {
                raw: RawRegister<u32>,
            }

            impl POWER {
                pub fn write_with<F: Fn(&mut POWER_VALUE) -> &mut POWER_VALUE>(&mut self, f: F) {
                    let mut v = POWER_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for POWER {
                type Value = POWER_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    POWER_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for POWER {
                type Value = POWER_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct POWER_VALUE {
                raw: u32,
            }

            impl POWER_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn s0power(&self) -> S0POWER_FIELD {
                    let raw = self.raw;
                    S0POWER_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_s0power(&mut self, value: S0POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_s0power_with<F: Fn(&mut S0POWER_FIELD) -> &mut S0POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s0power();
                    f(&mut value);
                    self.set_s0power(value)
                }

                pub fn s1power(&self) -> S1POWER_FIELD {
                    let raw = self.raw;
                    S1POWER_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_s1power(&mut self, value: S1POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_s1power_with<F: Fn(&mut S1POWER_FIELD) -> &mut S1POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s1power();
                    f(&mut value);
                    self.set_s1power(value)
                }

                pub fn s2power(&self) -> S2POWER_FIELD {
                    let raw = self.raw;
                    S2POWER_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_s2power(&mut self, value: S2POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_s2power_with<F: Fn(&mut S2POWER_FIELD) -> &mut S2POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s2power();
                    f(&mut value);
                    self.set_s2power(value)
                }

                pub fn s3power(&self) -> S3POWER_FIELD {
                    let raw = self.raw;
                    S3POWER_FIELD::from_value((raw & 0x00000008) >> 3)
                }

                pub fn set_s3power(&mut self, value: S3POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_s3power_with<F: Fn(&mut S3POWER_FIELD) -> &mut S3POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s3power();
                    f(&mut value);
                    self.set_s3power(value)
                }

                pub fn s4power(&self) -> S4POWER_FIELD {
                    let raw = self.raw;
                    S4POWER_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_s4power(&mut self, value: S4POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_s4power_with<F: Fn(&mut S4POWER_FIELD) -> &mut S4POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s4power();
                    f(&mut value);
                    self.set_s4power(value)
                }

                pub fn s5power(&self) -> S5POWER_FIELD {
                    let raw = self.raw;
                    S5POWER_FIELD::from_value((raw & 0x00000020) >> 5)
                }

                pub fn set_s5power(&mut self, value: S5POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_s5power_with<F: Fn(&mut S5POWER_FIELD) -> &mut S5POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s5power();
                    f(&mut value);
                    self.set_s5power(value)
                }

                pub fn s6power(&self) -> S6POWER_FIELD {
                    let raw = self.raw;
                    S6POWER_FIELD::from_value((raw & 0x00000040) >> 6)
                }

                pub fn set_s6power(&mut self, value: S6POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_s6power_with<F: Fn(&mut S6POWER_FIELD) -> &mut S6POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s6power();
                    f(&mut value);
                    self.set_s6power(value)
                }

                pub fn s7power(&self) -> S7POWER_FIELD {
                    let raw = self.raw;
                    S7POWER_FIELD::from_value((raw & 0x00000080) >> 7)
                }

                pub fn set_s7power(&mut self, value: S7POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_s7power_with<F: Fn(&mut S7POWER_FIELD) -> &mut S7POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s7power();
                    f(&mut value);
                    self.set_s7power(value)
                }

                pub fn s8power(&self) -> S8POWER_FIELD {
                    let raw = self.raw;
                    S8POWER_FIELD::from_value((raw & 0x00000100) >> 8)
                }

                pub fn set_s8power(&mut self, value: S8POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_s8power_with<F: Fn(&mut S8POWER_FIELD) -> &mut S8POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s8power();
                    f(&mut value);
                    self.set_s8power(value)
                }

                pub fn s9power(&self) -> S9POWER_FIELD {
                    let raw = self.raw;
                    S9POWER_FIELD::from_value((raw & 0x00000200) >> 9)
                }

                pub fn set_s9power(&mut self, value: S9POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_s9power_with<F: Fn(&mut S9POWER_FIELD) -> &mut S9POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s9power();
                    f(&mut value);
                    self.set_s9power(value)
                }

                pub fn s10power(&self) -> S10POWER_FIELD {
                    let raw = self.raw;
                    S10POWER_FIELD::from_value((raw & 0x00000400) >> 10)
                }

                pub fn set_s10power(&mut self, value: S10POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_s10power_with<F: Fn(&mut S10POWER_FIELD) -> &mut S10POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s10power();
                    f(&mut value);
                    self.set_s10power(value)
                }

                pub fn s11power(&self) -> S11POWER_FIELD {
                    let raw = self.raw;
                    S11POWER_FIELD::from_value((raw & 0x00000800) >> 11)
                }

                pub fn set_s11power(&mut self, value: S11POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_s11power_with<F: Fn(&mut S11POWER_FIELD) -> &mut S11POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s11power();
                    f(&mut value);
                    self.set_s11power(value)
                }

                pub fn s12power(&self) -> S12POWER_FIELD {
                    let raw = self.raw;
                    S12POWER_FIELD::from_value((raw & 0x00001000) >> 12)
                }

                pub fn set_s12power(&mut self, value: S12POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_s12power_with<F: Fn(&mut S12POWER_FIELD) -> &mut S12POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s12power();
                    f(&mut value);
                    self.set_s12power(value)
                }

                pub fn s13power(&self) -> S13POWER_FIELD {
                    let raw = self.raw;
                    S13POWER_FIELD::from_value((raw & 0x00002000) >> 13)
                }

                pub fn set_s13power(&mut self, value: S13POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_s13power_with<F: Fn(&mut S13POWER_FIELD) -> &mut S13POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s13power();
                    f(&mut value);
                    self.set_s13power(value)
                }

                pub fn s14power(&self) -> S14POWER_FIELD {
                    let raw = self.raw;
                    S14POWER_FIELD::from_value((raw & 0x00004000) >> 14)
                }

                pub fn set_s14power(&mut self, value: S14POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_s14power_with<F: Fn(&mut S14POWER_FIELD) -> &mut S14POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s14power();
                    f(&mut value);
                    self.set_s14power(value)
                }

                pub fn s15power(&self) -> S15POWER_FIELD {
                    let raw = self.raw;
                    S15POWER_FIELD::from_value((raw & 0x00008000) >> 15)
                }

                pub fn set_s15power(&mut self, value: S15POWER_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_s15power_with<F: Fn(&mut S15POWER_FIELD) -> &mut S15POWER_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s15power();
                    f(&mut value);
                    self.set_s15power(value)
                }

                pub fn s0retention(&self) -> S0RETENTION_FIELD {
                    let raw = self.raw;
                    S0RETENTION_FIELD::from_value((raw & 0x00010000) >> 16)
                }

                pub fn set_s0retention(&mut self, value: S0RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_s0retention_with<
                    F: Fn(&mut S0RETENTION_FIELD) -> &mut S0RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s0retention();
                    f(&mut value);
                    self.set_s0retention(value)
                }

                pub fn s1retention(&self) -> S1RETENTION_FIELD {
                    let raw = self.raw;
                    S1RETENTION_FIELD::from_value((raw & 0x00020000) >> 17)
                }

                pub fn set_s1retention(&mut self, value: S1RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_s1retention_with<
                    F: Fn(&mut S1RETENTION_FIELD) -> &mut S1RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s1retention();
                    f(&mut value);
                    self.set_s1retention(value)
                }

                pub fn s2retention(&self) -> S2RETENTION_FIELD {
                    let raw = self.raw;
                    S2RETENTION_FIELD::from_value((raw & 0x00040000) >> 18)
                }

                pub fn set_s2retention(&mut self, value: S2RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_s2retention_with<
                    F: Fn(&mut S2RETENTION_FIELD) -> &mut S2RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s2retention();
                    f(&mut value);
                    self.set_s2retention(value)
                }

                pub fn s3retention(&self) -> S3RETENTION_FIELD {
                    let raw = self.raw;
                    S3RETENTION_FIELD::from_value((raw & 0x00080000) >> 19)
                }

                pub fn set_s3retention(&mut self, value: S3RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_s3retention_with<
                    F: Fn(&mut S3RETENTION_FIELD) -> &mut S3RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s3retention();
                    f(&mut value);
                    self.set_s3retention(value)
                }

                pub fn s4retention(&self) -> S4RETENTION_FIELD {
                    let raw = self.raw;
                    S4RETENTION_FIELD::from_value((raw & 0x00100000) >> 20)
                }

                pub fn set_s4retention(&mut self, value: S4RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_s4retention_with<
                    F: Fn(&mut S4RETENTION_FIELD) -> &mut S4RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s4retention();
                    f(&mut value);
                    self.set_s4retention(value)
                }

                pub fn s5retention(&self) -> S5RETENTION_FIELD {
                    let raw = self.raw;
                    S5RETENTION_FIELD::from_value((raw & 0x00200000) >> 21)
                }

                pub fn set_s5retention(&mut self, value: S5RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_s5retention_with<
                    F: Fn(&mut S5RETENTION_FIELD) -> &mut S5RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s5retention();
                    f(&mut value);
                    self.set_s5retention(value)
                }

                pub fn s6retention(&self) -> S6RETENTION_FIELD {
                    let raw = self.raw;
                    S6RETENTION_FIELD::from_value((raw & 0x00400000) >> 22)
                }

                pub fn set_s6retention(&mut self, value: S6RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_s6retention_with<
                    F: Fn(&mut S6RETENTION_FIELD) -> &mut S6RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s6retention();
                    f(&mut value);
                    self.set_s6retention(value)
                }

                pub fn s7retention(&self) -> S7RETENTION_FIELD {
                    let raw = self.raw;
                    S7RETENTION_FIELD::from_value((raw & 0x00800000) >> 23)
                }

                pub fn set_s7retention(&mut self, value: S7RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_s7retention_with<
                    F: Fn(&mut S7RETENTION_FIELD) -> &mut S7RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s7retention();
                    f(&mut value);
                    self.set_s7retention(value)
                }

                pub fn s8retention(&self) -> S8RETENTION_FIELD {
                    let raw = self.raw;
                    S8RETENTION_FIELD::from_value((raw & 0x01000000) >> 24)
                }

                pub fn set_s8retention(&mut self, value: S8RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_s8retention_with<
                    F: Fn(&mut S8RETENTION_FIELD) -> &mut S8RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s8retention();
                    f(&mut value);
                    self.set_s8retention(value)
                }

                pub fn s9retention(&self) -> S9RETENTION_FIELD {
                    let raw = self.raw;
                    S9RETENTION_FIELD::from_value((raw & 0x02000000) >> 25)
                }

                pub fn set_s9retention(&mut self, value: S9RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_s9retention_with<
                    F: Fn(&mut S9RETENTION_FIELD) -> &mut S9RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s9retention();
                    f(&mut value);
                    self.set_s9retention(value)
                }

                pub fn s10retention(&self) -> S10RETENTION_FIELD {
                    let raw = self.raw;
                    S10RETENTION_FIELD::from_value((raw & 0x04000000) >> 26)
                }

                pub fn set_s10retention(&mut self, value: S10RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_s10retention_with<
                    F: Fn(&mut S10RETENTION_FIELD) -> &mut S10RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s10retention();
                    f(&mut value);
                    self.set_s10retention(value)
                }

                pub fn s11retention(&self) -> S11RETENTION_FIELD {
                    let raw = self.raw;
                    S11RETENTION_FIELD::from_value((raw & 0x08000000) >> 27)
                }

                pub fn set_s11retention(&mut self, value: S11RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_s11retention_with<
                    F: Fn(&mut S11RETENTION_FIELD) -> &mut S11RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s11retention();
                    f(&mut value);
                    self.set_s11retention(value)
                }

                pub fn s12retention(&self) -> S12RETENTION_FIELD {
                    let raw = self.raw;
                    S12RETENTION_FIELD::from_value((raw & 0x10000000) >> 28)
                }

                pub fn set_s12retention(&mut self, value: S12RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_s12retention_with<
                    F: Fn(&mut S12RETENTION_FIELD) -> &mut S12RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s12retention();
                    f(&mut value);
                    self.set_s12retention(value)
                }

                pub fn s13retention(&self) -> S13RETENTION_FIELD {
                    let raw = self.raw;
                    S13RETENTION_FIELD::from_value((raw & 0x20000000) >> 29)
                }

                pub fn set_s13retention(&mut self, value: S13RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_s13retention_with<
                    F: Fn(&mut S13RETENTION_FIELD) -> &mut S13RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s13retention();
                    f(&mut value);
                    self.set_s13retention(value)
                }

                pub fn s14retention(&self) -> S14RETENTION_FIELD {
                    let raw = self.raw;
                    S14RETENTION_FIELD::from_value((raw & 0x40000000) >> 30)
                }

                pub fn set_s14retention(&mut self, value: S14RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_s14retention_with<
                    F: Fn(&mut S14RETENTION_FIELD) -> &mut S14RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s14retention();
                    f(&mut value);
                    self.set_s14retention(value)
                }

                pub fn s15retention(&self) -> S15RETENTION_FIELD {
                    let raw = self.raw;
                    S15RETENTION_FIELD::from_value((raw & 0x80000000) >> 31)
                }

                pub fn set_s15retention(&mut self, value: S15RETENTION_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }

                pub fn set_s15retention_with<
                    F: Fn(&mut S15RETENTION_FIELD) -> &mut S15RETENTION_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.s15retention();
                    f(&mut value);
                    self.set_s15retention(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S0POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S1POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S2POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S3POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S4POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S5POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S6POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S7POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S8POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S9POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S10POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S11POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S12POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S13POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S14POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15POWER_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S15POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S0RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S1RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S2RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S3RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S4RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S5RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S6RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S7RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S8RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S9RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S10RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S11RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S12RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S13RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S14RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15RETENTION_FIELD u32 =>
                            // Off
                            Off = 0,
            // On
                            On = 1

                        );

            impl S15RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }

                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }
        }

        pub mod powerset {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct POWERSET {
                raw: RawRegister<u32>,
            }

            impl POWERSET {
                pub fn write_with<F: Fn(&mut POWERSET_WRITE_VALUE) -> &mut POWERSET_WRITE_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = POWERSET_WRITE_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterWrite for POWERSET {
                type Value = POWERSET_WRITE_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct POWERSET_WRITE_VALUE {
                raw: u32,
            }

            impl POWERSET_WRITE_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn set_s0power(&mut self) -> &mut Self {
                    let value = S0POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_s1power(&mut self) -> &mut Self {
                    let value = S1POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_s2power(&mut self) -> &mut Self {
                    let value = S2POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_s3power(&mut self) -> &mut Self {
                    let value = S3POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_s4power(&mut self) -> &mut Self {
                    let value = S4POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_s5power(&mut self) -> &mut Self {
                    let value = S5POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_s6power(&mut self) -> &mut Self {
                    let value = S6POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_s7power(&mut self) -> &mut Self {
                    let value = S7POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_s8power(&mut self) -> &mut Self {
                    let value = S8POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_s9power(&mut self) -> &mut Self {
                    let value = S9POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_s10power(&mut self) -> &mut Self {
                    let value = S10POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_s11power(&mut self) -> &mut Self {
                    let value = S11POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_s12power(&mut self) -> &mut Self {
                    let value = S12POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_s13power(&mut self) -> &mut Self {
                    let value = S13POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_s14power(&mut self) -> &mut Self {
                    let value = S14POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_s15power(&mut self) -> &mut Self {
                    let value = S15POWER_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_s0retention(&mut self) -> &mut Self {
                    let value = S0RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_s1retention(&mut self) -> &mut Self {
                    let value = S1RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_s2retention(&mut self) -> &mut Self {
                    let value = S2RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_s3retention(&mut self) -> &mut Self {
                    let value = S3RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_s4retention(&mut self) -> &mut Self {
                    let value = S4RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_s5retention(&mut self) -> &mut Self {
                    let value = S5RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_s6retention(&mut self) -> &mut Self {
                    let value = S6RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_s7retention(&mut self) -> &mut Self {
                    let value = S7RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_s8retention(&mut self) -> &mut Self {
                    let value = S8RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_s9retention(&mut self) -> &mut Self {
                    let value = S9RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_s10retention(&mut self) -> &mut Self {
                    let value = S10RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_s11retention(&mut self) -> &mut Self {
                    let value = S11RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_s12retention(&mut self) -> &mut Self {
                    let value = S12RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_s13retention(&mut self) -> &mut Self {
                    let value = S13RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_s14retention(&mut self) -> &mut Self {
                    let value = S14RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_s15retention(&mut self) -> &mut Self {
                    let value = S15RETENTION_FIELD::On.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S0POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S1POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S2POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S3POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S4POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S5POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S6POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S7POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S8POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S9POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S10POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S11POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S12POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S13POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S14POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15POWER_FIELD u32 =>
                // On
                On = 1

            );

            impl S15POWER_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S0RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S1RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S2RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S3RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S4RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S5RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S6RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S7RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S8RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S9RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S10RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S11RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S12RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S13RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S14RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15RETENTION_FIELD u32 =>
                // On
                On = 1

            );

            impl S15RETENTION_FIELD {
                pub fn is_on(&self) -> bool {
                    *self == Self::On
                }

                pub fn set_on(&mut self) -> &mut Self {
                    *self = Self::On;
                    self
                }
            }
        }

        pub mod powerclr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct POWERCLR {
                raw: RawRegister<u32>,
            }

            impl POWERCLR {
                pub fn write_with<F: Fn(&mut POWERCLR_WRITE_VALUE) -> &mut POWERCLR_WRITE_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = POWERCLR_WRITE_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterWrite for POWERCLR {
                type Value = POWERCLR_WRITE_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct POWERCLR_WRITE_VALUE {
                raw: u32,
            }

            impl POWERCLR_WRITE_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn set_s0power(&mut self) -> &mut Self {
                    let value = S0POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_s1power(&mut self) -> &mut Self {
                    let value = S1POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_s2power(&mut self) -> &mut Self {
                    let value = S2POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_s3power(&mut self) -> &mut Self {
                    let value = S3POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_s4power(&mut self) -> &mut Self {
                    let value = S4POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_s5power(&mut self) -> &mut Self {
                    let value = S5POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_s6power(&mut self) -> &mut Self {
                    let value = S6POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_s7power(&mut self) -> &mut Self {
                    let value = S7POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_s8power(&mut self) -> &mut Self {
                    let value = S8POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_s9power(&mut self) -> &mut Self {
                    let value = S9POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_s10power(&mut self) -> &mut Self {
                    let value = S10POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_s11power(&mut self) -> &mut Self {
                    let value = S11POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_s12power(&mut self) -> &mut Self {
                    let value = S12POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_s13power(&mut self) -> &mut Self {
                    let value = S13POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_s14power(&mut self) -> &mut Self {
                    let value = S14POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_s15power(&mut self) -> &mut Self {
                    let value = S15POWER_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_s0retention(&mut self) -> &mut Self {
                    let value = S0RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_s1retention(&mut self) -> &mut Self {
                    let value = S1RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_s2retention(&mut self) -> &mut Self {
                    let value = S2RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_s3retention(&mut self) -> &mut Self {
                    let value = S3RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_s4retention(&mut self) -> &mut Self {
                    let value = S4RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_s5retention(&mut self) -> &mut Self {
                    let value = S5RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_s6retention(&mut self) -> &mut Self {
                    let value = S6RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_s7retention(&mut self) -> &mut Self {
                    let value = S7RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_s8retention(&mut self) -> &mut Self {
                    let value = S8RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_s9retention(&mut self) -> &mut Self {
                    let value = S9RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_s10retention(&mut self) -> &mut Self {
                    let value = S10RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_s11retention(&mut self) -> &mut Self {
                    let value = S11RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_s12retention(&mut self) -> &mut Self {
                    let value = S12RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_s13retention(&mut self) -> &mut Self {
                    let value = S13RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_s14retention(&mut self) -> &mut Self {
                    let value = S14RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_s15retention(&mut self) -> &mut Self {
                    let value = S15RETENTION_FIELD::Off.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S0POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S1POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S2POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S3POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S4POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S5POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S6POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S7POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S8POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S9POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S10POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S11POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S12POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S13POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S14POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15POWER_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S15POWER_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S0RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S0RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S1RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S1RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S2RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S2RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S3RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S3RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S4RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S4RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S5RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S5RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S6RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S6RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S7RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S7RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S8RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S8RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S9RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S9RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S10RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S10RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S11RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S11RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S12RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S12RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S13RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S13RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S14RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S14RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] S15RETENTION_FIELD u32 =>
                // Off
                Off = 1

            );

            impl S15RETENTION_FIELD {
                pub fn is_off(&self) -> bool {
                    *self == Self::Off
                }

                pub fn set_off(&mut self) -> &mut Self {
                    *self = Self::Off;
                    self
                }
            }
        }
    }
}

pub mod p0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct P0 {
        _hidden: (),
    }

    impl P0 {
        const BASE_ADDRESS: u32 = 0x50000000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for P0 {
        type Target = P0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for P0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct P0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 1284],
        /// Write GPIO port
        pub out: out::OUT,
        /// Set individual bits in GPIO port
        pub outset: outset::OUTSET,
        /// Clear individual bits in GPIO port
        pub outclr: outclr::OUTCLR,
        /// Read GPIO port
        pub r#in: r#in::IN,
        /// Direction of GPIO pins
        pub dir: dir::DIR,
        /// DIR set register
        pub dirset: dirset::DIRSET,
        /// DIR clear register
        pub dirclr: dirclr::DIRCLR,
        /// Latch register indicating what GPIO pins that have met the criteria
        /// set in the PIN_CNF[n].SENSE registers
        pub latch: latch::LATCH,
        /// Select between default DETECT signal behavior and LDETECT mode
        pub detectmode: detectmode::DETECTMODE,
        _padding_1320: [u8; 472],
        /// Description collection: Configuration of GPIO pins
        pub pin_cnf: [pin_cnf::PIN_CNF; 32],
    }

    pub mod out {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct OUT {
            raw: RawRegister<u32>,
        }

        impl OUT {
            pub fn write_with<F: Fn(&mut OUT_VALUE) -> &mut OUT_VALUE>(&mut self, f: F) {
                let mut v = OUT_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for OUT {
            type Value = OUT_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                OUT_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for OUT {
            type Value = OUT_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct OUT_VALUE {
            raw: u32,
        }

        impl OUT_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }
    }

    pub mod outset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct OUTSET {
            raw: RawRegister<u32>,
        }

        impl OUTSET {
            pub fn write_with<F: Fn(&mut OUTSET_WRITE_VALUE) -> &mut OUTSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = OUTSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for OUTSET {
            type Value = OUTSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                OUTSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for OUTSET {
            type Value = OUTSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct OUTSET_READ_VALUE {
            raw: u32,
        }

        impl OUTSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct OUTSET_WRITE_VALUE {
            raw: u32,
        }

        impl OUTSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pin0(&mut self) -> &mut Self {
                let value = PIN0_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin1(&mut self) -> &mut Self {
                let value = PIN1_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin2(&mut self) -> &mut Self {
                let value = PIN2_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin3(&mut self) -> &mut Self {
                let value = PIN3_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin4(&mut self) -> &mut Self {
                let value = PIN4_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin5(&mut self) -> &mut Self {
                let value = PIN5_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin6(&mut self) -> &mut Self {
                let value = PIN6_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin7(&mut self) -> &mut Self {
                let value = PIN7_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin8(&mut self) -> &mut Self {
                let value = PIN8_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin9(&mut self) -> &mut Self {
                let value = PIN9_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin10(&mut self) -> &mut Self {
                let value = PIN10_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin11(&mut self) -> &mut Self {
                let value = PIN11_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin12(&mut self) -> &mut Self {
                let value = PIN12_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin13(&mut self) -> &mut Self {
                let value = PIN13_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin14(&mut self) -> &mut Self {
                let value = PIN14_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin15(&mut self) -> &mut Self {
                let value = PIN15_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin16(&mut self) -> &mut Self {
                let value = PIN16_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin17(&mut self) -> &mut Self {
                let value = PIN17_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin18(&mut self) -> &mut Self {
                let value = PIN18_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin19(&mut self) -> &mut Self {
                let value = PIN19_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin20(&mut self) -> &mut Self {
                let value = PIN20_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin21(&mut self) -> &mut Self {
                let value = PIN21_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin22(&mut self) -> &mut Self {
                let value = PIN22_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin23(&mut self) -> &mut Self {
                let value = PIN23_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin24(&mut self) -> &mut Self {
                let value = PIN24_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin25(&mut self) -> &mut Self {
                let value = PIN25_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin26(&mut self) -> &mut Self {
                let value = PIN26_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin27(&mut self) -> &mut Self {
                let value = PIN27_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin28(&mut self) -> &mut Self {
                let value = PIN28_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin29(&mut self) -> &mut Self {
                let value = PIN29_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin30(&mut self) -> &mut Self {
                let value = PIN30_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin31(&mut self) -> &mut Self {
                let value = PIN31_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN0_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN1_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN2_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN3_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN4_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN5_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN6_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN7_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN8_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN9_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN10_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN11_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN12_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN13_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN14_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN15_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN16_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN17_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN18_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN19_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN20_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN21_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN22_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN23_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN24_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN25_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN26_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN27_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN28_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN29_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN30_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin high; a '0' has no effect
            Set = 1

        );

        impl PIN31_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod outclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct OUTCLR {
            raw: RawRegister<u32>,
        }

        impl OUTCLR {
            pub fn write_with<F: Fn(&mut OUTCLR_WRITE_VALUE) -> &mut OUTCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = OUTCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for OUTCLR {
            type Value = OUTCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                OUTCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for OUTCLR {
            type Value = OUTCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct OUTCLR_READ_VALUE {
            raw: u32,
        }

        impl OUTCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct OUTCLR_WRITE_VALUE {
            raw: u32,
        }

        impl OUTCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pin0(&mut self) -> &mut Self {
                let value = PIN0_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin1(&mut self) -> &mut Self {
                let value = PIN1_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin2(&mut self) -> &mut Self {
                let value = PIN2_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin3(&mut self) -> &mut Self {
                let value = PIN3_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin4(&mut self) -> &mut Self {
                let value = PIN4_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin5(&mut self) -> &mut Self {
                let value = PIN5_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin6(&mut self) -> &mut Self {
                let value = PIN6_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin7(&mut self) -> &mut Self {
                let value = PIN7_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin8(&mut self) -> &mut Self {
                let value = PIN8_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin9(&mut self) -> &mut Self {
                let value = PIN9_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin10(&mut self) -> &mut Self {
                let value = PIN10_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin11(&mut self) -> &mut Self {
                let value = PIN11_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin12(&mut self) -> &mut Self {
                let value = PIN12_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin13(&mut self) -> &mut Self {
                let value = PIN13_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin14(&mut self) -> &mut Self {
                let value = PIN14_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin15(&mut self) -> &mut Self {
                let value = PIN15_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin16(&mut self) -> &mut Self {
                let value = PIN16_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin17(&mut self) -> &mut Self {
                let value = PIN17_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin18(&mut self) -> &mut Self {
                let value = PIN18_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin19(&mut self) -> &mut Self {
                let value = PIN19_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin20(&mut self) -> &mut Self {
                let value = PIN20_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin21(&mut self) -> &mut Self {
                let value = PIN21_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin22(&mut self) -> &mut Self {
                let value = PIN22_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin23(&mut self) -> &mut Self {
                let value = PIN23_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin24(&mut self) -> &mut Self {
                let value = PIN24_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin25(&mut self) -> &mut Self {
                let value = PIN25_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin26(&mut self) -> &mut Self {
                let value = PIN26_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin27(&mut self) -> &mut Self {
                let value = PIN27_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin28(&mut self) -> &mut Self {
                let value = PIN28_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin29(&mut self) -> &mut Self {
                let value = PIN29_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin30(&mut self) -> &mut Self {
                let value = PIN30_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin31(&mut self) -> &mut Self {
                let value = PIN31_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN0_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN1_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN2_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN3_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN4_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN5_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN6_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN7_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN8_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN9_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN10_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN11_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN12_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN13_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN14_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN15_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN16_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN17_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN18_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN19_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN20_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN21_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN22_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN23_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN24_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN25_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN26_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN27_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN28_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN29_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN30_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_WRITE_FIELD u32 =>
            // Write: a '1' sets the pin low; a '0' has no effect
            Clear = 1

        );

        impl PIN31_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod r#in {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct IN {
            raw: RawRegister<u32>,
        }

        impl IN {}

        impl RegisterRead for IN {
            type Value = IN_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                IN_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct IN_READ_VALUE {
            raw: u32,
        }

        impl IN_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PinLevel {
                let raw = self.raw;
                PinLevel::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PinLevel) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PinLevel) -> &mut PinLevel>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }
    }

    pub mod dir {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DIR {
            raw: RawRegister<u32>,
        }

        impl DIR {
            pub fn write_with<F: Fn(&mut DIR_VALUE) -> &mut DIR_VALUE>(&mut self, f: F) {
                let mut v = DIR_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DIR {
            type Value = DIR_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DIR_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DIR {
            type Value = DIR_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DIR_VALUE {
            raw: u32,
        }

        impl DIR_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PinDirection {
                let raw = self.raw;
                PinDirection::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PinDirection) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PinDirection) -> &mut PinDirection>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }
    }

    pub mod dirset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DIRSET {
            raw: RawRegister<u32>,
        }

        impl DIRSET {
            pub fn write_with<F: Fn(&mut DIRSET_WRITE_VALUE) -> &mut DIRSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = DIRSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DIRSET {
            type Value = DIRSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DIRSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DIRSET {
            type Value = DIRSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DIRSET_READ_VALUE {
            raw: u32,
        }

        impl DIRSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PIN0_READ_FIELD {
                let raw = self.raw;
                PIN0_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PIN0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PIN0_READ_FIELD) -> &mut PIN0_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PIN1_READ_FIELD {
                let raw = self.raw;
                PIN1_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PIN1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PIN1_READ_FIELD) -> &mut PIN1_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PIN2_READ_FIELD {
                let raw = self.raw;
                PIN2_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PIN2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PIN2_READ_FIELD) -> &mut PIN2_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PIN3_READ_FIELD {
                let raw = self.raw;
                PIN3_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PIN3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PIN3_READ_FIELD) -> &mut PIN3_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PIN4_READ_FIELD {
                let raw = self.raw;
                PIN4_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PIN4_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PIN4_READ_FIELD) -> &mut PIN4_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PIN5_READ_FIELD {
                let raw = self.raw;
                PIN5_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PIN5_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PIN5_READ_FIELD) -> &mut PIN5_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PIN6_READ_FIELD {
                let raw = self.raw;
                PIN6_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PIN6_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PIN6_READ_FIELD) -> &mut PIN6_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PIN7_READ_FIELD {
                let raw = self.raw;
                PIN7_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PIN7_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PIN7_READ_FIELD) -> &mut PIN7_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PIN8_READ_FIELD {
                let raw = self.raw;
                PIN8_READ_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PIN8_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PIN8_READ_FIELD) -> &mut PIN8_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PIN9_READ_FIELD {
                let raw = self.raw;
                PIN9_READ_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PIN9_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PIN9_READ_FIELD) -> &mut PIN9_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PIN10_READ_FIELD {
                let raw = self.raw;
                PIN10_READ_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PIN10_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PIN10_READ_FIELD) -> &mut PIN10_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PIN11_READ_FIELD {
                let raw = self.raw;
                PIN11_READ_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PIN11_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PIN11_READ_FIELD) -> &mut PIN11_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PIN12_READ_FIELD {
                let raw = self.raw;
                PIN12_READ_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PIN12_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PIN12_READ_FIELD) -> &mut PIN12_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PIN13_READ_FIELD {
                let raw = self.raw;
                PIN13_READ_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PIN13_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PIN13_READ_FIELD) -> &mut PIN13_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PIN14_READ_FIELD {
                let raw = self.raw;
                PIN14_READ_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PIN14_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PIN14_READ_FIELD) -> &mut PIN14_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PIN15_READ_FIELD {
                let raw = self.raw;
                PIN15_READ_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PIN15_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PIN15_READ_FIELD) -> &mut PIN15_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PIN16_READ_FIELD {
                let raw = self.raw;
                PIN16_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PIN16_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PIN16_READ_FIELD) -> &mut PIN16_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PIN17_READ_FIELD {
                let raw = self.raw;
                PIN17_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PIN17_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PIN17_READ_FIELD) -> &mut PIN17_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PIN18_READ_FIELD {
                let raw = self.raw;
                PIN18_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PIN18_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PIN18_READ_FIELD) -> &mut PIN18_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PIN19_READ_FIELD {
                let raw = self.raw;
                PIN19_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PIN19_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PIN19_READ_FIELD) -> &mut PIN19_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PIN20_READ_FIELD {
                let raw = self.raw;
                PIN20_READ_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PIN20_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PIN20_READ_FIELD) -> &mut PIN20_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PIN21_READ_FIELD {
                let raw = self.raw;
                PIN21_READ_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PIN21_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PIN21_READ_FIELD) -> &mut PIN21_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PIN22_READ_FIELD {
                let raw = self.raw;
                PIN22_READ_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PIN22_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PIN22_READ_FIELD) -> &mut PIN22_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PIN23_READ_FIELD {
                let raw = self.raw;
                PIN23_READ_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PIN23_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PIN23_READ_FIELD) -> &mut PIN23_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PIN24_READ_FIELD {
                let raw = self.raw;
                PIN24_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PIN24_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PIN24_READ_FIELD) -> &mut PIN24_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PIN25_READ_FIELD {
                let raw = self.raw;
                PIN25_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PIN25_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PIN25_READ_FIELD) -> &mut PIN25_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PIN26_READ_FIELD {
                let raw = self.raw;
                PIN26_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PIN26_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PIN26_READ_FIELD) -> &mut PIN26_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PIN27_READ_FIELD {
                let raw = self.raw;
                PIN27_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PIN27_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PIN27_READ_FIELD) -> &mut PIN27_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PIN28_READ_FIELD {
                let raw = self.raw;
                PIN28_READ_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PIN28_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PIN28_READ_FIELD) -> &mut PIN28_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PIN29_READ_FIELD {
                let raw = self.raw;
                PIN29_READ_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PIN29_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PIN29_READ_FIELD) -> &mut PIN29_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PIN30_READ_FIELD {
                let raw = self.raw;
                PIN30_READ_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PIN30_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PIN30_READ_FIELD) -> &mut PIN30_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PIN31_READ_FIELD {
                let raw = self.raw;
                PIN31_READ_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PIN31_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PIN31_READ_FIELD) -> &mut PIN31_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DIRSET_WRITE_VALUE {
            raw: u32,
        }

        impl DIRSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pin0(&mut self) -> &mut Self {
                let value = PIN0_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin1(&mut self) -> &mut Self {
                let value = PIN1_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin2(&mut self) -> &mut Self {
                let value = PIN2_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin3(&mut self) -> &mut Self {
                let value = PIN3_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin4(&mut self) -> &mut Self {
                let value = PIN4_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin5(&mut self) -> &mut Self {
                let value = PIN5_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin6(&mut self) -> &mut Self {
                let value = PIN6_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin7(&mut self) -> &mut Self {
                let value = PIN7_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin8(&mut self) -> &mut Self {
                let value = PIN8_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin9(&mut self) -> &mut Self {
                let value = PIN9_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin10(&mut self) -> &mut Self {
                let value = PIN10_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin11(&mut self) -> &mut Self {
                let value = PIN11_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin12(&mut self) -> &mut Self {
                let value = PIN12_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin13(&mut self) -> &mut Self {
                let value = PIN13_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin14(&mut self) -> &mut Self {
                let value = PIN14_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin15(&mut self) -> &mut Self {
                let value = PIN15_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin16(&mut self) -> &mut Self {
                let value = PIN16_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin17(&mut self) -> &mut Self {
                let value = PIN17_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin18(&mut self) -> &mut Self {
                let value = PIN18_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin19(&mut self) -> &mut Self {
                let value = PIN19_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin20(&mut self) -> &mut Self {
                let value = PIN20_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin21(&mut self) -> &mut Self {
                let value = PIN21_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin22(&mut self) -> &mut Self {
                let value = PIN22_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin23(&mut self) -> &mut Self {
                let value = PIN23_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin24(&mut self) -> &mut Self {
                let value = PIN24_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin25(&mut self) -> &mut Self {
                let value = PIN25_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin26(&mut self) -> &mut Self {
                let value = PIN26_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin27(&mut self) -> &mut Self {
                let value = PIN27_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin28(&mut self) -> &mut Self {
                let value = PIN28_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin29(&mut self) -> &mut Self {
                let value = PIN29_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin30(&mut self) -> &mut Self {
                let value = PIN30_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin31(&mut self) -> &mut Self {
                let value = PIN31_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN0_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN0_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN1_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN1_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN2_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN2_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN3_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN3_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN4_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN4_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN5_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN5_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN6_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN6_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN7_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN7_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN8_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN8_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN9_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN9_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN10_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN10_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN11_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN11_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN12_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN12_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN13_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN13_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN14_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN14_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN15_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN15_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN16_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN16_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN17_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN17_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN18_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN18_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN19_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN19_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN20_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN20_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN21_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN21_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN22_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN22_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN23_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN23_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN24_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN24_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN25_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN25_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN26_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN26_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN27_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN27_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN28_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN28_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN29_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN29_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN30_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN30_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN31_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to output; a '0' has no effect
            Set = 1

        );

        impl PIN31_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod dirclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DIRCLR {
            raw: RawRegister<u32>,
        }

        impl DIRCLR {
            pub fn write_with<F: Fn(&mut DIRCLR_WRITE_VALUE) -> &mut DIRCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = DIRCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DIRCLR {
            type Value = DIRCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DIRCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DIRCLR {
            type Value = DIRCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DIRCLR_READ_VALUE {
            raw: u32,
        }

        impl DIRCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PIN0_READ_FIELD {
                let raw = self.raw;
                PIN0_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PIN0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PIN0_READ_FIELD) -> &mut PIN0_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PIN1_READ_FIELD {
                let raw = self.raw;
                PIN1_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PIN1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PIN1_READ_FIELD) -> &mut PIN1_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PIN2_READ_FIELD {
                let raw = self.raw;
                PIN2_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PIN2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PIN2_READ_FIELD) -> &mut PIN2_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PIN3_READ_FIELD {
                let raw = self.raw;
                PIN3_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PIN3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PIN3_READ_FIELD) -> &mut PIN3_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PIN4_READ_FIELD {
                let raw = self.raw;
                PIN4_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PIN4_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PIN4_READ_FIELD) -> &mut PIN4_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PIN5_READ_FIELD {
                let raw = self.raw;
                PIN5_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PIN5_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PIN5_READ_FIELD) -> &mut PIN5_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PIN6_READ_FIELD {
                let raw = self.raw;
                PIN6_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PIN6_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PIN6_READ_FIELD) -> &mut PIN6_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PIN7_READ_FIELD {
                let raw = self.raw;
                PIN7_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PIN7_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PIN7_READ_FIELD) -> &mut PIN7_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PIN8_READ_FIELD {
                let raw = self.raw;
                PIN8_READ_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PIN8_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PIN8_READ_FIELD) -> &mut PIN8_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PIN9_READ_FIELD {
                let raw = self.raw;
                PIN9_READ_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PIN9_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PIN9_READ_FIELD) -> &mut PIN9_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PIN10_READ_FIELD {
                let raw = self.raw;
                PIN10_READ_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PIN10_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PIN10_READ_FIELD) -> &mut PIN10_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PIN11_READ_FIELD {
                let raw = self.raw;
                PIN11_READ_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PIN11_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PIN11_READ_FIELD) -> &mut PIN11_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PIN12_READ_FIELD {
                let raw = self.raw;
                PIN12_READ_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PIN12_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PIN12_READ_FIELD) -> &mut PIN12_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PIN13_READ_FIELD {
                let raw = self.raw;
                PIN13_READ_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PIN13_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PIN13_READ_FIELD) -> &mut PIN13_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PIN14_READ_FIELD {
                let raw = self.raw;
                PIN14_READ_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PIN14_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PIN14_READ_FIELD) -> &mut PIN14_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PIN15_READ_FIELD {
                let raw = self.raw;
                PIN15_READ_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PIN15_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PIN15_READ_FIELD) -> &mut PIN15_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PIN16_READ_FIELD {
                let raw = self.raw;
                PIN16_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PIN16_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PIN16_READ_FIELD) -> &mut PIN16_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PIN17_READ_FIELD {
                let raw = self.raw;
                PIN17_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PIN17_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PIN17_READ_FIELD) -> &mut PIN17_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PIN18_READ_FIELD {
                let raw = self.raw;
                PIN18_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PIN18_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PIN18_READ_FIELD) -> &mut PIN18_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PIN19_READ_FIELD {
                let raw = self.raw;
                PIN19_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PIN19_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PIN19_READ_FIELD) -> &mut PIN19_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PIN20_READ_FIELD {
                let raw = self.raw;
                PIN20_READ_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PIN20_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PIN20_READ_FIELD) -> &mut PIN20_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PIN21_READ_FIELD {
                let raw = self.raw;
                PIN21_READ_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PIN21_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PIN21_READ_FIELD) -> &mut PIN21_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PIN22_READ_FIELD {
                let raw = self.raw;
                PIN22_READ_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PIN22_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PIN22_READ_FIELD) -> &mut PIN22_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PIN23_READ_FIELD {
                let raw = self.raw;
                PIN23_READ_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PIN23_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PIN23_READ_FIELD) -> &mut PIN23_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PIN24_READ_FIELD {
                let raw = self.raw;
                PIN24_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PIN24_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PIN24_READ_FIELD) -> &mut PIN24_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PIN25_READ_FIELD {
                let raw = self.raw;
                PIN25_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PIN25_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PIN25_READ_FIELD) -> &mut PIN25_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PIN26_READ_FIELD {
                let raw = self.raw;
                PIN26_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PIN26_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PIN26_READ_FIELD) -> &mut PIN26_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PIN27_READ_FIELD {
                let raw = self.raw;
                PIN27_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PIN27_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PIN27_READ_FIELD) -> &mut PIN27_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PIN28_READ_FIELD {
                let raw = self.raw;
                PIN28_READ_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PIN28_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PIN28_READ_FIELD) -> &mut PIN28_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PIN29_READ_FIELD {
                let raw = self.raw;
                PIN29_READ_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PIN29_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PIN29_READ_FIELD) -> &mut PIN29_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PIN30_READ_FIELD {
                let raw = self.raw;
                PIN30_READ_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PIN30_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PIN30_READ_FIELD) -> &mut PIN30_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PIN31_READ_FIELD {
                let raw = self.raw;
                PIN31_READ_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PIN31_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PIN31_READ_FIELD) -> &mut PIN31_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DIRCLR_WRITE_VALUE {
            raw: u32,
        }

        impl DIRCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_pin0(&mut self) -> &mut Self {
                let value = PIN0_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin1(&mut self) -> &mut Self {
                let value = PIN1_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin2(&mut self) -> &mut Self {
                let value = PIN2_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin3(&mut self) -> &mut Self {
                let value = PIN3_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin4(&mut self) -> &mut Self {
                let value = PIN4_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin5(&mut self) -> &mut Self {
                let value = PIN5_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin6(&mut self) -> &mut Self {
                let value = PIN6_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin7(&mut self) -> &mut Self {
                let value = PIN7_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin8(&mut self) -> &mut Self {
                let value = PIN8_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin9(&mut self) -> &mut Self {
                let value = PIN9_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin10(&mut self) -> &mut Self {
                let value = PIN10_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin11(&mut self) -> &mut Self {
                let value = PIN11_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin12(&mut self) -> &mut Self {
                let value = PIN12_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin13(&mut self) -> &mut Self {
                let value = PIN13_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin14(&mut self) -> &mut Self {
                let value = PIN14_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin15(&mut self) -> &mut Self {
                let value = PIN15_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin16(&mut self) -> &mut Self {
                let value = PIN16_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin17(&mut self) -> &mut Self {
                let value = PIN17_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin18(&mut self) -> &mut Self {
                let value = PIN18_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin19(&mut self) -> &mut Self {
                let value = PIN19_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin20(&mut self) -> &mut Self {
                let value = PIN20_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin21(&mut self) -> &mut Self {
                let value = PIN21_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin22(&mut self) -> &mut Self {
                let value = PIN22_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin23(&mut self) -> &mut Self {
                let value = PIN23_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin24(&mut self) -> &mut Self {
                let value = PIN24_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin25(&mut self) -> &mut Self {
                let value = PIN25_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin26(&mut self) -> &mut Self {
                let value = PIN26_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin27(&mut self) -> &mut Self {
                let value = PIN27_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin28(&mut self) -> &mut Self {
                let value = PIN28_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin29(&mut self) -> &mut Self {
                let value = PIN29_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin30(&mut self) -> &mut Self {
                let value = PIN30_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin31(&mut self) -> &mut Self {
                let value = PIN31_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN0_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN0_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN1_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN1_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN2_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN2_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN3_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN3_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN4_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN4_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN5_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN5_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN6_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN6_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN7_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN7_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN8_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN8_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN9_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN9_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN10_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN10_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN11_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN11_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN12_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN12_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN13_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN13_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN14_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN14_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN15_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN15_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN16_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN16_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN17_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN17_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN18_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN18_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN19_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN19_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN20_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN20_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN21_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN21_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN22_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN22_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN23_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN23_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN24_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN24_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN25_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN25_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN26_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN26_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN27_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN27_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN28_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN28_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN29_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN29_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN30_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN30_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_READ_FIELD u32 =>
                        // Read: pin set as input
                        Input = 0,
        // Read: pin set as output
                        Output = 1

                    );

        impl PIN31_READ_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_WRITE_FIELD u32 =>
            // Write: a '1' sets pin to input; a '0' has no effect
            Clear = 1

        );

        impl PIN31_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod latch {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LATCH {
            raw: RawRegister<u32>,
        }

        impl LATCH {
            pub fn write_with<F: Fn(&mut LATCH_VALUE) -> &mut LATCH_VALUE>(&mut self, f: F) {
                let mut v = LATCH_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for LATCH {
            type Value = LATCH_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LATCH_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for LATCH {
            type Value = LATCH_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LATCH_VALUE {
            raw: u32,
        }

        impl LATCH_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin0(&self) -> PIN0_FIELD {
                let raw = self.raw;
                PIN0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pin0(&mut self, value: PIN0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pin0_with<F: Fn(&mut PIN0_FIELD) -> &mut PIN0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin0();
                f(&mut value);
                self.set_pin0(value)
            }

            pub fn pin1(&self) -> PIN1_FIELD {
                let raw = self.raw;
                PIN1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_pin1(&mut self, value: PIN1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_pin1_with<F: Fn(&mut PIN1_FIELD) -> &mut PIN1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin1();
                f(&mut value);
                self.set_pin1(value)
            }

            pub fn pin2(&self) -> PIN2_FIELD {
                let raw = self.raw;
                PIN2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_pin2(&mut self, value: PIN2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_pin2_with<F: Fn(&mut PIN2_FIELD) -> &mut PIN2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin2();
                f(&mut value);
                self.set_pin2(value)
            }

            pub fn pin3(&self) -> PIN3_FIELD {
                let raw = self.raw;
                PIN3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_pin3(&mut self, value: PIN3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_pin3_with<F: Fn(&mut PIN3_FIELD) -> &mut PIN3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin3();
                f(&mut value);
                self.set_pin3(value)
            }

            pub fn pin4(&self) -> PIN4_FIELD {
                let raw = self.raw;
                PIN4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_pin4(&mut self, value: PIN4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_pin4_with<F: Fn(&mut PIN4_FIELD) -> &mut PIN4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin4();
                f(&mut value);
                self.set_pin4(value)
            }

            pub fn pin5(&self) -> PIN5_FIELD {
                let raw = self.raw;
                PIN5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_pin5(&mut self, value: PIN5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pin5_with<F: Fn(&mut PIN5_FIELD) -> &mut PIN5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin5();
                f(&mut value);
                self.set_pin5(value)
            }

            pub fn pin6(&self) -> PIN6_FIELD {
                let raw = self.raw;
                PIN6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pin6(&mut self, value: PIN6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pin6_with<F: Fn(&mut PIN6_FIELD) -> &mut PIN6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin6();
                f(&mut value);
                self.set_pin6(value)
            }

            pub fn pin7(&self) -> PIN7_FIELD {
                let raw = self.raw;
                PIN7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_pin7(&mut self, value: PIN7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pin7_with<F: Fn(&mut PIN7_FIELD) -> &mut PIN7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin7();
                f(&mut value);
                self.set_pin7(value)
            }

            pub fn pin8(&self) -> PIN8_FIELD {
                let raw = self.raw;
                PIN8_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_pin8(&mut self, value: PIN8_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_pin8_with<F: Fn(&mut PIN8_FIELD) -> &mut PIN8_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin8();
                f(&mut value);
                self.set_pin8(value)
            }

            pub fn pin9(&self) -> PIN9_FIELD {
                let raw = self.raw;
                PIN9_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_pin9(&mut self, value: PIN9_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_pin9_with<F: Fn(&mut PIN9_FIELD) -> &mut PIN9_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin9();
                f(&mut value);
                self.set_pin9(value)
            }

            pub fn pin10(&self) -> PIN10_FIELD {
                let raw = self.raw;
                PIN10_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_pin10(&mut self, value: PIN10_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_pin10_with<F: Fn(&mut PIN10_FIELD) -> &mut PIN10_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin10();
                f(&mut value);
                self.set_pin10(value)
            }

            pub fn pin11(&self) -> PIN11_FIELD {
                let raw = self.raw;
                PIN11_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_pin11(&mut self, value: PIN11_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_pin11_with<F: Fn(&mut PIN11_FIELD) -> &mut PIN11_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin11();
                f(&mut value);
                self.set_pin11(value)
            }

            pub fn pin12(&self) -> PIN12_FIELD {
                let raw = self.raw;
                PIN12_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_pin12(&mut self, value: PIN12_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_pin12_with<F: Fn(&mut PIN12_FIELD) -> &mut PIN12_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin12();
                f(&mut value);
                self.set_pin12(value)
            }

            pub fn pin13(&self) -> PIN13_FIELD {
                let raw = self.raw;
                PIN13_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_pin13(&mut self, value: PIN13_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_pin13_with<F: Fn(&mut PIN13_FIELD) -> &mut PIN13_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin13();
                f(&mut value);
                self.set_pin13(value)
            }

            pub fn pin14(&self) -> PIN14_FIELD {
                let raw = self.raw;
                PIN14_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_pin14(&mut self, value: PIN14_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_pin14_with<F: Fn(&mut PIN14_FIELD) -> &mut PIN14_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin14();
                f(&mut value);
                self.set_pin14(value)
            }

            pub fn pin15(&self) -> PIN15_FIELD {
                let raw = self.raw;
                PIN15_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_pin15(&mut self, value: PIN15_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_pin15_with<F: Fn(&mut PIN15_FIELD) -> &mut PIN15_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin15();
                f(&mut value);
                self.set_pin15(value)
            }

            pub fn pin16(&self) -> PIN16_FIELD {
                let raw = self.raw;
                PIN16_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_pin16(&mut self, value: PIN16_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_pin16_with<F: Fn(&mut PIN16_FIELD) -> &mut PIN16_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin16();
                f(&mut value);
                self.set_pin16(value)
            }

            pub fn pin17(&self) -> PIN17_FIELD {
                let raw = self.raw;
                PIN17_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_pin17(&mut self, value: PIN17_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_pin17_with<F: Fn(&mut PIN17_FIELD) -> &mut PIN17_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin17();
                f(&mut value);
                self.set_pin17(value)
            }

            pub fn pin18(&self) -> PIN18_FIELD {
                let raw = self.raw;
                PIN18_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_pin18(&mut self, value: PIN18_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_pin18_with<F: Fn(&mut PIN18_FIELD) -> &mut PIN18_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin18();
                f(&mut value);
                self.set_pin18(value)
            }

            pub fn pin19(&self) -> PIN19_FIELD {
                let raw = self.raw;
                PIN19_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_pin19(&mut self, value: PIN19_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_pin19_with<F: Fn(&mut PIN19_FIELD) -> &mut PIN19_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin19();
                f(&mut value);
                self.set_pin19(value)
            }

            pub fn pin20(&self) -> PIN20_FIELD {
                let raw = self.raw;
                PIN20_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_pin20(&mut self, value: PIN20_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_pin20_with<F: Fn(&mut PIN20_FIELD) -> &mut PIN20_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin20();
                f(&mut value);
                self.set_pin20(value)
            }

            pub fn pin21(&self) -> PIN21_FIELD {
                let raw = self.raw;
                PIN21_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_pin21(&mut self, value: PIN21_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_pin21_with<F: Fn(&mut PIN21_FIELD) -> &mut PIN21_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin21();
                f(&mut value);
                self.set_pin21(value)
            }

            pub fn pin22(&self) -> PIN22_FIELD {
                let raw = self.raw;
                PIN22_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_pin22(&mut self, value: PIN22_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_pin22_with<F: Fn(&mut PIN22_FIELD) -> &mut PIN22_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin22();
                f(&mut value);
                self.set_pin22(value)
            }

            pub fn pin23(&self) -> PIN23_FIELD {
                let raw = self.raw;
                PIN23_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_pin23(&mut self, value: PIN23_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_pin23_with<F: Fn(&mut PIN23_FIELD) -> &mut PIN23_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin23();
                f(&mut value);
                self.set_pin23(value)
            }

            pub fn pin24(&self) -> PIN24_FIELD {
                let raw = self.raw;
                PIN24_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pin24(&mut self, value: PIN24_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pin24_with<F: Fn(&mut PIN24_FIELD) -> &mut PIN24_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin24();
                f(&mut value);
                self.set_pin24(value)
            }

            pub fn pin25(&self) -> PIN25_FIELD {
                let raw = self.raw;
                PIN25_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pin25(&mut self, value: PIN25_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pin25_with<F: Fn(&mut PIN25_FIELD) -> &mut PIN25_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin25();
                f(&mut value);
                self.set_pin25(value)
            }

            pub fn pin26(&self) -> PIN26_FIELD {
                let raw = self.raw;
                PIN26_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pin26(&mut self, value: PIN26_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pin26_with<F: Fn(&mut PIN26_FIELD) -> &mut PIN26_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin26();
                f(&mut value);
                self.set_pin26(value)
            }

            pub fn pin27(&self) -> PIN27_FIELD {
                let raw = self.raw;
                PIN27_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pin27(&mut self, value: PIN27_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pin27_with<F: Fn(&mut PIN27_FIELD) -> &mut PIN27_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin27();
                f(&mut value);
                self.set_pin27(value)
            }

            pub fn pin28(&self) -> PIN28_FIELD {
                let raw = self.raw;
                PIN28_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_pin28(&mut self, value: PIN28_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_pin28_with<F: Fn(&mut PIN28_FIELD) -> &mut PIN28_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin28();
                f(&mut value);
                self.set_pin28(value)
            }

            pub fn pin29(&self) -> PIN29_FIELD {
                let raw = self.raw;
                PIN29_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_pin29(&mut self, value: PIN29_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_pin29_with<F: Fn(&mut PIN29_FIELD) -> &mut PIN29_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin29();
                f(&mut value);
                self.set_pin29(value)
            }

            pub fn pin30(&self) -> PIN30_FIELD {
                let raw = self.raw;
                PIN30_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_pin30(&mut self, value: PIN30_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_pin30_with<F: Fn(&mut PIN30_FIELD) -> &mut PIN30_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin30();
                f(&mut value);
                self.set_pin30(value)
            }

            pub fn pin31(&self) -> PIN31_FIELD {
                let raw = self.raw;
                PIN31_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_pin31(&mut self, value: PIN31_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_pin31_with<F: Fn(&mut PIN31_FIELD) -> &mut PIN31_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pin31();
                f(&mut value);
                self.set_pin31(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN0_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN0_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN1_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN1_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN2_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN2_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN3_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN3_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN4_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN4_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN5_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN5_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN6_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN6_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN7_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN7_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN8_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN8_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN9_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN9_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN10_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN10_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN11_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN11_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN12_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN12_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN13_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN13_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN14_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN14_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN15_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN15_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN16_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN16_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN17_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN17_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN18_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN18_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN19_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN19_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN20_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN20_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN21_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN21_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN22_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN22_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN23_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN23_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN24_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN24_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN25_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN25_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN26_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN26_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN27_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN27_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN28_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN28_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN29_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN29_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN30_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN30_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PIN31_FIELD u32 =>
                        // Criteria has not been met
                        NotLatched = 0,
        // Criteria has been met
                        Latched = 1

                    );

        impl PIN31_FIELD {
            pub fn is_notlatched(&self) -> bool {
                *self == Self::NotLatched
            }

            pub fn set_notlatched(&mut self) -> &mut Self {
                *self = Self::NotLatched;
                self
            }

            pub fn is_latched(&self) -> bool {
                *self == Self::Latched
            }

            pub fn set_latched(&mut self) -> &mut Self {
                *self = Self::Latched;
                self
            }
        }
    }

    pub mod detectmode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DETECTMODE {
            raw: RawRegister<u32>,
        }

        impl DETECTMODE {
            pub fn write_default(&mut self) {
                self.write(DETECTMODE_FIELD::Default)
            }

            pub fn write_ldetect(&mut self) {
                self.write(DETECTMODE_FIELD::LDETECT)
            }
        }

        impl RegisterRead for DETECTMODE {
            type Value = DETECTMODE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                DETECTMODE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for DETECTMODE {
            type Value = DETECTMODE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DETECTMODE_FIELD u32 =>
                        // DETECT directly connected to PIN DETECT signals
                        Default = 0,
        // Use the latched LDETECT behavior
                        LDETECT = 1

                    );

        impl DETECTMODE_FIELD {
            pub fn is_default(&self) -> bool {
                *self == Self::Default
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::Default;
                self
            }

            pub fn is_ldetect(&self) -> bool {
                *self == Self::LDETECT
            }

            pub fn set_ldetect(&mut self) -> &mut Self {
                *self = Self::LDETECT;
                self
            }
        }
    }

    pub mod pin_cnf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PIN_CNF {
            raw: RawRegister<u32>,
        }

        impl PIN_CNF {
            pub fn write_with<F: Fn(&mut PIN_CNF_VALUE) -> &mut PIN_CNF_VALUE>(&mut self, f: F) {
                let mut v = PIN_CNF_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PIN_CNF {
            type Value = PIN_CNF_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PIN_CNF_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PIN_CNF {
            type Value = PIN_CNF_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PIN_CNF_VALUE {
            raw: u32,
        }

        impl PIN_CNF_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn dir(&self) -> DIR_FIELD {
                let raw = self.raw;
                DIR_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_dir(&mut self, value: DIR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_dir_with<F: Fn(&mut DIR_FIELD) -> &mut DIR_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dir();
                f(&mut value);
                self.set_dir(value)
            }

            pub fn input(&self) -> INPUT_FIELD {
                let raw = self.raw;
                INPUT_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_input(&mut self, value: INPUT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_input_with<F: Fn(&mut INPUT_FIELD) -> &mut INPUT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.input();
                f(&mut value);
                self.set_input(value)
            }

            pub fn pull(&self) -> PULL_FIELD {
                let raw = self.raw;
                PULL_FIELD::from_value((raw & 0x0000000c) >> 2)
            }

            pub fn set_pull(&mut self, value: PULL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000000c) | (value << 2);
                self
            }

            pub fn set_pull_with<F: Fn(&mut PULL_FIELD) -> &mut PULL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pull();
                f(&mut value);
                self.set_pull(value)
            }

            pub fn drive(&self) -> DRIVE_FIELD {
                let raw = self.raw;
                DRIVE_FIELD::from_value((raw & 0x00000700) >> 8)
            }

            pub fn set_drive(&mut self, value: DRIVE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000700) | (value << 8);
                self
            }

            pub fn set_drive_with<F: Fn(&mut DRIVE_FIELD) -> &mut DRIVE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.drive();
                f(&mut value);
                self.set_drive(value)
            }

            pub fn sense(&self) -> SENSE_FIELD {
                let raw = self.raw;
                SENSE_FIELD::from_value((raw & 0x00030000) >> 16)
            }

            pub fn set_sense(&mut self, value: SENSE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00030000) | (value << 16);
                self
            }

            pub fn set_sense_with<F: Fn(&mut SENSE_FIELD) -> &mut SENSE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sense();
                f(&mut value);
                self.set_sense(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DIR_FIELD u32 =>
                        // Configure pin as an input pin
                        Input = 0,
        // Configure pin as an output pin
                        Output = 1

                    );

        impl DIR_FIELD {
            pub fn is_input(&self) -> bool {
                *self == Self::Input
            }

            pub fn set_input(&mut self) -> &mut Self {
                *self = Self::Input;
                self
            }

            pub fn is_output(&self) -> bool {
                *self == Self::Output
            }

            pub fn set_output(&mut self) -> &mut Self {
                *self = Self::Output;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] INPUT_FIELD u32 =>
                        // Connect input buffer
                        Connect = 0,
        // Disconnect input buffer
                        Disconnect = 1

                    );

        impl INPUT_FIELD {
            pub fn is_connect(&self) -> bool {
                *self == Self::Connect
            }

            pub fn set_connect(&mut self) -> &mut Self {
                *self = Self::Connect;
                self
            }

            pub fn is_disconnect(&self) -> bool {
                *self == Self::Disconnect
            }

            pub fn set_disconnect(&mut self) -> &mut Self {
                *self = Self::Disconnect;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PULL_FIELD u32 =>
                        // No pull
                        Disabled = 0,
        // Pull down on pin
                        Pulldown = 1,
        // Pull up on pin
                        Pullup = 3

                    );

        impl PULL_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_pulldown(&self) -> bool {
                *self == Self::Pulldown
            }

            pub fn set_pulldown(&mut self) -> &mut Self {
                *self = Self::Pulldown;
                self
            }

            pub fn is_pullup(&self) -> bool {
                *self == Self::Pullup
            }

            pub fn set_pullup(&mut self) -> &mut Self {
                *self = Self::Pullup;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DRIVE_FIELD u32 =>
                        // Standard '0', standard '1'
                        S0S1 = 0,
        // High drive '0', standard '1'
                        H0S1 = 1,
        // Standard '0', high drive '1'
                        S0H1 = 2,
        // High drive '0', high 'drive '1''
                        H0H1 = 3,
        // Disconnect '0' standard '1' (normally used for wired-or connections)
                        D0S1 = 4,
        // Disconnect '0', high drive '1' (normally used for wired-or connections)
                        D0H1 = 5,
        // Standard '0'. disconnect '1' (normally used for wired-and connections)
                        S0D1 = 6,
        // High drive '0', disconnect '1' (normally used for wired-and connections)
                        H0D1 = 7

                    );

        impl DRIVE_FIELD {
            pub fn is_s0s1(&self) -> bool {
                *self == Self::S0S1
            }

            pub fn set_s0s1(&mut self) -> &mut Self {
                *self = Self::S0S1;
                self
            }

            pub fn is_h0s1(&self) -> bool {
                *self == Self::H0S1
            }

            pub fn set_h0s1(&mut self) -> &mut Self {
                *self = Self::H0S1;
                self
            }

            pub fn is_s0h1(&self) -> bool {
                *self == Self::S0H1
            }

            pub fn set_s0h1(&mut self) -> &mut Self {
                *self = Self::S0H1;
                self
            }

            pub fn is_h0h1(&self) -> bool {
                *self == Self::H0H1
            }

            pub fn set_h0h1(&mut self) -> &mut Self {
                *self = Self::H0H1;
                self
            }

            pub fn is_d0s1(&self) -> bool {
                *self == Self::D0S1
            }

            pub fn set_d0s1(&mut self) -> &mut Self {
                *self = Self::D0S1;
                self
            }

            pub fn is_d0h1(&self) -> bool {
                *self == Self::D0H1
            }

            pub fn set_d0h1(&mut self) -> &mut Self {
                *self = Self::D0H1;
                self
            }

            pub fn is_s0d1(&self) -> bool {
                *self == Self::S0D1
            }

            pub fn set_s0d1(&mut self) -> &mut Self {
                *self = Self::S0D1;
                self
            }

            pub fn is_h0d1(&self) -> bool {
                *self == Self::H0D1
            }

            pub fn set_h0d1(&mut self) -> &mut Self {
                *self = Self::H0D1;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SENSE_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Sense for high level
                        High = 2,
        // Sense for low level
                        Low = 3

                    );

        impl SENSE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_high(&self) -> bool {
                *self == Self::High
            }

            pub fn set_high(&mut self) -> &mut Self {
                *self = Self::High;
                self
            }

            pub fn is_low(&self) -> bool {
                *self == Self::Low
            }

            pub fn set_low(&mut self) -> &mut Self {
                *self = Self::Low;
                self
            }
        }
    }
}

pub mod p1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct P1 {
        _hidden: (),
    }

    impl P1 {
        const BASE_ADDRESS: u32 = 0x50000300;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for P1 {
        type Target = p0::P0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for P1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod radio {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct RADIO {
        _hidden: (),
    }

    impl RADIO {
        const BASE_ADDRESS: u32 = 0x40001000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for RADIO {
        type Target = RADIO_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for RADIO {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct RADIO_REGISTERS {
        _hidden: (),
        /// Enable RADIO in TX mode
        pub tasks_txen: TaskRegister,
        /// Enable RADIO in RX mode
        pub tasks_rxen: TaskRegister,
        /// Start RADIO
        pub tasks_start: TaskRegister,
        /// Stop RADIO
        pub tasks_stop: TaskRegister,
        /// Disable RADIO
        pub tasks_disable: TaskRegister,
        /// Start the RSSI and take one single sample of the receive signal
        /// strength
        pub tasks_rssistart: TaskRegister,
        /// Stop the RSSI measurement
        pub tasks_rssistop: TaskRegister,
        /// Start the bit counter
        pub tasks_bcstart: TaskRegister,
        /// Stop the bit counter
        pub tasks_bcstop: TaskRegister,
        /// Start the energy detect measurement used in IEEE 802.15.4 mode
        pub tasks_edstart: TaskRegister,
        /// Stop the energy detect measurement
        pub tasks_edstop: TaskRegister,
        /// Start the clear channel assessment used in IEEE 802.15.4 mode
        pub tasks_ccastart: TaskRegister,
        /// Stop the clear channel assessment
        pub tasks_ccastop: TaskRegister,
        _padding_52: [u8; 204],
        /// RADIO has ramped up and is ready to be started
        pub events_ready: EventRegister,
        /// Address sent or received
        pub events_address: EventRegister,
        /// Packet payload sent or received
        pub events_payload: EventRegister,
        /// Packet sent or received
        pub events_end: EventRegister,
        /// RADIO has been disabled
        pub events_disabled: EventRegister,
        /// A device address match occurred on the last received packet
        pub events_devmatch: EventRegister,
        /// No device address match occurred on the last received packet
        pub events_devmiss: EventRegister,
        /// Sampling of receive signal strength complete
        pub events_rssiend: EventRegister,
        _padding_288: [u8; 8],
        /// Bit counter reached bit count value
        pub events_bcmatch: EventRegister,
        _padding_300: [u8; 4],
        /// Packet received with CRC ok
        pub events_crcok: EventRegister,
        /// Packet received with CRC error
        pub events_crcerror: EventRegister,
        /// IEEE 802.15.4 length field received
        pub events_framestart: EventRegister,
        /// Sampling of energy detection complete. A new ED sample is ready for
        /// readout from the RADIO.EDSAMPLE register.
        pub events_edend: EventRegister,
        /// The sampling of energy detection has stopped
        pub events_edstopped: EventRegister,
        /// Wireless medium in idle - clear to send
        pub events_ccaidle: EventRegister,
        /// Wireless medium busy - do not send
        pub events_ccabusy: EventRegister,
        /// The CCA has stopped
        pub events_ccastopped: EventRegister,
        /// Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit
        /// to Ble_LR500Kbit.
        pub events_rateboost: EventRegister,
        /// RADIO has ramped up and is ready to be started TX path
        pub events_txready: EventRegister,
        /// RADIO has ramped up and is ready to be started RX path
        pub events_rxready: EventRegister,
        /// MAC header match found
        pub events_mhrmatch: EventRegister,
        _padding_352: [u8; 8],
        /// Preamble indicator
        pub events_sync: EventRegister,
        /// Generated when last bit is sent on air, or received from air
        pub events_phyend: EventRegister,
        /// CTE is present (early warning right after receiving CTEInfo byte)
        pub events_ctepresent: EventRegister,
        _padding_372: [u8; 140],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// CRC status
        pub crcstatus: crcstatus::CRCSTATUS,
        _padding_1028: [u8; 4],
        /// Received address
        pub rxmatch: rxmatch::RXMATCH,
        /// CRC field of previously received packet
        pub rxcrc: rxcrc::RXCRC,
        /// Device address match index
        pub dai: dai::DAI,
        /// Payload status
        pub pdustat: pdustat::PDUSTAT,
        _padding_1048: [u8; 52],
        /// CTEInfo parsed from received packet
        pub ctestatus: ctestatus::CTESTATUS,
        _padding_1104: [u8; 8],
        /// DFE status information
        pub dfestatus: dfestatus::DFESTATUS,
        _padding_1116: [u8; 168],
        /// Packet pointer
        pub packetptr: packetptr::PACKETPTR,
        /// Frequency
        pub frequency: frequency::FREQUENCY,
        /// Output power
        pub txpower: txpower::TXPOWER,
        /// Data rate and modulation
        pub mode: mode::MODE,
        /// Packet configuration register 0
        pub pcnf0: pcnf0::PCNF0,
        /// Packet configuration register 1
        pub pcnf1: pcnf1::PCNF1,
        /// Base address 0
        pub base0: base0::BASE0,
        /// Base address 1
        pub base1: base1::BASE1,
        /// Prefixes bytes for logical addresses 0-3
        pub prefix0: prefix0::PREFIX0,
        /// Prefixes bytes for logical addresses 4-7
        pub prefix1: prefix1::PREFIX1,
        /// Transmit address select
        pub txaddress: txaddress::TXADDRESS,
        /// Receive address select
        pub rxaddresses: rxaddresses::RXADDRESSES,
        /// CRC configuration
        pub crccnf: crccnf::CRCCNF,
        /// CRC polynomial
        pub crcpoly: crcpoly::CRCPOLY,
        /// CRC initial value
        pub crcinit: crcinit::CRCINIT,
        _padding_1344: [u8; 4],
        /// Interframe spacing in us
        pub tifs: tifs::TIFS,
        /// RSSI sample
        pub rssisample: rssisample::RSSISAMPLE,
        _padding_1356: [u8; 4],
        /// Current radio state
        pub state: state::STATE,
        /// Data whitening initial value
        pub datawhiteiv: datawhiteiv::DATAWHITEIV,
        _padding_1368: [u8; 8],
        /// Bit counter compare
        pub bcc: bcc::BCC,
        _padding_1380: [u8; 156],
        /// Description collection: Device address base segment n
        pub dab: [dab::DAB; 8],
        /// Description collection: Device address prefix n
        pub dap: [dap::DAP; 8],
        /// Device address match configuration
        pub dacnf: dacnf::DACNF,
        /// Search pattern configuration
        pub mhrmatchconf: mhrmatchconf::MHRMATCHCONF,
        /// Pattern mask
        pub mhrmatchmas: mhrmatchmas::MHRMATCHMAS,
        _padding_1612: [u8; 4],
        /// Radio mode configuration register 0
        pub modecnf0: modecnf0::MODECNF0,
        _padding_1620: [u8; 12],
        /// IEEE 802.15.4 start of frame delimiter
        pub sfd: sfd::SFD,
        /// IEEE 802.15.4 energy detect loop count
        pub edcnt: edcnt::EDCNT,
        /// IEEE 802.15.4 energy detect level
        pub edsample: edsample::EDSAMPLE,
        /// IEEE 802.15.4 clear channel assessment control
        pub ccactrl: ccactrl::CCACTRL,
        _padding_1648: [u8; 656],
        /// Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
        pub dfemode: dfemode::DFEMODE,
        /// Configuration for CTE inline mode
        pub cteinlineconf: cteinlineconf::CTEINLINECONF,
        _padding_2312: [u8; 8],
        /// Various configuration for Direction finding
        pub dfectrl1: dfectrl1::DFECTRL1,
        /// Start offset for Direction finding
        pub dfectrl2: dfectrl2::DFECTRL2,
        _padding_2328: [u8; 16],
        /// GPIO patterns to be used for each antenna
        pub switchpattern: switchpattern::SWITCHPATTERN,
        /// Clear the GPIO pattern array for antenna control
        pub clearpattern: clearpattern::CLEARPATTERN,
        pub psel: psel::PSEL,
        pub dfepacket: dfepacket::DFEPACKET,
        _padding_2396: [u8; 1696],
        /// Peripheral power control
        pub power: power::POWER,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready_start(&self) -> READY_START_FIELD {
                let raw = self.raw;
                READY_START_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready_start(&mut self, value: READY_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_start_with<F: Fn(&mut READY_START_FIELD) -> &mut READY_START_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_start();
                f(&mut value);
                self.set_ready_start(value)
            }

            pub fn end_disable(&self) -> END_DISABLE_FIELD {
                let raw = self.raw;
                END_DISABLE_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end_disable(&mut self, value: END_DISABLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_disable_with<F: Fn(&mut END_DISABLE_FIELD) -> &mut END_DISABLE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end_disable();
                f(&mut value);
                self.set_end_disable(value)
            }

            pub fn disabled_txen(&self) -> DISABLED_TXEN_FIELD {
                let raw = self.raw;
                DISABLED_TXEN_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_disabled_txen(&mut self, value: DISABLED_TXEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_disabled_txen_with<
                F: Fn(&mut DISABLED_TXEN_FIELD) -> &mut DISABLED_TXEN_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.disabled_txen();
                f(&mut value);
                self.set_disabled_txen(value)
            }

            pub fn disabled_rxen(&self) -> DISABLED_RXEN_FIELD {
                let raw = self.raw;
                DISABLED_RXEN_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_disabled_rxen(&mut self, value: DISABLED_RXEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_disabled_rxen_with<
                F: Fn(&mut DISABLED_RXEN_FIELD) -> &mut DISABLED_RXEN_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.disabled_rxen();
                f(&mut value);
                self.set_disabled_rxen(value)
            }

            pub fn address_rssistart(&self) -> ADDRESS_RSSISTART_FIELD {
                let raw = self.raw;
                ADDRESS_RSSISTART_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_address_rssistart(&mut self, value: ADDRESS_RSSISTART_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_address_rssistart_with<
                F: Fn(&mut ADDRESS_RSSISTART_FIELD) -> &mut ADDRESS_RSSISTART_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address_rssistart();
                f(&mut value);
                self.set_address_rssistart(value)
            }

            pub fn end_start(&self) -> END_START_FIELD {
                let raw = self.raw;
                END_START_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_end_start(&mut self, value: END_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_end_start_with<F: Fn(&mut END_START_FIELD) -> &mut END_START_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end_start();
                f(&mut value);
                self.set_end_start(value)
            }

            pub fn address_bcstart(&self) -> ADDRESS_BCSTART_FIELD {
                let raw = self.raw;
                ADDRESS_BCSTART_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_address_bcstart(&mut self, value: ADDRESS_BCSTART_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_address_bcstart_with<
                F: Fn(&mut ADDRESS_BCSTART_FIELD) -> &mut ADDRESS_BCSTART_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address_bcstart();
                f(&mut value);
                self.set_address_bcstart(value)
            }

            pub fn disabled_rssistop(&self) -> DISABLED_RSSISTOP_FIELD {
                let raw = self.raw;
                DISABLED_RSSISTOP_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_disabled_rssistop(&mut self, value: DISABLED_RSSISTOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_disabled_rssistop_with<
                F: Fn(&mut DISABLED_RSSISTOP_FIELD) -> &mut DISABLED_RSSISTOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.disabled_rssistop();
                f(&mut value);
                self.set_disabled_rssistop(value)
            }

            pub fn rxready_ccastart(&self) -> RXREADY_CCASTART_FIELD {
                let raw = self.raw;
                RXREADY_CCASTART_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_rxready_ccastart(&mut self, value: RXREADY_CCASTART_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_rxready_ccastart_with<
                F: Fn(&mut RXREADY_CCASTART_FIELD) -> &mut RXREADY_CCASTART_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxready_ccastart();
                f(&mut value);
                self.set_rxready_ccastart(value)
            }

            pub fn ccaidle_txen(&self) -> CCAIDLE_TXEN_FIELD {
                let raw = self.raw;
                CCAIDLE_TXEN_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ccaidle_txen(&mut self, value: CCAIDLE_TXEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ccaidle_txen_with<
                F: Fn(&mut CCAIDLE_TXEN_FIELD) -> &mut CCAIDLE_TXEN_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccaidle_txen();
                f(&mut value);
                self.set_ccaidle_txen(value)
            }

            pub fn ccabusy_disable(&self) -> CCABUSY_DISABLE_FIELD {
                let raw = self.raw;
                CCABUSY_DISABLE_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ccabusy_disable(&mut self, value: CCABUSY_DISABLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ccabusy_disable_with<
                F: Fn(&mut CCABUSY_DISABLE_FIELD) -> &mut CCABUSY_DISABLE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccabusy_disable();
                f(&mut value);
                self.set_ccabusy_disable(value)
            }

            pub fn framestart_bcstart(&self) -> FRAMESTART_BCSTART_FIELD {
                let raw = self.raw;
                FRAMESTART_BCSTART_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_framestart_bcstart(&mut self, value: FRAMESTART_BCSTART_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_framestart_bcstart_with<
                F: Fn(&mut FRAMESTART_BCSTART_FIELD) -> &mut FRAMESTART_BCSTART_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.framestart_bcstart();
                f(&mut value);
                self.set_framestart_bcstart(value)
            }

            pub fn ready_edstart(&self) -> READY_EDSTART_FIELD {
                let raw = self.raw;
                READY_EDSTART_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ready_edstart(&mut self, value: READY_EDSTART_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ready_edstart_with<
                F: Fn(&mut READY_EDSTART_FIELD) -> &mut READY_EDSTART_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_edstart();
                f(&mut value);
                self.set_ready_edstart(value)
            }

            pub fn edend_disable(&self) -> EDEND_DISABLE_FIELD {
                let raw = self.raw;
                EDEND_DISABLE_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_edend_disable(&mut self, value: EDEND_DISABLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_edend_disable_with<
                F: Fn(&mut EDEND_DISABLE_FIELD) -> &mut EDEND_DISABLE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edend_disable();
                f(&mut value);
                self.set_edend_disable(value)
            }

            pub fn ccaidle_stop(&self) -> CCAIDLE_STOP_FIELD {
                let raw = self.raw;
                CCAIDLE_STOP_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ccaidle_stop(&mut self, value: CCAIDLE_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ccaidle_stop_with<
                F: Fn(&mut CCAIDLE_STOP_FIELD) -> &mut CCAIDLE_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccaidle_stop();
                f(&mut value);
                self.set_ccaidle_stop(value)
            }

            pub fn txready_start(&self) -> TXREADY_START_FIELD {
                let raw = self.raw;
                TXREADY_START_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_txready_start(&mut self, value: TXREADY_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_txready_start_with<
                F: Fn(&mut TXREADY_START_FIELD) -> &mut TXREADY_START_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txready_start();
                f(&mut value);
                self.set_txready_start(value)
            }

            pub fn rxready_start(&self) -> RXREADY_START_FIELD {
                let raw = self.raw;
                RXREADY_START_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxready_start(&mut self, value: RXREADY_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxready_start_with<
                F: Fn(&mut RXREADY_START_FIELD) -> &mut RXREADY_START_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxready_start();
                f(&mut value);
                self.set_rxready_start(value)
            }

            pub fn phyend_disable(&self) -> PHYEND_DISABLE_FIELD {
                let raw = self.raw;
                PHYEND_DISABLE_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_phyend_disable(&mut self, value: PHYEND_DISABLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_phyend_disable_with<
                F: Fn(&mut PHYEND_DISABLE_FIELD) -> &mut PHYEND_DISABLE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.phyend_disable();
                f(&mut value);
                self.set_phyend_disable(value)
            }

            pub fn phyend_start(&self) -> PHYEND_START_FIELD {
                let raw = self.raw;
                PHYEND_START_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_phyend_start(&mut self, value: PHYEND_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_phyend_start_with<
                F: Fn(&mut PHYEND_START_FIELD) -> &mut PHYEND_START_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.phyend_start();
                f(&mut value);
                self.set_phyend_start(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] END_DISABLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl END_DISABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DISABLED_TXEN_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DISABLED_TXEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DISABLED_RXEN_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DISABLED_RXEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDRESS_RSSISTART_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ADDRESS_RSSISTART_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] END_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl END_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDRESS_BCSTART_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ADDRESS_BCSTART_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DISABLED_RSSISTOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DISABLED_RSSISTOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RXREADY_CCASTART_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl RXREADY_CCASTART_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CCAIDLE_TXEN_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CCAIDLE_TXEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CCABUSY_DISABLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CCABUSY_DISABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FRAMESTART_BCSTART_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl FRAMESTART_BCSTART_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_EDSTART_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_EDSTART_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EDEND_DISABLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl EDEND_DISABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CCAIDLE_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CCAIDLE_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TXREADY_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl TXREADY_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RXREADY_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl RXREADY_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PHYEND_DISABLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl PHYEND_DISABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PHYEND_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl PHYEND_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn address(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_address(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_address_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address();
                f(&mut value);
                self.set_address(value)
            }

            pub fn payload(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_payload(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_payload_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.payload();
                f(&mut value);
                self.set_payload(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn disabled(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_disabled(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_disabled_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.disabled();
                f(&mut value);
                self.set_disabled(value)
            }

            pub fn devmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_devmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_devmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.devmatch();
                f(&mut value);
                self.set_devmatch(value)
            }

            pub fn devmiss(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_devmiss(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_devmiss_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.devmiss();
                f(&mut value);
                self.set_devmiss(value)
            }

            pub fn rssiend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rssiend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rssiend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rssiend();
                f(&mut value);
                self.set_rssiend(value)
            }

            pub fn bcmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_bcmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_bcmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bcmatch();
                f(&mut value);
                self.set_bcmatch(value)
            }

            pub fn crcok(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_crcok(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_crcok_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.crcok();
                f(&mut value);
                self.set_crcok(value)
            }

            pub fn crcerror(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_crcerror(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_crcerror_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.crcerror();
                f(&mut value);
                self.set_crcerror(value)
            }

            pub fn framestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_framestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_framestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.framestart();
                f(&mut value);
                self.set_framestart(value)
            }

            pub fn edend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_edend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_edend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edend();
                f(&mut value);
                self.set_edend(value)
            }

            pub fn edstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_edstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_edstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edstopped();
                f(&mut value);
                self.set_edstopped(value)
            }

            pub fn ccaidle(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ccaidle(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ccaidle_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccaidle();
                f(&mut value);
                self.set_ccaidle(value)
            }

            pub fn ccabusy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ccabusy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ccabusy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccabusy();
                f(&mut value);
                self.set_ccabusy(value)
            }

            pub fn ccastopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ccastopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ccastopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccastopped();
                f(&mut value);
                self.set_ccastopped(value)
            }

            pub fn rateboost(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_rateboost(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_rateboost_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rateboost();
                f(&mut value);
                self.set_rateboost(value)
            }

            pub fn txready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_txready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_txready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txready();
                f(&mut value);
                self.set_txready(value)
            }

            pub fn rxready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_rxready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_rxready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxready();
                f(&mut value);
                self.set_rxready(value)
            }

            pub fn mhrmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_mhrmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_mhrmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mhrmatch();
                f(&mut value);
                self.set_mhrmatch(value)
            }

            pub fn sync(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_sync(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_sync_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sync();
                f(&mut value);
                self.set_sync(value)
            }

            pub fn phyend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_phyend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_phyend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.phyend();
                f(&mut value);
                self.set_phyend(value)
            }

            pub fn ctepresent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ctepresent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ctepresent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctepresent();
                f(&mut value);
                self.set_ctepresent(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_address(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_payload(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_devmatch(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_devmiss(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rssiend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_bcmatch(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_crcok(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_crcerror(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_framestart(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_edend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_edstopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ccaidle(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ccabusy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ccastopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rateboost(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_rxready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_mhrmatch(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_sync(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_phyend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ctepresent(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn address(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_address(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_address_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address();
                f(&mut value);
                self.set_address(value)
            }

            pub fn payload(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_payload(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_payload_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.payload();
                f(&mut value);
                self.set_payload(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn disabled(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_disabled(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_disabled_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.disabled();
                f(&mut value);
                self.set_disabled(value)
            }

            pub fn devmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_devmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_devmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.devmatch();
                f(&mut value);
                self.set_devmatch(value)
            }

            pub fn devmiss(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_devmiss(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_devmiss_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.devmiss();
                f(&mut value);
                self.set_devmiss(value)
            }

            pub fn rssiend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rssiend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rssiend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rssiend();
                f(&mut value);
                self.set_rssiend(value)
            }

            pub fn bcmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_bcmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_bcmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bcmatch();
                f(&mut value);
                self.set_bcmatch(value)
            }

            pub fn crcok(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_crcok(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_crcok_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.crcok();
                f(&mut value);
                self.set_crcok(value)
            }

            pub fn crcerror(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_crcerror(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_crcerror_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.crcerror();
                f(&mut value);
                self.set_crcerror(value)
            }

            pub fn framestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_framestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_framestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.framestart();
                f(&mut value);
                self.set_framestart(value)
            }

            pub fn edend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_edend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_edend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edend();
                f(&mut value);
                self.set_edend(value)
            }

            pub fn edstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_edstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_edstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edstopped();
                f(&mut value);
                self.set_edstopped(value)
            }

            pub fn ccaidle(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ccaidle(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ccaidle_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccaidle();
                f(&mut value);
                self.set_ccaidle(value)
            }

            pub fn ccabusy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ccabusy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ccabusy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccabusy();
                f(&mut value);
                self.set_ccabusy(value)
            }

            pub fn ccastopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ccastopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ccastopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccastopped();
                f(&mut value);
                self.set_ccastopped(value)
            }

            pub fn rateboost(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_rateboost(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_rateboost_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rateboost();
                f(&mut value);
                self.set_rateboost(value)
            }

            pub fn txready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_txready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_txready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txready();
                f(&mut value);
                self.set_txready(value)
            }

            pub fn rxready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_rxready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_rxready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxready();
                f(&mut value);
                self.set_rxready(value)
            }

            pub fn mhrmatch(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_mhrmatch(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_mhrmatch_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mhrmatch();
                f(&mut value);
                self.set_mhrmatch(value)
            }

            pub fn sync(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_sync(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_sync_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sync();
                f(&mut value);
                self.set_sync(value)
            }

            pub fn phyend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_phyend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_phyend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.phyend();
                f(&mut value);
                self.set_phyend(value)
            }

            pub fn ctepresent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ctepresent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ctepresent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctepresent();
                f(&mut value);
                self.set_ctepresent(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_address(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_payload(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_devmatch(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_devmiss(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rssiend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_bcmatch(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_crcok(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_crcerror(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_framestart(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_edend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_edstopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ccaidle(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ccabusy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ccastopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rateboost(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_rxready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_mhrmatch(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_sync(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_phyend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ctepresent(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }
        }
    }

    pub mod crcstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CRCSTATUS {
            raw: RawRegister<u32>,
        }

        impl CRCSTATUS {}

        impl RegisterRead for CRCSTATUS {
            type Value = CRCSTATUS_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                CRCSTATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CRCSTATUS_FIELD u32 =>
                        // Packet received with CRC error
                        CRCError = 0,
        // Packet received with CRC ok
                        CRCOk = 1

                    );

        impl CRCSTATUS_FIELD {
            pub fn is_crcerror(&self) -> bool {
                *self == Self::CRCError
            }

            pub fn set_crcerror(&mut self) -> &mut Self {
                *self = Self::CRCError;
                self
            }

            pub fn is_crcok(&self) -> bool {
                *self == Self::CRCOk
            }

            pub fn set_crcok(&mut self) -> &mut Self {
                *self = Self::CRCOk;
                self
            }
        }
    }

    pub mod rxmatch {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXMATCH {
            raw: RawRegister<u32>,
        }

        impl RXMATCH {}

        impl RegisterRead for RXMATCH {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000007) >> 0
            }
        }
    }

    pub mod rxcrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXCRC {
            raw: RawRegister<u32>,
        }

        impl RXCRC {}

        impl RegisterRead for RXCRC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00ffffff) >> 0
            }
        }
    }

    pub mod dai {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DAI {
            raw: RawRegister<u32>,
        }

        impl DAI {}

        impl RegisterRead for DAI {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000007) >> 0
            }
        }
    }

    pub mod pdustat {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PDUSTAT {
            raw: RawRegister<u32>,
        }

        impl PDUSTAT {}

        impl RegisterRead for PDUSTAT {
            type Value = PDUSTAT_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PDUSTAT_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PDUSTAT_READ_VALUE {
            raw: u32,
        }

        impl PDUSTAT_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pdustat(&self) -> PDUSTAT_FIELD {
                let raw = self.raw;
                PDUSTAT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_pdustat(&mut self, value: PDUSTAT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_pdustat_with<F: Fn(&mut PDUSTAT_FIELD) -> &mut PDUSTAT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pdustat();
                f(&mut value);
                self.set_pdustat(value)
            }

            pub fn cistat(&self) -> CISTAT_FIELD {
                let raw = self.raw;
                CISTAT_FIELD::from_value((raw & 0x00000006) >> 1)
            }

            pub fn set_cistat(&mut self, value: CISTAT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000006) | (value << 1);
                self
            }

            pub fn set_cistat_with<F: Fn(&mut CISTAT_FIELD) -> &mut CISTAT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cistat();
                f(&mut value);
                self.set_cistat(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PDUSTAT_FIELD u32 =>
                        // Payload less than PCNF1.MAXLEN
                        LessThan = 0,
        // Payload greater than PCNF1.MAXLEN
                        GreaterThan = 1

                    );

        impl PDUSTAT_FIELD {
            pub fn is_lessthan(&self) -> bool {
                *self == Self::LessThan
            }

            pub fn set_lessthan(&mut self) -> &mut Self {
                *self = Self::LessThan;
                self
            }

            pub fn is_greaterthan(&self) -> bool {
                *self == Self::GreaterThan
            }

            pub fn set_greaterthan(&mut self) -> &mut Self {
                *self = Self::GreaterThan;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CISTAT_FIELD u32 =>
                        // Frame is received at 125 kbps
                        LR125kbit = 0,
        // Frame is received at 500 kbps
                        LR500kbit = 1

                    );

        impl CISTAT_FIELD {
            pub fn is_lr125kbit(&self) -> bool {
                *self == Self::LR125kbit
            }

            pub fn set_lr125kbit(&mut self) -> &mut Self {
                *self = Self::LR125kbit;
                self
            }

            pub fn is_lr500kbit(&self) -> bool {
                *self == Self::LR500kbit
            }

            pub fn set_lr500kbit(&mut self) -> &mut Self {
                *self = Self::LR500kbit;
                self
            }
        }
    }

    pub mod ctestatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CTESTATUS {
            raw: RawRegister<u32>,
        }

        impl CTESTATUS {}

        impl RegisterRead for CTESTATUS {
            type Value = CTESTATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CTESTATUS_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CTESTATUS_READ_VALUE {
            raw: u32,
        }

        impl CTESTATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ctetime(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000001f) >> 0
            }

            pub fn set_ctetime(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn rfu(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000020) >> 5
            }

            pub fn set_rfu(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn ctetype(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000c0) >> 6
            }

            pub fn set_ctetype(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000c0) | (value << 6);
                self
            }
        }
    }

    pub mod dfestatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DFESTATUS {
            raw: RawRegister<u32>,
        }

        impl DFESTATUS {}

        impl RegisterRead for DFESTATUS {
            type Value = DFESTATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DFESTATUS_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DFESTATUS_READ_VALUE {
            raw: u32,
        }

        impl DFESTATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn switchingstate(&self) -> SWITCHINGSTATE_FIELD {
                let raw = self.raw;
                SWITCHINGSTATE_FIELD::from_value((raw & 0x00000007) >> 0)
            }

            pub fn set_switchingstate(&mut self, value: SWITCHINGSTATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn set_switchingstate_with<
                F: Fn(&mut SWITCHINGSTATE_FIELD) -> &mut SWITCHINGSTATE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.switchingstate();
                f(&mut value);
                self.set_switchingstate(value)
            }

            pub fn samplingstate(&self) -> SAMPLINGSTATE_FIELD {
                let raw = self.raw;
                SAMPLINGSTATE_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_samplingstate(&mut self, value: SAMPLINGSTATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_samplingstate_with<
                F: Fn(&mut SAMPLINGSTATE_FIELD) -> &mut SAMPLINGSTATE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.samplingstate();
                f(&mut value);
                self.set_samplingstate(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SWITCHINGSTATE_FIELD u32 =>
                        // Switching state Idle
                        Idle = 0,
        // Switching state Offset
                        Offset = 1,
        // Switching state Guard
                        Guard = 2,
        // Switching state Ref
                        Ref = 3,
        // Switching state Switching
                        Switching = 4,
        // Switching state Ending
                        Ending = 5

                    );

        impl SWITCHINGSTATE_FIELD {
            pub fn is_idle(&self) -> bool {
                *self == Self::Idle
            }

            pub fn set_idle(&mut self) -> &mut Self {
                *self = Self::Idle;
                self
            }

            pub fn is_offset(&self) -> bool {
                *self == Self::Offset
            }

            pub fn set_offset(&mut self) -> &mut Self {
                *self = Self::Offset;
                self
            }

            pub fn is_guard(&self) -> bool {
                *self == Self::Guard
            }

            pub fn set_guard(&mut self) -> &mut Self {
                *self = Self::Guard;
                self
            }

            pub fn is_ref(&self) -> bool {
                *self == Self::Ref
            }

            pub fn set_ref(&mut self) -> &mut Self {
                *self = Self::Ref;
                self
            }

            pub fn is_switching(&self) -> bool {
                *self == Self::Switching
            }

            pub fn set_switching(&mut self) -> &mut Self {
                *self = Self::Switching;
                self
            }

            pub fn is_ending(&self) -> bool {
                *self == Self::Ending
            }

            pub fn set_ending(&mut self) -> &mut Self {
                *self = Self::Ending;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SAMPLINGSTATE_FIELD u32 =>
                        // Sampling state Idle
                        Idle = 0,
        // Sampling state Sampling
                        Sampling = 1

                    );

        impl SAMPLINGSTATE_FIELD {
            pub fn is_idle(&self) -> bool {
                *self == Self::Idle
            }

            pub fn set_idle(&mut self) -> &mut Self {
                *self = Self::Idle;
                self
            }

            pub fn is_sampling(&self) -> bool {
                *self == Self::Sampling
            }

            pub fn set_sampling(&mut self) -> &mut Self {
                *self = Self::Sampling;
                self
            }
        }
    }

    pub mod packetptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PACKETPTR {
            raw: RawRegister<u32>,
        }

        impl PACKETPTR {}

        impl RegisterRead for PACKETPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for PACKETPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FREQUENCY {
            raw: RawRegister<u32>,
        }

        impl FREQUENCY {
            pub fn write_with<F: Fn(&mut FREQUENCY_VALUE) -> &mut FREQUENCY_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = FREQUENCY_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for FREQUENCY {
            type Value = FREQUENCY_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                FREQUENCY_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for FREQUENCY {
            type Value = FREQUENCY_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct FREQUENCY_VALUE {
            raw: u32,
        }

        impl FREQUENCY_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn frequency(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000007f) >> 0
            }

            pub fn set_frequency(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000007f) | (value << 0);
                self
            }

            pub fn map(&self) -> MAP_FIELD {
                let raw = self.raw;
                MAP_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_map(&mut self, value: MAP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_map_with<F: Fn(&mut MAP_FIELD) -> &mut MAP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.map();
                f(&mut value);
                self.set_map(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MAP_FIELD u32 =>
                        // Channel map between 2400 MHZ .. 2500 MHz
                        Default = 0,
        // Channel map between 2360 MHZ .. 2460 MHz
                        Low = 1

                    );

        impl MAP_FIELD {
            pub fn is_default(&self) -> bool {
                *self == Self::Default
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::Default;
                self
            }

            pub fn is_low(&self) -> bool {
                *self == Self::Low
            }

            pub fn set_low(&mut self) -> &mut Self {
                *self = Self::Low;
                self
            }
        }
    }

    pub mod txpower {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TXPOWER {
            raw: RawRegister<u32>,
        }

        impl TXPOWER {
            pub fn write_pos8dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos8dBm)
            }

            pub fn write_pos7dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos7dBm)
            }

            pub fn write_pos6dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos6dBm)
            }

            pub fn write_pos5dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos5dBm)
            }

            pub fn write_pos4dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos4dBm)
            }

            pub fn write_pos3dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos3dBm)
            }

            pub fn write_pos2dbm(&mut self) {
                self.write(TXPOWER_FIELD::Pos2dBm)
            }

            pub fn write_0dbm(&mut self) {
                self.write(TXPOWER_FIELD::_0dBm)
            }

            pub fn write_neg4dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg4dBm)
            }

            pub fn write_neg8dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg8dBm)
            }

            pub fn write_neg12dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg12dBm)
            }

            pub fn write_neg16dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg16dBm)
            }

            pub fn write_neg20dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg20dBm)
            }

            pub fn write_neg30dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg30dBm)
            }

            pub fn write_neg40dbm(&mut self) {
                self.write(TXPOWER_FIELD::Neg40dBm)
            }
        }

        impl RegisterRead for TXPOWER {
            type Value = TXPOWER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                TXPOWER_FIELD::from_value((raw & 0x000000ff) >> 0)
            }
        }

        impl RegisterWrite for TXPOWER {
            type Value = TXPOWER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TXPOWER_FIELD u32 =>
                        // +8 dBm
                        Pos8dBm = 8,
        // +7 dBm
                        Pos7dBm = 7,
        // +6 dBm
                        Pos6dBm = 6,
        // +5 dBm
                        Pos5dBm = 5,
        // +4 dBm
                        Pos4dBm = 4,
        // +3 dBm
                        Pos3dBm = 3,
        // +2 dBm
                        Pos2dBm = 2,
        // 0 dBm
                        _0dBm = 0,
        // -4 dBm
                        Neg4dBm = 252,
        // -8 dBm
                        Neg8dBm = 248,
        // -12 dBm
                        Neg12dBm = 244,
        // -16 dBm
                        Neg16dBm = 240,
        // -20 dBm
                        Neg20dBm = 236,
        // Deprecated enumerator -  -40 dBm
                        Neg30dBm = 226,
        // -40 dBm
                        Neg40dBm = 216

                    );

        impl TXPOWER_FIELD {
            pub fn is_pos8dbm(&self) -> bool {
                *self == Self::Pos8dBm
            }

            pub fn set_pos8dbm(&mut self) -> &mut Self {
                *self = Self::Pos8dBm;
                self
            }

            pub fn is_pos7dbm(&self) -> bool {
                *self == Self::Pos7dBm
            }

            pub fn set_pos7dbm(&mut self) -> &mut Self {
                *self = Self::Pos7dBm;
                self
            }

            pub fn is_pos6dbm(&self) -> bool {
                *self == Self::Pos6dBm
            }

            pub fn set_pos6dbm(&mut self) -> &mut Self {
                *self = Self::Pos6dBm;
                self
            }

            pub fn is_pos5dbm(&self) -> bool {
                *self == Self::Pos5dBm
            }

            pub fn set_pos5dbm(&mut self) -> &mut Self {
                *self = Self::Pos5dBm;
                self
            }

            pub fn is_pos4dbm(&self) -> bool {
                *self == Self::Pos4dBm
            }

            pub fn set_pos4dbm(&mut self) -> &mut Self {
                *self = Self::Pos4dBm;
                self
            }

            pub fn is_pos3dbm(&self) -> bool {
                *self == Self::Pos3dBm
            }

            pub fn set_pos3dbm(&mut self) -> &mut Self {
                *self = Self::Pos3dBm;
                self
            }

            pub fn is_pos2dbm(&self) -> bool {
                *self == Self::Pos2dBm
            }

            pub fn set_pos2dbm(&mut self) -> &mut Self {
                *self = Self::Pos2dBm;
                self
            }

            pub fn is_0dbm(&self) -> bool {
                *self == Self::_0dBm
            }

            pub fn set_0dbm(&mut self) -> &mut Self {
                *self = Self::_0dBm;
                self
            }

            pub fn is_neg4dbm(&self) -> bool {
                *self == Self::Neg4dBm
            }

            pub fn set_neg4dbm(&mut self) -> &mut Self {
                *self = Self::Neg4dBm;
                self
            }

            pub fn is_neg8dbm(&self) -> bool {
                *self == Self::Neg8dBm
            }

            pub fn set_neg8dbm(&mut self) -> &mut Self {
                *self = Self::Neg8dBm;
                self
            }

            pub fn is_neg12dbm(&self) -> bool {
                *self == Self::Neg12dBm
            }

            pub fn set_neg12dbm(&mut self) -> &mut Self {
                *self = Self::Neg12dBm;
                self
            }

            pub fn is_neg16dbm(&self) -> bool {
                *self == Self::Neg16dBm
            }

            pub fn set_neg16dbm(&mut self) -> &mut Self {
                *self = Self::Neg16dBm;
                self
            }

            pub fn is_neg20dbm(&self) -> bool {
                *self == Self::Neg20dBm
            }

            pub fn set_neg20dbm(&mut self) -> &mut Self {
                *self = Self::Neg20dBm;
                self
            }

            pub fn is_neg30dbm(&self) -> bool {
                *self == Self::Neg30dBm
            }

            pub fn set_neg30dbm(&mut self) -> &mut Self {
                *self = Self::Neg30dBm;
                self
            }

            pub fn is_neg40dbm(&self) -> bool {
                *self == Self::Neg40dBm
            }

            pub fn set_neg40dbm(&mut self) -> &mut Self {
                *self = Self::Neg40dBm;
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_nrf_1mbit(&mut self) {
                self.write(MODE_FIELD::Nrf_1Mbit)
            }

            pub fn write_nrf_2mbit(&mut self) {
                self.write(MODE_FIELD::Nrf_2Mbit)
            }

            pub fn write_ble_1mbit(&mut self) {
                self.write(MODE_FIELD::Ble_1Mbit)
            }

            pub fn write_ble_2mbit(&mut self) {
                self.write(MODE_FIELD::Ble_2Mbit)
            }

            pub fn write_ble_lr125kbit(&mut self) {
                self.write(MODE_FIELD::Ble_LR125Kbit)
            }

            pub fn write_ble_lr500kbit(&mut self) {
                self.write(MODE_FIELD::Ble_LR500Kbit)
            }

            pub fn write_ieee802154_250kbit(&mut self) {
                self.write(MODE_FIELD::Ieee802154_250Kbit)
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                MODE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // 1 Mbps Nordic proprietary radio mode
                        Nrf_1Mbit = 0,
        // 2 Mbps Nordic proprietary radio mode
                        Nrf_2Mbit = 1,
        // 1 Mbps BLE
                        Ble_1Mbit = 3,
        // 2 Mbps BLE
                        Ble_2Mbit = 4,
        // Long range 125 kbps TX, 125 kbps and 500 kbps RX
                        Ble_LR125Kbit = 5,
        // Long range 500 kbps TX, 125 kbps and 500 kbps RX
                        Ble_LR500Kbit = 6,
        // IEEE 802.15.4-2006 250 kbps
                        Ieee802154_250Kbit = 15

                    );

        impl MODE_FIELD {
            pub fn is_nrf_1mbit(&self) -> bool {
                *self == Self::Nrf_1Mbit
            }

            pub fn set_nrf_1mbit(&mut self) -> &mut Self {
                *self = Self::Nrf_1Mbit;
                self
            }

            pub fn is_nrf_2mbit(&self) -> bool {
                *self == Self::Nrf_2Mbit
            }

            pub fn set_nrf_2mbit(&mut self) -> &mut Self {
                *self = Self::Nrf_2Mbit;
                self
            }

            pub fn is_ble_1mbit(&self) -> bool {
                *self == Self::Ble_1Mbit
            }

            pub fn set_ble_1mbit(&mut self) -> &mut Self {
                *self = Self::Ble_1Mbit;
                self
            }

            pub fn is_ble_2mbit(&self) -> bool {
                *self == Self::Ble_2Mbit
            }

            pub fn set_ble_2mbit(&mut self) -> &mut Self {
                *self = Self::Ble_2Mbit;
                self
            }

            pub fn is_ble_lr125kbit(&self) -> bool {
                *self == Self::Ble_LR125Kbit
            }

            pub fn set_ble_lr125kbit(&mut self) -> &mut Self {
                *self = Self::Ble_LR125Kbit;
                self
            }

            pub fn is_ble_lr500kbit(&self) -> bool {
                *self == Self::Ble_LR500Kbit
            }

            pub fn set_ble_lr500kbit(&mut self) -> &mut Self {
                *self = Self::Ble_LR500Kbit;
                self
            }

            pub fn is_ieee802154_250kbit(&self) -> bool {
                *self == Self::Ieee802154_250Kbit
            }

            pub fn set_ieee802154_250kbit(&mut self) -> &mut Self {
                *self = Self::Ieee802154_250Kbit;
                self
            }
        }
    }

    pub mod pcnf0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PCNF0 {
            raw: RawRegister<u32>,
        }

        impl PCNF0 {
            pub fn write_with<F: Fn(&mut PCNF0_VALUE) -> &mut PCNF0_VALUE>(&mut self, f: F) {
                let mut v = PCNF0_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PCNF0 {
            type Value = PCNF0_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PCNF0_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PCNF0 {
            type Value = PCNF0_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PCNF0_VALUE {
            raw: u32,
        }

        impl PCNF0_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn lflen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000000f) >> 0
            }

            pub fn set_lflen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000000f) | (value << 0);
                self
            }

            pub fn s0len(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000100) >> 8
            }

            pub fn set_s0len(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn s1len(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000f0000) >> 16
            }

            pub fn set_s1len(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000f0000) | (value << 16);
                self
            }

            pub fn s1incl(&self) -> S1INCL_FIELD {
                let raw = self.raw;
                S1INCL_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_s1incl(&mut self, value: S1INCL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_s1incl_with<F: Fn(&mut S1INCL_FIELD) -> &mut S1INCL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.s1incl();
                f(&mut value);
                self.set_s1incl(value)
            }

            pub fn cilen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00c00000) >> 22
            }

            pub fn set_cilen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00c00000) | (value << 22);
                self
            }

            pub fn plen(&self) -> PLEN_FIELD {
                let raw = self.raw;
                PLEN_FIELD::from_value((raw & 0x03000000) >> 24)
            }

            pub fn set_plen(&mut self, value: PLEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x03000000) | (value << 24);
                self
            }

            pub fn set_plen_with<F: Fn(&mut PLEN_FIELD) -> &mut PLEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.plen();
                f(&mut value);
                self.set_plen(value)
            }

            pub fn crcinc(&self) -> CRCINC_FIELD {
                let raw = self.raw;
                CRCINC_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_crcinc(&mut self, value: CRCINC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_crcinc_with<F: Fn(&mut CRCINC_FIELD) -> &mut CRCINC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.crcinc();
                f(&mut value);
                self.set_crcinc(value)
            }

            pub fn termlen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x60000000) >> 29
            }

            pub fn set_termlen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x60000000) | (value << 29);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] S1INCL_FIELD u32 =>
                        // Include S1 field in RAM only if S1LEN &gt; 0
                        Automatic = 0,
        // Always include S1 field in RAM independent of S1LEN
                        Include = 1

                    );

        impl S1INCL_FIELD {
            pub fn is_automatic(&self) -> bool {
                *self == Self::Automatic
            }

            pub fn set_automatic(&mut self) -> &mut Self {
                *self = Self::Automatic;
                self
            }

            pub fn is_include(&self) -> bool {
                *self == Self::Include
            }

            pub fn set_include(&mut self) -> &mut Self {
                *self = Self::Include;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PLEN_FIELD u32 =>
                        // 8-bit preamble
                        _8bit = 0,
        // 16-bit preamble
                        _16bit = 1,
        // 32-bit zero preamble - used for IEEE 802.15.4
                        _32bitZero = 2,
        // Preamble - used for BLE long range
                        LongRange = 3

                    );

        impl PLEN_FIELD {
            pub fn is_8bit(&self) -> bool {
                *self == Self::_8bit
            }

            pub fn set_8bit(&mut self) -> &mut Self {
                *self = Self::_8bit;
                self
            }

            pub fn is_16bit(&self) -> bool {
                *self == Self::_16bit
            }

            pub fn set_16bit(&mut self) -> &mut Self {
                *self = Self::_16bit;
                self
            }

            pub fn is_32bitzero(&self) -> bool {
                *self == Self::_32bitZero
            }

            pub fn set_32bitzero(&mut self) -> &mut Self {
                *self = Self::_32bitZero;
                self
            }

            pub fn is_longrange(&self) -> bool {
                *self == Self::LongRange
            }

            pub fn set_longrange(&mut self) -> &mut Self {
                *self = Self::LongRange;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CRCINC_FIELD u32 =>
                        // LENGTH does not contain CRC
                        Exclude = 0,
        // LENGTH includes CRC
                        Include = 1

                    );

        impl CRCINC_FIELD {
            pub fn is_exclude(&self) -> bool {
                *self == Self::Exclude
            }

            pub fn set_exclude(&mut self) -> &mut Self {
                *self = Self::Exclude;
                self
            }

            pub fn is_include(&self) -> bool {
                *self == Self::Include
            }

            pub fn set_include(&mut self) -> &mut Self {
                *self = Self::Include;
                self
            }
        }
    }

    pub mod pcnf1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PCNF1 {
            raw: RawRegister<u32>,
        }

        impl PCNF1 {
            pub fn write_with<F: Fn(&mut PCNF1_VALUE) -> &mut PCNF1_VALUE>(&mut self, f: F) {
                let mut v = PCNF1_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PCNF1 {
            type Value = PCNF1_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PCNF1_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PCNF1 {
            type Value = PCNF1_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PCNF1_VALUE {
            raw: u32,
        }

        impl PCNF1_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn maxlen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_maxlen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn statlen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_statlen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn balen(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00070000) >> 16
            }

            pub fn set_balen(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00070000) | (value << 16);
                self
            }

            pub fn endian(&self) -> ENDIAN_FIELD {
                let raw = self.raw;
                ENDIAN_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_endian(&mut self, value: ENDIAN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_endian_with<F: Fn(&mut ENDIAN_FIELD) -> &mut ENDIAN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endian();
                f(&mut value);
                self.set_endian(value)
            }

            pub fn whiteen(&self) -> WHITEEN_FIELD {
                let raw = self.raw;
                WHITEEN_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_whiteen(&mut self, value: WHITEEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_whiteen_with<F: Fn(&mut WHITEEN_FIELD) -> &mut WHITEEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.whiteen();
                f(&mut value);
                self.set_whiteen(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDIAN_FIELD u32 =>
                        // Least significant bit on air first
                        Little = 0,
        // Most significant bit on air first
                        Big = 1

                    );

        impl ENDIAN_FIELD {
            pub fn is_little(&self) -> bool {
                *self == Self::Little
            }

            pub fn set_little(&mut self) -> &mut Self {
                *self = Self::Little;
                self
            }

            pub fn is_big(&self) -> bool {
                *self == Self::Big
            }

            pub fn set_big(&mut self) -> &mut Self {
                *self = Self::Big;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] WHITEEN_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl WHITEEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod base0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BASE0 {
            raw: RawRegister<u32>,
        }

        impl BASE0 {}

        impl RegisterRead for BASE0 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for BASE0 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod base1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BASE1 {
            raw: RawRegister<u32>,
        }

        impl BASE1 {}

        impl RegisterRead for BASE1 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for BASE1 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod prefix0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PREFIX0 {
            raw: RawRegister<u32>,
        }

        impl PREFIX0 {
            pub fn write_with<F: Fn(&mut PREFIX0_VALUE) -> &mut PREFIX0_VALUE>(&mut self, f: F) {
                let mut v = PREFIX0_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PREFIX0 {
            type Value = PREFIX0_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PREFIX0_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PREFIX0 {
            type Value = PREFIX0_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PREFIX0_VALUE {
            raw: u32,
        }

        impl PREFIX0_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ap0(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_ap0(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn ap1(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_ap1(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn ap2(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_ap2(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }

            pub fn ap3(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xff000000) >> 24
            }

            pub fn set_ap3(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xff000000) | (value << 24);
                self
            }
        }
    }

    pub mod prefix1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PREFIX1 {
            raw: RawRegister<u32>,
        }

        impl PREFIX1 {
            pub fn write_with<F: Fn(&mut PREFIX1_VALUE) -> &mut PREFIX1_VALUE>(&mut self, f: F) {
                let mut v = PREFIX1_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PREFIX1 {
            type Value = PREFIX1_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PREFIX1_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PREFIX1 {
            type Value = PREFIX1_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PREFIX1_VALUE {
            raw: u32,
        }

        impl PREFIX1_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ap4(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_ap4(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn ap5(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_ap5(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn ap6(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_ap6(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }

            pub fn ap7(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xff000000) >> 24
            }

            pub fn set_ap7(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xff000000) | (value << 24);
                self
            }
        }
    }

    pub mod txaddress {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TXADDRESS {
            raw: RawRegister<u32>,
        }

        impl TXADDRESS {}

        impl RegisterRead for TXADDRESS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000007) >> 0
            }
        }

        impl RegisterWrite for TXADDRESS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000007) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod rxaddresses {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXADDRESSES {
            raw: RawRegister<u32>,
        }

        impl RXADDRESSES {
            pub fn write_with<F: Fn(&mut RXADDRESSES_VALUE) -> &mut RXADDRESSES_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = RXADDRESSES_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for RXADDRESSES {
            type Value = RXADDRESSES_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                RXADDRESSES_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for RXADDRESSES {
            type Value = RXADDRESSES_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct RXADDRESSES_VALUE {
            raw: u32,
        }

        impl RXADDRESSES_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn addr0(&self) -> ADDR0_FIELD {
                let raw = self.raw;
                ADDR0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_addr0(&mut self, value: ADDR0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_addr0_with<F: Fn(&mut ADDR0_FIELD) -> &mut ADDR0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr0();
                f(&mut value);
                self.set_addr0(value)
            }

            pub fn addr1(&self) -> ADDR1_FIELD {
                let raw = self.raw;
                ADDR1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_addr1(&mut self, value: ADDR1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_addr1_with<F: Fn(&mut ADDR1_FIELD) -> &mut ADDR1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr1();
                f(&mut value);
                self.set_addr1(value)
            }

            pub fn addr2(&self) -> ADDR2_FIELD {
                let raw = self.raw;
                ADDR2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_addr2(&mut self, value: ADDR2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_addr2_with<F: Fn(&mut ADDR2_FIELD) -> &mut ADDR2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr2();
                f(&mut value);
                self.set_addr2(value)
            }

            pub fn addr3(&self) -> ADDR3_FIELD {
                let raw = self.raw;
                ADDR3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_addr3(&mut self, value: ADDR3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_addr3_with<F: Fn(&mut ADDR3_FIELD) -> &mut ADDR3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr3();
                f(&mut value);
                self.set_addr3(value)
            }

            pub fn addr4(&self) -> ADDR4_FIELD {
                let raw = self.raw;
                ADDR4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_addr4(&mut self, value: ADDR4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_addr4_with<F: Fn(&mut ADDR4_FIELD) -> &mut ADDR4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr4();
                f(&mut value);
                self.set_addr4(value)
            }

            pub fn addr5(&self) -> ADDR5_FIELD {
                let raw = self.raw;
                ADDR5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_addr5(&mut self, value: ADDR5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_addr5_with<F: Fn(&mut ADDR5_FIELD) -> &mut ADDR5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr5();
                f(&mut value);
                self.set_addr5(value)
            }

            pub fn addr6(&self) -> ADDR6_FIELD {
                let raw = self.raw;
                ADDR6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_addr6(&mut self, value: ADDR6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_addr6_with<F: Fn(&mut ADDR6_FIELD) -> &mut ADDR6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr6();
                f(&mut value);
                self.set_addr6(value)
            }

            pub fn addr7(&self) -> ADDR7_FIELD {
                let raw = self.raw;
                ADDR7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_addr7(&mut self, value: ADDR7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_addr7_with<F: Fn(&mut ADDR7_FIELD) -> &mut ADDR7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.addr7();
                f(&mut value);
                self.set_addr7(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR0_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR1_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR2_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR2_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR3_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR3_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR4_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR4_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR5_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR5_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR6_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR6_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDR7_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ADDR7_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod crccnf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CRCCNF {
            raw: RawRegister<u32>,
        }

        impl CRCCNF {
            pub fn write_with<F: Fn(&mut CRCCNF_VALUE) -> &mut CRCCNF_VALUE>(&mut self, f: F) {
                let mut v = CRCCNF_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CRCCNF {
            type Value = CRCCNF_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CRCCNF_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CRCCNF {
            type Value = CRCCNF_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CRCCNF_VALUE {
            raw: u32,
        }

        impl CRCCNF_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn len(&self) -> LEN_FIELD {
                let raw = self.raw;
                LEN_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_len(&mut self, value: LEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_len_with<F: Fn(&mut LEN_FIELD) -> &mut LEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.len();
                f(&mut value);
                self.set_len(value)
            }

            pub fn skipaddr(&self) -> SKIPADDR_FIELD {
                let raw = self.raw;
                SKIPADDR_FIELD::from_value((raw & 0x00000300) >> 8)
            }

            pub fn set_skipaddr(&mut self, value: SKIPADDR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000300) | (value << 8);
                self
            }

            pub fn set_skipaddr_with<F: Fn(&mut SKIPADDR_FIELD) -> &mut SKIPADDR_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.skipaddr();
                f(&mut value);
                self.set_skipaddr(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LEN_FIELD u32 =>
                        // CRC length is zero and CRC calculation is disabled
                        Disabled = 0,
        // CRC length is one byte and CRC calculation is enabled
                        One = 1,
        // CRC length is two bytes and CRC calculation is enabled
                        Two = 2,
        // CRC length is three bytes and CRC calculation is enabled
                        Three = 3

                    );

        impl LEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_one(&self) -> bool {
                *self == Self::One
            }

            pub fn set_one(&mut self) -> &mut Self {
                *self = Self::One;
                self
            }

            pub fn is_two(&self) -> bool {
                *self == Self::Two
            }

            pub fn set_two(&mut self) -> &mut Self {
                *self = Self::Two;
                self
            }

            pub fn is_three(&self) -> bool {
                *self == Self::Three
            }

            pub fn set_three(&mut self) -> &mut Self {
                *self = Self::Three;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SKIPADDR_FIELD u32 =>
                        // CRC calculation includes address field
                        Include = 0,
        // CRC calculation does not include address field. The CRC calculation will start at the first byte after the address.
                        Skip = 1,
        // CRC calculation as per 802.15.4 standard. Starting at first byte after length field.
                        Ieee802154 = 2

                    );

        impl SKIPADDR_FIELD {
            pub fn is_include(&self) -> bool {
                *self == Self::Include
            }

            pub fn set_include(&mut self) -> &mut Self {
                *self = Self::Include;
                self
            }

            pub fn is_skip(&self) -> bool {
                *self == Self::Skip
            }

            pub fn set_skip(&mut self) -> &mut Self {
                *self = Self::Skip;
                self
            }

            pub fn is_ieee802154(&self) -> bool {
                *self == Self::Ieee802154
            }

            pub fn set_ieee802154(&mut self) -> &mut Self {
                *self = Self::Ieee802154;
                self
            }
        }
    }

    pub mod crcpoly {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CRCPOLY {
            raw: RawRegister<u32>,
        }

        impl CRCPOLY {}

        impl RegisterRead for CRCPOLY {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00ffffff) >> 0
            }
        }

        impl RegisterWrite for CRCPOLY {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00ffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod crcinit {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CRCINIT {
            raw: RawRegister<u32>,
        }

        impl CRCINIT {}

        impl RegisterRead for CRCINIT {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00ffffff) >> 0
            }
        }

        impl RegisterWrite for CRCINIT {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00ffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod tifs {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TIFS {
            raw: RawRegister<u32>,
        }

        impl TIFS {}

        impl RegisterRead for TIFS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000003ff) >> 0
            }
        }

        impl RegisterWrite for TIFS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000003ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod rssisample {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RSSISAMPLE {
            raw: RawRegister<u32>,
        }

        impl RSSISAMPLE {}

        impl RegisterRead for RSSISAMPLE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }
    }

    pub mod state {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct STATE {
            raw: RawRegister<u32>,
        }

        impl STATE {}

        impl RegisterRead for STATE {
            type Value = STATE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                STATE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATE_FIELD u32 =>
                        // RADIO is in the Disabled state
                        Disabled = 0,
        // RADIO is in the RXRU state
                        RxRu = 1,
        // RADIO is in the RXIDLE state
                        RxIdle = 2,
        // RADIO is in the RX state
                        Rx = 3,
        // RADIO is in the RXDISABLED state
                        RxDisable = 4,
        // RADIO is in the TXRU state
                        TxRu = 9,
        // RADIO is in the TXIDLE state
                        TxIdle = 10,
        // RADIO is in the TX state
                        Tx = 11,
        // RADIO is in the TXDISABLED state
                        TxDisable = 12

                    );

        impl STATE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_rxru(&self) -> bool {
                *self == Self::RxRu
            }

            pub fn set_rxru(&mut self) -> &mut Self {
                *self = Self::RxRu;
                self
            }

            pub fn is_rxidle(&self) -> bool {
                *self == Self::RxIdle
            }

            pub fn set_rxidle(&mut self) -> &mut Self {
                *self = Self::RxIdle;
                self
            }

            pub fn is_rx(&self) -> bool {
                *self == Self::Rx
            }

            pub fn set_rx(&mut self) -> &mut Self {
                *self = Self::Rx;
                self
            }

            pub fn is_rxdisable(&self) -> bool {
                *self == Self::RxDisable
            }

            pub fn set_rxdisable(&mut self) -> &mut Self {
                *self = Self::RxDisable;
                self
            }

            pub fn is_txru(&self) -> bool {
                *self == Self::TxRu
            }

            pub fn set_txru(&mut self) -> &mut Self {
                *self = Self::TxRu;
                self
            }

            pub fn is_txidle(&self) -> bool {
                *self == Self::TxIdle
            }

            pub fn set_txidle(&mut self) -> &mut Self {
                *self = Self::TxIdle;
                self
            }

            pub fn is_tx(&self) -> bool {
                *self == Self::Tx
            }

            pub fn set_tx(&mut self) -> &mut Self {
                *self = Self::Tx;
                self
            }

            pub fn is_txdisable(&self) -> bool {
                *self == Self::TxDisable
            }

            pub fn set_txdisable(&mut self) -> &mut Self {
                *self = Self::TxDisable;
                self
            }
        }
    }

    pub mod datawhiteiv {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DATAWHITEIV {
            raw: RawRegister<u32>,
        }

        impl DATAWHITEIV {}

        impl RegisterRead for DATAWHITEIV {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }

        impl RegisterWrite for DATAWHITEIV {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000007f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod bcc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BCC {
            raw: RawRegister<u32>,
        }

        impl BCC {}

        impl RegisterRead for BCC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for BCC {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod dab {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DAB {
            raw: RawRegister<u32>,
        }

        impl DAB {}

        impl RegisterRead for DAB {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for DAB {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod dap {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DAP {
            raw: RawRegister<u32>,
        }

        impl DAP {}

        impl RegisterRead for DAP {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000ffff) >> 0
            }
        }

        impl RegisterWrite for DAP {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000ffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod dacnf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DACNF {
            raw: RawRegister<u32>,
        }

        impl DACNF {
            pub fn write_with<F: Fn(&mut DACNF_VALUE) -> &mut DACNF_VALUE>(&mut self, f: F) {
                let mut v = DACNF_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DACNF {
            type Value = DACNF_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DACNF_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DACNF {
            type Value = DACNF_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DACNF_VALUE {
            raw: u32,
        }

        impl DACNF_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ena0(&self) -> ENA0_FIELD {
                let raw = self.raw;
                ENA0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ena0(&mut self, value: ENA0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ena0_with<F: Fn(&mut ENA0_FIELD) -> &mut ENA0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena0();
                f(&mut value);
                self.set_ena0(value)
            }

            pub fn ena1(&self) -> ENA1_FIELD {
                let raw = self.raw;
                ENA1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ena1(&mut self, value: ENA1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ena1_with<F: Fn(&mut ENA1_FIELD) -> &mut ENA1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena1();
                f(&mut value);
                self.set_ena1(value)
            }

            pub fn ena2(&self) -> ENA2_FIELD {
                let raw = self.raw;
                ENA2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ena2(&mut self, value: ENA2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ena2_with<F: Fn(&mut ENA2_FIELD) -> &mut ENA2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena2();
                f(&mut value);
                self.set_ena2(value)
            }

            pub fn ena3(&self) -> ENA3_FIELD {
                let raw = self.raw;
                ENA3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ena3(&mut self, value: ENA3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ena3_with<F: Fn(&mut ENA3_FIELD) -> &mut ENA3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena3();
                f(&mut value);
                self.set_ena3(value)
            }

            pub fn ena4(&self) -> ENA4_FIELD {
                let raw = self.raw;
                ENA4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ena4(&mut self, value: ENA4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ena4_with<F: Fn(&mut ENA4_FIELD) -> &mut ENA4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena4();
                f(&mut value);
                self.set_ena4(value)
            }

            pub fn ena5(&self) -> ENA5_FIELD {
                let raw = self.raw;
                ENA5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_ena5(&mut self, value: ENA5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ena5_with<F: Fn(&mut ENA5_FIELD) -> &mut ENA5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena5();
                f(&mut value);
                self.set_ena5(value)
            }

            pub fn ena6(&self) -> ENA6_FIELD {
                let raw = self.raw;
                ENA6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ena6(&mut self, value: ENA6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ena6_with<F: Fn(&mut ENA6_FIELD) -> &mut ENA6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena6();
                f(&mut value);
                self.set_ena6(value)
            }

            pub fn ena7(&self) -> ENA7_FIELD {
                let raw = self.raw;
                ENA7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ena7(&mut self, value: ENA7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ena7_with<F: Fn(&mut ENA7_FIELD) -> &mut ENA7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ena7();
                f(&mut value);
                self.set_ena7(value)
            }

            pub fn txadd0(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000100) >> 8
            }

            pub fn set_txadd0(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn txadd1(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000200) >> 9
            }

            pub fn set_txadd1(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn txadd2(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000400) >> 10
            }

            pub fn set_txadd2(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn txadd3(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000800) >> 11
            }

            pub fn set_txadd3(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn txadd4(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00001000) >> 12
            }

            pub fn set_txadd4(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn txadd5(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00002000) >> 13
            }

            pub fn set_txadd5(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn txadd6(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00004000) >> 14
            }

            pub fn set_txadd6(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn txadd7(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00008000) >> 15
            }

            pub fn set_txadd7(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA0_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA1_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA2_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA2_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA3_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA3_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA4_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA4_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA5_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA5_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA6_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA6_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENA7_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ENA7_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod mhrmatchconf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MHRMATCHCONF {
            raw: RawRegister<u32>,
        }

        impl MHRMATCHCONF {}

        impl RegisterRead for MHRMATCHCONF {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for MHRMATCHCONF {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod mhrmatchmas {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MHRMATCHMAS {
            raw: RawRegister<u32>,
        }

        impl MHRMATCHMAS {}

        impl RegisterRead for MHRMATCHMAS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for MHRMATCHMAS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod modecnf0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODECNF0 {
            raw: RawRegister<u32>,
        }

        impl MODECNF0 {
            pub fn write_with<F: Fn(&mut MODECNF0_VALUE) -> &mut MODECNF0_VALUE>(&mut self, f: F) {
                let mut v = MODECNF0_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODECNF0 {
            type Value = MODECNF0_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODECNF0_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODECNF0 {
            type Value = MODECNF0_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODECNF0_VALUE {
            raw: u32,
        }

        impl MODECNF0_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ru(&self) -> RU_FIELD {
                let raw = self.raw;
                RU_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ru(&mut self, value: RU_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ru_with<F: Fn(&mut RU_FIELD) -> &mut RU_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ru();
                f(&mut value);
                self.set_ru(value)
            }

            pub fn dtx(&self) -> DTX_FIELD {
                let raw = self.raw;
                DTX_FIELD::from_value((raw & 0x00000300) >> 8)
            }

            pub fn set_dtx(&mut self, value: DTX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000300) | (value << 8);
                self
            }

            pub fn set_dtx_with<F: Fn(&mut DTX_FIELD) -> &mut DTX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dtx();
                f(&mut value);
                self.set_dtx(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RU_FIELD u32 =>
                        // Default ramp-up time (tRXEN and tTXEN), compatible with firmware written for nRF51
                        Default = 0,
        // Fast ramp-up (tRXEN,FAST and tTXEN,FAST), see electrical specifications for more information
                        Fast = 1

                    );

        impl RU_FIELD {
            pub fn is_default(&self) -> bool {
                *self == Self::Default
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::Default;
                self
            }

            pub fn is_fast(&self) -> bool {
                *self == Self::Fast
            }

            pub fn set_fast(&mut self) -> &mut Self {
                *self = Self::Fast;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DTX_FIELD u32 =>
                        // Transmit '1'
                        B1 = 0,
        // Transmit '0'
                        B0 = 1,
        // Transmit center frequency
                        Center = 2

                    );

        impl DTX_FIELD {
            pub fn is_b1(&self) -> bool {
                *self == Self::B1
            }

            pub fn set_b1(&mut self) -> &mut Self {
                *self = Self::B1;
                self
            }

            pub fn is_b0(&self) -> bool {
                *self == Self::B0
            }

            pub fn set_b0(&mut self) -> &mut Self {
                *self = Self::B0;
                self
            }

            pub fn is_center(&self) -> bool {
                *self == Self::Center
            }

            pub fn set_center(&mut self) -> &mut Self {
                *self = Self::Center;
                self
            }
        }
    }

    pub mod sfd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SFD {
            raw: RawRegister<u32>,
        }

        impl SFD {}

        impl RegisterRead for SFD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for SFD {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod edcnt {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EDCNT {
            raw: RawRegister<u32>,
        }

        impl EDCNT {}

        impl RegisterRead for EDCNT {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x001fffff) >> 0
            }
        }

        impl RegisterWrite for EDCNT {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x001fffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod edsample {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EDSAMPLE {
            raw: RawRegister<u32>,
        }

        impl EDSAMPLE {}

        impl RegisterRead for EDSAMPLE {
            type Value = EDSAMPLE_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EDSAMPLE_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EDSAMPLE_READ_VALUE {
            raw: u32,
        }

        impl EDSAMPLE_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn edlvl(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_edlvl(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }
        }
    }

    pub mod ccactrl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CCACTRL {
            raw: RawRegister<u32>,
        }

        impl CCACTRL {
            pub fn write_with<F: Fn(&mut CCACTRL_VALUE) -> &mut CCACTRL_VALUE>(&mut self, f: F) {
                let mut v = CCACTRL_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CCACTRL {
            type Value = CCACTRL_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CCACTRL_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CCACTRL {
            type Value = CCACTRL_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CCACTRL_VALUE {
            raw: u32,
        }

        impl CCACTRL_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ccamode(&self) -> CCAMODE_FIELD {
                let raw = self.raw;
                CCAMODE_FIELD::from_value((raw & 0x00000007) >> 0)
            }

            pub fn set_ccamode(&mut self, value: CCAMODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn set_ccamode_with<F: Fn(&mut CCAMODE_FIELD) -> &mut CCAMODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ccamode();
                f(&mut value);
                self.set_ccamode(value)
            }

            pub fn ccaedthres(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_ccaedthres(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn ccacorrthres(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_ccacorrthres(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }

            pub fn ccacorrcnt(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xff000000) >> 24
            }

            pub fn set_ccacorrcnt(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xff000000) | (value << 24);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CCAMODE_FIELD u32 =>
                        // Energy above threshold
                        EdMode = 0,
        // Carrier seen
                        CarrierMode = 1,
        // Energy above threshold AND carrier seen
                        CarrierAndEdMode = 2,
        // Energy above threshold OR carrier seen
                        CarrierOrEdMode = 3,
        // Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging.
                        EdModeTest1 = 4

                    );

        impl CCAMODE_FIELD {
            pub fn is_edmode(&self) -> bool {
                *self == Self::EdMode
            }

            pub fn set_edmode(&mut self) -> &mut Self {
                *self = Self::EdMode;
                self
            }

            pub fn is_carriermode(&self) -> bool {
                *self == Self::CarrierMode
            }

            pub fn set_carriermode(&mut self) -> &mut Self {
                *self = Self::CarrierMode;
                self
            }

            pub fn is_carrierandedmode(&self) -> bool {
                *self == Self::CarrierAndEdMode
            }

            pub fn set_carrierandedmode(&mut self) -> &mut Self {
                *self = Self::CarrierAndEdMode;
                self
            }

            pub fn is_carrieroredmode(&self) -> bool {
                *self == Self::CarrierOrEdMode
            }

            pub fn set_carrieroredmode(&mut self) -> &mut Self {
                *self = Self::CarrierOrEdMode;
                self
            }

            pub fn is_edmodetest1(&self) -> bool {
                *self == Self::EdModeTest1
            }

            pub fn set_edmodetest1(&mut self) -> &mut Self {
                *self = Self::EdModeTest1;
                self
            }
        }
    }

    pub mod dfemode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DFEMODE {
            raw: RawRegister<u32>,
        }

        impl DFEMODE {
            pub fn write_with<F: Fn(&mut DFEMODE_VALUE) -> &mut DFEMODE_VALUE>(&mut self, f: F) {
                let mut v = DFEMODE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DFEMODE {
            type Value = DFEMODE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DFEMODE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DFEMODE {
            type Value = DFEMODE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DFEMODE_VALUE {
            raw: u32,
        }

        impl DFEMODE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn dfeopmode(&self) -> DFEOPMODE_FIELD {
                let raw = self.raw;
                DFEOPMODE_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_dfeopmode(&mut self, value: DFEOPMODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_dfeopmode_with<F: Fn(&mut DFEOPMODE_FIELD) -> &mut DFEOPMODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dfeopmode();
                f(&mut value);
                self.set_dfeopmode(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DFEOPMODE_FIELD u32 =>
                        // Direction finding mode disabled
                        Disabled = 0,
        // Direction finding mode set to AoD
                        AoD = 2,
        // Direction finding mode set to AoA
                        AoA = 3

                    );

        impl DFEOPMODE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_aod(&self) -> bool {
                *self == Self::AoD
            }

            pub fn set_aod(&mut self) -> &mut Self {
                *self = Self::AoD;
                self
            }

            pub fn is_aoa(&self) -> bool {
                *self == Self::AoA
            }

            pub fn set_aoa(&mut self) -> &mut Self {
                *self = Self::AoA;
                self
            }
        }
    }

    pub mod cteinlineconf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CTEINLINECONF {
            raw: RawRegister<u32>,
        }

        impl CTEINLINECONF {
            pub fn write_with<F: Fn(&mut CTEINLINECONF_VALUE) -> &mut CTEINLINECONF_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = CTEINLINECONF_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CTEINLINECONF {
            type Value = CTEINLINECONF_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CTEINLINECONF_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CTEINLINECONF {
            type Value = CTEINLINECONF_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CTEINLINECONF_VALUE {
            raw: u32,
        }

        impl CTEINLINECONF_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cteinlinectrlen(&self) -> CTEINLINECTRLEN_FIELD {
                let raw = self.raw;
                CTEINLINECTRLEN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cteinlinectrlen(&mut self, value: CTEINLINECTRLEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cteinlinectrlen_with<
                F: Fn(&mut CTEINLINECTRLEN_FIELD) -> &mut CTEINLINECTRLEN_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cteinlinectrlen();
                f(&mut value);
                self.set_cteinlinectrlen(value)
            }

            pub fn cteinfoins1(&self) -> CTEINFOINS1_FIELD {
                let raw = self.raw;
                CTEINFOINS1_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cteinfoins1(&mut self, value: CTEINFOINS1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cteinfoins1_with<F: Fn(&mut CTEINFOINS1_FIELD) -> &mut CTEINFOINS1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cteinfoins1();
                f(&mut value);
                self.set_cteinfoins1(value)
            }

            pub fn cteerrorhandling(&self) -> CTEERRORHANDLING_FIELD {
                let raw = self.raw;
                CTEERRORHANDLING_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_cteerrorhandling(&mut self, value: CTEERRORHANDLING_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_cteerrorhandling_with<
                F: Fn(&mut CTEERRORHANDLING_FIELD) -> &mut CTEERRORHANDLING_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cteerrorhandling();
                f(&mut value);
                self.set_cteerrorhandling(value)
            }

            pub fn ctetimevalidrange(&self) -> CTETIMEVALIDRANGE_FIELD {
                let raw = self.raw;
                CTETIMEVALIDRANGE_FIELD::from_value((raw & 0x000000c0) >> 6)
            }

            pub fn set_ctetimevalidrange(&mut self, value: CTETIMEVALIDRANGE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000c0) | (value << 6);
                self
            }

            pub fn set_ctetimevalidrange_with<
                F: Fn(&mut CTETIMEVALIDRANGE_FIELD) -> &mut CTETIMEVALIDRANGE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ctetimevalidrange();
                f(&mut value);
                self.set_ctetimevalidrange(value)
            }

            pub fn cteinlinerxmode1us(&self) -> CTEINLINERXMODE1US_FIELD {
                let raw = self.raw;
                CTEINLINERXMODE1US_FIELD::from_value((raw & 0x00001c00) >> 10)
            }

            pub fn set_cteinlinerxmode1us(&mut self, value: CTEINLINERXMODE1US_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001c00) | (value << 10);
                self
            }

            pub fn set_cteinlinerxmode1us_with<
                F: Fn(&mut CTEINLINERXMODE1US_FIELD) -> &mut CTEINLINERXMODE1US_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cteinlinerxmode1us();
                f(&mut value);
                self.set_cteinlinerxmode1us(value)
            }

            pub fn cteinlinerxmode2us(&self) -> CTEINLINERXMODE2US_FIELD {
                let raw = self.raw;
                CTEINLINERXMODE2US_FIELD::from_value((raw & 0x0000e000) >> 13)
            }

            pub fn set_cteinlinerxmode2us(&mut self, value: CTEINLINERXMODE2US_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000e000) | (value << 13);
                self
            }

            pub fn set_cteinlinerxmode2us_with<
                F: Fn(&mut CTEINLINERXMODE2US_FIELD) -> &mut CTEINLINERXMODE2US_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cteinlinerxmode2us();
                f(&mut value);
                self.set_cteinlinerxmode2us(value)
            }

            pub fn s0conf(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_s0conf(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }

            pub fn s0mask(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xff000000) >> 24
            }

            pub fn set_s0mask(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xff000000) | (value << 24);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTEINLINECTRLEN_FIELD u32 =>
                        // Parsing of CTEInfo is enabled
                        Enabled = 1,
        // Parsing of CTEInfo is disabled
                        Disabled = 0

                    );

        impl CTEINLINECTRLEN_FIELD {
            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }

            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTEINFOINS1_FIELD u32 =>
                        // CTEInfo is in S1 byte (data PDU)
                        InS1 = 1,
        // CTEInfo is NOT in S1 byte (advertising PDU)
                        NotInS1 = 0

                    );

        impl CTEINFOINS1_FIELD {
            pub fn is_ins1(&self) -> bool {
                *self == Self::InS1
            }

            pub fn set_ins1(&mut self) -> &mut Self {
                *self = Self::InS1;
                self
            }

            pub fn is_notins1(&self) -> bool {
                *self == Self::NotInS1
            }

            pub fn set_notins1(&mut self) -> &mut Self {
                *self = Self::NotInS1;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTEERRORHANDLING_FIELD u32 =>
                        // Sampling and antenna switching also when CRC is not OK
                        Yes = 1,
        // No sampling and antenna switching when CRC is not OK
                        No = 0

                    );

        impl CTEERRORHANDLING_FIELD {
            pub fn is_yes(&self) -> bool {
                *self == Self::Yes
            }

            pub fn set_yes(&mut self) -> &mut Self {
                *self = Self::Yes;
                self
            }

            pub fn is_no(&self) -> bool {
                *self == Self::No
            }

            pub fn set_no(&mut self) -> &mut Self {
                *self = Self::No;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTETIMEVALIDRANGE_FIELD u32 =>
                        // 20 in 8 us unit (default) Set to 20 if parsed CTETime is larger than 20
                        _20 = 0,
        // 31 in 8 us unit
                        _31 = 1,
        // 63 in 8 us unit
                        _63 = 2

                    );

        impl CTETIMEVALIDRANGE_FIELD {
            pub fn is_20(&self) -> bool {
                *self == Self::_20
            }

            pub fn set_20(&mut self) -> &mut Self {
                *self = Self::_20;
                self
            }

            pub fn is_31(&self) -> bool {
                *self == Self::_31
            }

            pub fn set_31(&mut self) -> &mut Self {
                *self = Self::_31;
                self
            }

            pub fn is_63(&self) -> bool {
                *self == Self::_63
            }

            pub fn set_63(&mut self) -> &mut Self {
                *self = Self::_63;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTEINLINERXMODE1US_FIELD u32 =>
                        // 4 us
                        _4us = 1,
        // 2 us
                        _2us = 2,
        // 1 us
                        _1us = 3,
        // 0.5 us
                        _500ns = 4,
        // 0.25 us
                        _250ns = 5,
        // 0.125 us
                        _125ns = 6

                    );

        impl CTEINLINERXMODE1US_FIELD {
            pub fn is_4us(&self) -> bool {
                *self == Self::_4us
            }

            pub fn set_4us(&mut self) -> &mut Self {
                *self = Self::_4us;
                self
            }

            pub fn is_2us(&self) -> bool {
                *self == Self::_2us
            }

            pub fn set_2us(&mut self) -> &mut Self {
                *self = Self::_2us;
                self
            }

            pub fn is_1us(&self) -> bool {
                *self == Self::_1us
            }

            pub fn set_1us(&mut self) -> &mut Self {
                *self = Self::_1us;
                self
            }

            pub fn is_500ns(&self) -> bool {
                *self == Self::_500ns
            }

            pub fn set_500ns(&mut self) -> &mut Self {
                *self = Self::_500ns;
                self
            }

            pub fn is_250ns(&self) -> bool {
                *self == Self::_250ns
            }

            pub fn set_250ns(&mut self) -> &mut Self {
                *self = Self::_250ns;
                self
            }

            pub fn is_125ns(&self) -> bool {
                *self == Self::_125ns
            }

            pub fn set_125ns(&mut self) -> &mut Self {
                *self = Self::_125ns;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTEINLINERXMODE2US_FIELD u32 =>
                        // 4 us
                        _4us = 1,
        // 2 us
                        _2us = 2,
        // 1 us
                        _1us = 3,
        // 0.5 us
                        _500ns = 4,
        // 0.25 us
                        _250ns = 5,
        // 0.125 us
                        _125ns = 6

                    );

        impl CTEINLINERXMODE2US_FIELD {
            pub fn is_4us(&self) -> bool {
                *self == Self::_4us
            }

            pub fn set_4us(&mut self) -> &mut Self {
                *self = Self::_4us;
                self
            }

            pub fn is_2us(&self) -> bool {
                *self == Self::_2us
            }

            pub fn set_2us(&mut self) -> &mut Self {
                *self = Self::_2us;
                self
            }

            pub fn is_1us(&self) -> bool {
                *self == Self::_1us
            }

            pub fn set_1us(&mut self) -> &mut Self {
                *self = Self::_1us;
                self
            }

            pub fn is_500ns(&self) -> bool {
                *self == Self::_500ns
            }

            pub fn set_500ns(&mut self) -> &mut Self {
                *self = Self::_500ns;
                self
            }

            pub fn is_250ns(&self) -> bool {
                *self == Self::_250ns
            }

            pub fn set_250ns(&mut self) -> &mut Self {
                *self = Self::_250ns;
                self
            }

            pub fn is_125ns(&self) -> bool {
                *self == Self::_125ns
            }

            pub fn set_125ns(&mut self) -> &mut Self {
                *self = Self::_125ns;
                self
            }
        }
    }

    pub mod dfectrl1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DFECTRL1 {
            raw: RawRegister<u32>,
        }

        impl DFECTRL1 {
            pub fn write_with<F: Fn(&mut DFECTRL1_VALUE) -> &mut DFECTRL1_VALUE>(&mut self, f: F) {
                let mut v = DFECTRL1_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DFECTRL1 {
            type Value = DFECTRL1_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DFECTRL1_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DFECTRL1 {
            type Value = DFECTRL1_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DFECTRL1_VALUE {
            raw: u32,
        }

        impl DFECTRL1_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn numberof8us(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000003f) >> 0
            }

            pub fn set_numberof8us(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000003f) | (value << 0);
                self
            }

            pub fn dfeinextension(&self) -> DFEINEXTENSION_FIELD {
                let raw = self.raw;
                DFEINEXTENSION_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_dfeinextension(&mut self, value: DFEINEXTENSION_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_dfeinextension_with<
                F: Fn(&mut DFEINEXTENSION_FIELD) -> &mut DFEINEXTENSION_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dfeinextension();
                f(&mut value);
                self.set_dfeinextension(value)
            }

            pub fn tswitchspacing(&self) -> TSWITCHSPACING_FIELD {
                let raw = self.raw;
                TSWITCHSPACING_FIELD::from_value((raw & 0x00000700) >> 8)
            }

            pub fn set_tswitchspacing(&mut self, value: TSWITCHSPACING_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000700) | (value << 8);
                self
            }

            pub fn set_tswitchspacing_with<
                F: Fn(&mut TSWITCHSPACING_FIELD) -> &mut TSWITCHSPACING_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tswitchspacing();
                f(&mut value);
                self.set_tswitchspacing(value)
            }

            pub fn tsamplespacingref(&self) -> TSAMPLESPACINGREF_FIELD {
                let raw = self.raw;
                TSAMPLESPACINGREF_FIELD::from_value((raw & 0x00007000) >> 12)
            }

            pub fn set_tsamplespacingref(&mut self, value: TSAMPLESPACINGREF_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00007000) | (value << 12);
                self
            }

            pub fn set_tsamplespacingref_with<
                F: Fn(&mut TSAMPLESPACINGREF_FIELD) -> &mut TSAMPLESPACINGREF_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tsamplespacingref();
                f(&mut value);
                self.set_tsamplespacingref(value)
            }

            pub fn sampletype(&self) -> SAMPLETYPE_FIELD {
                let raw = self.raw;
                SAMPLETYPE_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_sampletype(&mut self, value: SAMPLETYPE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_sampletype_with<F: Fn(&mut SAMPLETYPE_FIELD) -> &mut SAMPLETYPE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sampletype();
                f(&mut value);
                self.set_sampletype(value)
            }

            pub fn tsamplespacing(&self) -> TSAMPLESPACING_FIELD {
                let raw = self.raw;
                TSAMPLESPACING_FIELD::from_value((raw & 0x00070000) >> 16)
            }

            pub fn set_tsamplespacing(&mut self, value: TSAMPLESPACING_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00070000) | (value << 16);
                self
            }

            pub fn set_tsamplespacing_with<
                F: Fn(&mut TSAMPLESPACING_FIELD) -> &mut TSAMPLESPACING_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tsamplespacing();
                f(&mut value);
                self.set_tsamplespacing(value)
            }

            pub fn set_repeatpattern(&mut self) -> &mut Self {
                let value = REPEATPATTERN_FIELD::NoRepeat.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00f00000) | (value << 20);
                self
            }

            pub fn agcbackoffgain(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0f000000) >> 24
            }

            pub fn set_agcbackoffgain(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0f000000) | (value << 24);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DFEINEXTENSION_FIELD u32 =>
                        // AoA/AoD procedure triggered at end of CRC
                        CRC = 1,
        // Antenna switching/sampling is done in the packet payload
                        Payload = 0

                    );

        impl DFEINEXTENSION_FIELD {
            pub fn is_crc(&self) -> bool {
                *self == Self::CRC
            }

            pub fn set_crc(&mut self) -> &mut Self {
                *self = Self::CRC;
                self
            }

            pub fn is_payload(&self) -> bool {
                *self == Self::Payload
            }

            pub fn set_payload(&mut self) -> &mut Self {
                *self = Self::Payload;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TSWITCHSPACING_FIELD u32 =>
                        // 4 us
                        _4us = 1,
        // 2 us
                        _2us = 2,
        // 1 us
                        _1us = 3

                    );

        impl TSWITCHSPACING_FIELD {
            pub fn is_4us(&self) -> bool {
                *self == Self::_4us
            }

            pub fn set_4us(&mut self) -> &mut Self {
                *self = Self::_4us;
                self
            }

            pub fn is_2us(&self) -> bool {
                *self == Self::_2us
            }

            pub fn set_2us(&mut self) -> &mut Self {
                *self = Self::_2us;
                self
            }

            pub fn is_1us(&self) -> bool {
                *self == Self::_1us
            }

            pub fn set_1us(&mut self) -> &mut Self {
                *self = Self::_1us;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TSAMPLESPACINGREF_FIELD u32 =>
                        // 4 us
                        _4us = 1,
        // 2 us
                        _2us = 2,
        // 1 us
                        _1us = 3,
        // 0.5 us
                        _500ns = 4,
        // 0.25 us
                        _250ns = 5,
        // 0.125 us
                        _125ns = 6

                    );

        impl TSAMPLESPACINGREF_FIELD {
            pub fn is_4us(&self) -> bool {
                *self == Self::_4us
            }

            pub fn set_4us(&mut self) -> &mut Self {
                *self = Self::_4us;
                self
            }

            pub fn is_2us(&self) -> bool {
                *self == Self::_2us
            }

            pub fn set_2us(&mut self) -> &mut Self {
                *self = Self::_2us;
                self
            }

            pub fn is_1us(&self) -> bool {
                *self == Self::_1us
            }

            pub fn set_1us(&mut self) -> &mut Self {
                *self = Self::_1us;
                self
            }

            pub fn is_500ns(&self) -> bool {
                *self == Self::_500ns
            }

            pub fn set_500ns(&mut self) -> &mut Self {
                *self = Self::_500ns;
                self
            }

            pub fn is_250ns(&self) -> bool {
                *self == Self::_250ns
            }

            pub fn set_250ns(&mut self) -> &mut Self {
                *self = Self::_250ns;
                self
            }

            pub fn is_125ns(&self) -> bool {
                *self == Self::_125ns
            }

            pub fn set_125ns(&mut self) -> &mut Self {
                *self = Self::_125ns;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SAMPLETYPE_FIELD u32 =>
                        // Complex samples in I and Q
                        IQ = 0,
        // Complex samples as magnitude and phase
                        MagPhase = 1

                    );

        impl SAMPLETYPE_FIELD {
            pub fn is_iq(&self) -> bool {
                *self == Self::IQ
            }

            pub fn set_iq(&mut self) -> &mut Self {
                *self = Self::IQ;
                self
            }

            pub fn is_magphase(&self) -> bool {
                *self == Self::MagPhase
            }

            pub fn set_magphase(&mut self) -> &mut Self {
                *self = Self::MagPhase;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TSAMPLESPACING_FIELD u32 =>
                        // 4 us
                        _4us = 1,
        // 2 us
                        _2us = 2,
        // 1 us
                        _1us = 3,
        // 0.5 us
                        _500ns = 4,
        // 0.25 us
                        _250ns = 5,
        // 0.125 us
                        _125ns = 6

                    );

        impl TSAMPLESPACING_FIELD {
            pub fn is_4us(&self) -> bool {
                *self == Self::_4us
            }

            pub fn set_4us(&mut self) -> &mut Self {
                *self = Self::_4us;
                self
            }

            pub fn is_2us(&self) -> bool {
                *self == Self::_2us
            }

            pub fn set_2us(&mut self) -> &mut Self {
                *self = Self::_2us;
                self
            }

            pub fn is_1us(&self) -> bool {
                *self == Self::_1us
            }

            pub fn set_1us(&mut self) -> &mut Self {
                *self = Self::_1us;
                self
            }

            pub fn is_500ns(&self) -> bool {
                *self == Self::_500ns
            }

            pub fn set_500ns(&mut self) -> &mut Self {
                *self = Self::_500ns;
                self
            }

            pub fn is_250ns(&self) -> bool {
                *self == Self::_250ns
            }

            pub fn set_250ns(&mut self) -> &mut Self {
                *self = Self::_250ns;
                self
            }

            pub fn is_125ns(&self) -> bool {
                *self == Self::_125ns
            }

            pub fn set_125ns(&mut self) -> &mut Self {
                *self = Self::_125ns;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REPEATPATTERN_FIELD u32 =>
            // Do not repeat (1 time in total)
            NoRepeat = 0

        );

        impl REPEATPATTERN_FIELD {
            pub fn is_norepeat(&self) -> bool {
                *self == Self::NoRepeat
            }

            pub fn set_norepeat(&mut self) -> &mut Self {
                *self = Self::NoRepeat;
                self
            }
        }
    }

    pub mod dfectrl2 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DFECTRL2 {
            raw: RawRegister<u32>,
        }

        impl DFECTRL2 {
            pub fn write_with<F: Fn(&mut DFECTRL2_VALUE) -> &mut DFECTRL2_VALUE>(&mut self, f: F) {
                let mut v = DFECTRL2_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DFECTRL2 {
            type Value = DFECTRL2_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DFECTRL2_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DFECTRL2 {
            type Value = DFECTRL2_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DFECTRL2_VALUE {
            raw: u32,
        }

        impl DFECTRL2_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tswitchoffset(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00001fff) >> 0
            }

            pub fn set_tswitchoffset(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001fff) | (value << 0);
                self
            }

            pub fn tsampleoffset(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0fff0000) >> 16
            }

            pub fn set_tsampleoffset(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0fff0000) | (value << 16);
                self
            }
        }
    }

    pub mod switchpattern {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SWITCHPATTERN {
            raw: RawRegister<u32>,
        }

        impl SWITCHPATTERN {}

        impl RegisterRead for SWITCHPATTERN {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for SWITCHPATTERN {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod clearpattern {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CLEARPATTERN {
            raw: RawRegister<u32>,
        }

        impl CLEARPATTERN {
            pub fn write_clear(&mut self) {
                self.write(CLEARPATTERN_FIELD::Clear)
            }
        }

        impl RegisterRead for CLEARPATTERN {
            type Value = CLEARPATTERN_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                CLEARPATTERN_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for CLEARPATTERN {
            type Value = CLEARPATTERN_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CLEARPATTERN_FIELD u32 =>
            // Clear the GPIO pattern
            Clear = 1

        );

        impl CLEARPATTERN_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description collection: Pin select for DFE pin n
            pub dfegpio: [PinSelectRegister; 8],
        }
    }

    pub mod dfepacket {
        #[allow(unused_imports)]
        use super::*;

        /// DFE packet EasyDMA channel
        #[repr(C)]
        pub struct DFEPACKET {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of buffer words to transfer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of samples transferred in the last transaction
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x00003fff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x00003fff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }
    }

    pub mod power {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct POWER {
            raw: RawRegister<u32>,
        }

        impl POWER {
            pub fn write_disabled(&mut self) {
                self.write(POWER_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(POWER_FIELD::Enabled)
            }
        }

        impl RegisterRead for POWER {
            type Value = POWER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                POWER_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for POWER {
            type Value = POWER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] POWER_FIELD u32 =>
                        // Peripheral is powered off
                        Disabled = 0,
        // Peripheral is powered on
                        Enabled = 1

                    );

        impl POWER_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }
}

pub mod uart0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct UART0 {
        _hidden: (),
    }

    impl UART0 {
        const BASE_ADDRESS: u32 = 0x40002000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for UART0 {
        type Target = UART0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for UART0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct UART0_REGISTERS {
        _hidden: (),
        /// Start UART receiver
        pub tasks_startrx: TaskRegister,
        /// Stop UART receiver
        pub tasks_stoprx: TaskRegister,
        /// Start UART transmitter
        pub tasks_starttx: TaskRegister,
        /// Stop UART transmitter
        pub tasks_stoptx: TaskRegister,
        _padding_16: [u8; 12],
        /// Suspend UART
        pub tasks_suspend: TaskRegister,
        _padding_32: [u8; 224],
        /// CTS is activated (set low). Clear To Send.
        pub events_cts: EventRegister,
        /// CTS is deactivated (set high). Not Clear To Send.
        pub events_ncts: EventRegister,
        /// Data received in RXD
        pub events_rxdrdy: EventRegister,
        _padding_268: [u8; 16],
        /// Data sent from TXD
        pub events_txdrdy: EventRegister,
        _padding_288: [u8; 4],
        /// Error detected
        pub events_error: EventRegister,
        _padding_296: [u8; 28],
        /// Receiver timeout
        pub events_rxto: EventRegister,
        _padding_328: [u8; 184],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 372],
        /// Error source
        pub errorsrc: errorsrc::ERRORSRC,
        _padding_1156: [u8; 124],
        /// Enable UART
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        /// RXD register
        pub rxd: rxd::RXD,
        /// TXD register
        pub txd: txd::TXD,
        _padding_1312: [u8; 4],
        /// Baud rate. Accuracy depends on the HFCLK source selected.
        pub baudrate: baudrate::BAUDRATE,
        _padding_1320: [u8; 68],
        /// Configuration of parity and hardware flow control
        pub config: config::CONFIG,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts_startrx(&self) -> CTS_STARTRX_FIELD {
                let raw = self.raw;
                CTS_STARTRX_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cts_startrx(&mut self, value: CTS_STARTRX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cts_startrx_with<F: Fn(&mut CTS_STARTRX_FIELD) -> &mut CTS_STARTRX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts_startrx();
                f(&mut value);
                self.set_cts_startrx(value)
            }

            pub fn ncts_stoprx(&self) -> NCTS_STOPRX_FIELD {
                let raw = self.raw;
                NCTS_STOPRX_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ncts_stoprx(&mut self, value: NCTS_STOPRX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ncts_stoprx_with<F: Fn(&mut NCTS_STOPRX_FIELD) -> &mut NCTS_STOPRX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts_stoprx();
                f(&mut value);
                self.set_ncts_stoprx(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CTS_STARTRX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CTS_STARTRX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] NCTS_STOPRX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl NCTS_STOPRX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts();
                f(&mut value);
                self.set_cts(value)
            }

            pub fn ncts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ncts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ncts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts();
                f(&mut value);
                self.set_ncts(value)
            }

            pub fn rxdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdrdy();
                f(&mut value);
                self.set_rxdrdy(value)
            }

            pub fn txdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdrdy();
                f(&mut value);
                self.set_txdrdy(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_rxto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxto();
                f(&mut value);
                self.set_rxto(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_cts(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ncts(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txdrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxto(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts();
                f(&mut value);
                self.set_cts(value)
            }

            pub fn ncts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ncts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ncts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts();
                f(&mut value);
                self.set_ncts(value)
            }

            pub fn rxdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdrdy();
                f(&mut value);
                self.set_rxdrdy(value)
            }

            pub fn txdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdrdy();
                f(&mut value);
                self.set_txdrdy(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_rxto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxto();
                f(&mut value);
                self.set_rxto(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_cts(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ncts(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txdrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxto(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }
        }
    }

    pub mod errorsrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSRC {
            raw: RawRegister<u32>,
        }

        impl ERRORSRC {
            pub fn write_with<F: Fn(&mut ERRORSRC_WRITE_VALUE) -> &mut ERRORSRC_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ERRORSRC_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSRC {
            type Value = ERRORSRC_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSRC_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSRC {
            type Value = ERRORSRC_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_READ_VALUE {
            raw: u32,
        }

        impl ERRORSRC_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overrun(&self) -> OVERRUN_READ_FIELD {
                let raw = self.raw;
                OVERRUN_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overrun(&mut self, value: OVERRUN_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overrun_with<F: Fn(&mut OVERRUN_READ_FIELD) -> &mut OVERRUN_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overrun();
                f(&mut value);
                self.set_overrun(value)
            }

            pub fn parity(&self) -> PARITY_READ_FIELD {
                let raw = self.raw;
                PARITY_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_parity(&mut self, value: PARITY_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_parity_with<F: Fn(&mut PARITY_READ_FIELD) -> &mut PARITY_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.parity();
                f(&mut value);
                self.set_parity(value)
            }

            pub fn framing(&self) -> FRAMING_READ_FIELD {
                let raw = self.raw;
                FRAMING_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_framing(&mut self, value: FRAMING_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_framing_with<F: Fn(&mut FRAMING_READ_FIELD) -> &mut FRAMING_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.framing();
                f(&mut value);
                self.set_framing(value)
            }

            pub fn r#break(&self) -> BREAK_READ_FIELD {
                let raw = self.raw;
                BREAK_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_break(&mut self, value: BREAK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_break_with<F: Fn(&mut BREAK_READ_FIELD) -> &mut BREAK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.r#break();
                f(&mut value);
                self.set_break(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_WRITE_VALUE {
            raw: u32,
        }

        impl ERRORSRC_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_overrun(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_parity(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_framing(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_break(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERRUN_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl OVERRUN_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl PARITY_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FRAMING_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl FRAMING_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BREAK_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl BREAK_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable UART
                        Disabled = 0,
        // Enable UART
                        Enabled = 4

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for RTS
            pub rts: PinSelectRegister,
            /// Pin select for TXD
            pub txd: PinSelectRegister,
            /// Pin select for CTS
            pub cts: PinSelectRegister,
            /// Pin select for RXD
            pub rxd: PinSelectRegister,
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXD {
            raw: RawRegister<u32>,
        }

        impl RXD {}

        impl RegisterRead for RXD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TXD {
            raw: RawRegister<u32>,
        }

        impl TXD {}

        impl RegisterWrite for TXD {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod baudrate {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BAUDRATE {
            raw: RawRegister<u32>,
        }

        impl BAUDRATE {
            pub fn write_baud1200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud1200)
            }

            pub fn write_baud2400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud2400)
            }

            pub fn write_baud4800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud4800)
            }

            pub fn write_baud9600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud9600)
            }

            pub fn write_baud14400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud14400)
            }

            pub fn write_baud19200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud19200)
            }

            pub fn write_baud28800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud28800)
            }

            pub fn write_baud31250(&mut self) {
                self.write(BAUDRATE_FIELD::Baud31250)
            }

            pub fn write_baud38400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud38400)
            }

            pub fn write_baud56000(&mut self) {
                self.write(BAUDRATE_FIELD::Baud56000)
            }

            pub fn write_baud57600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud57600)
            }

            pub fn write_baud76800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud76800)
            }

            pub fn write_baud115200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud115200)
            }

            pub fn write_baud230400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud230400)
            }

            pub fn write_baud250000(&mut self) {
                self.write(BAUDRATE_FIELD::Baud250000)
            }

            pub fn write_baud460800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud460800)
            }

            pub fn write_baud921600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud921600)
            }

            pub fn write_baud1m(&mut self) {
                self.write(BAUDRATE_FIELD::Baud1M)
            }
        }

        impl RegisterRead for BAUDRATE {
            type Value = BAUDRATE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                BAUDRATE_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for BAUDRATE {
            type Value = BAUDRATE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BAUDRATE_FIELD u32 =>
                        // 1200 baud (actual rate: 1205)
                        Baud1200 = 323584,
        // 2400 baud (actual rate: 2396)
                        Baud2400 = 643072,
        // 4800 baud (actual rate: 4808)
                        Baud4800 = 1290240,
        // 9600 baud (actual rate: 9598)
                        Baud9600 = 2576384,
        // 14400 baud (actual rate: 14414)
                        Baud14400 = 3866624,
        // 19200 baud (actual rate: 19208)
                        Baud19200 = 5152768,
        // 28800 baud (actual rate: 28829)
                        Baud28800 = 7729152,
        // 31250 baud
                        Baud31250 = 8388608,
        // 38400 baud (actual rate: 38462)
                        Baud38400 = 10309632,
        // 56000 baud (actual rate: 55944)
                        Baud56000 = 15007744,
        // 57600 baud (actual rate: 57762)
                        Baud57600 = 15462400,
        // 76800 baud (actual rate: 76923)
                        Baud76800 = 20615168,
        // 115200 baud (actual rate: 115942)
                        Baud115200 = 30924800,
        // 230400 baud (actual rate: 231884)
                        Baud230400 = 61845504,
        // 250000 baud
                        Baud250000 = 67108864,
        // 460800 baud (actual rate: 470588)
                        Baud460800 = 123695104,
        // 921600 baud (actual rate: 941176)
                        Baud921600 = 247386112,
        // 1Mega baud
                        Baud1M = 268435456

                    );

        impl BAUDRATE_FIELD {
            pub fn is_baud1200(&self) -> bool {
                *self == Self::Baud1200
            }

            pub fn set_baud1200(&mut self) -> &mut Self {
                *self = Self::Baud1200;
                self
            }

            pub fn is_baud2400(&self) -> bool {
                *self == Self::Baud2400
            }

            pub fn set_baud2400(&mut self) -> &mut Self {
                *self = Self::Baud2400;
                self
            }

            pub fn is_baud4800(&self) -> bool {
                *self == Self::Baud4800
            }

            pub fn set_baud4800(&mut self) -> &mut Self {
                *self = Self::Baud4800;
                self
            }

            pub fn is_baud9600(&self) -> bool {
                *self == Self::Baud9600
            }

            pub fn set_baud9600(&mut self) -> &mut Self {
                *self = Self::Baud9600;
                self
            }

            pub fn is_baud14400(&self) -> bool {
                *self == Self::Baud14400
            }

            pub fn set_baud14400(&mut self) -> &mut Self {
                *self = Self::Baud14400;
                self
            }

            pub fn is_baud19200(&self) -> bool {
                *self == Self::Baud19200
            }

            pub fn set_baud19200(&mut self) -> &mut Self {
                *self = Self::Baud19200;
                self
            }

            pub fn is_baud28800(&self) -> bool {
                *self == Self::Baud28800
            }

            pub fn set_baud28800(&mut self) -> &mut Self {
                *self = Self::Baud28800;
                self
            }

            pub fn is_baud31250(&self) -> bool {
                *self == Self::Baud31250
            }

            pub fn set_baud31250(&mut self) -> &mut Self {
                *self = Self::Baud31250;
                self
            }

            pub fn is_baud38400(&self) -> bool {
                *self == Self::Baud38400
            }

            pub fn set_baud38400(&mut self) -> &mut Self {
                *self = Self::Baud38400;
                self
            }

            pub fn is_baud56000(&self) -> bool {
                *self == Self::Baud56000
            }

            pub fn set_baud56000(&mut self) -> &mut Self {
                *self = Self::Baud56000;
                self
            }

            pub fn is_baud57600(&self) -> bool {
                *self == Self::Baud57600
            }

            pub fn set_baud57600(&mut self) -> &mut Self {
                *self = Self::Baud57600;
                self
            }

            pub fn is_baud76800(&self) -> bool {
                *self == Self::Baud76800
            }

            pub fn set_baud76800(&mut self) -> &mut Self {
                *self = Self::Baud76800;
                self
            }

            pub fn is_baud115200(&self) -> bool {
                *self == Self::Baud115200
            }

            pub fn set_baud115200(&mut self) -> &mut Self {
                *self = Self::Baud115200;
                self
            }

            pub fn is_baud230400(&self) -> bool {
                *self == Self::Baud230400
            }

            pub fn set_baud230400(&mut self) -> &mut Self {
                *self = Self::Baud230400;
                self
            }

            pub fn is_baud250000(&self) -> bool {
                *self == Self::Baud250000
            }

            pub fn set_baud250000(&mut self) -> &mut Self {
                *self = Self::Baud250000;
                self
            }

            pub fn is_baud460800(&self) -> bool {
                *self == Self::Baud460800
            }

            pub fn set_baud460800(&mut self) -> &mut Self {
                *self = Self::Baud460800;
                self
            }

            pub fn is_baud921600(&self) -> bool {
                *self == Self::Baud921600
            }

            pub fn set_baud921600(&mut self) -> &mut Self {
                *self = Self::Baud921600;
                self
            }

            pub fn is_baud1m(&self) -> bool {
                *self == Self::Baud1M
            }

            pub fn set_baud1m(&mut self) -> &mut Self {
                *self = Self::Baud1M;
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn hwfc(&self) -> HWFC_FIELD {
                let raw = self.raw;
                HWFC_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_hwfc(&mut self, value: HWFC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_hwfc_with<F: Fn(&mut HWFC_FIELD) -> &mut HWFC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.hwfc();
                f(&mut value);
                self.set_hwfc(value)
            }

            pub fn parity(&self) -> PARITY_FIELD {
                let raw = self.raw;
                PARITY_FIELD::from_value((raw & 0x0000000e) >> 1)
            }

            pub fn set_parity(&mut self, value: PARITY_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000000e) | (value << 1);
                self
            }

            pub fn set_parity_with<F: Fn(&mut PARITY_FIELD) -> &mut PARITY_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.parity();
                f(&mut value);
                self.set_parity(value)
            }

            pub fn stop(&self) -> STOP_FIELD {
                let raw = self.raw;
                STOP_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_stop(&mut self, value: STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stop_with<F: Fn(&mut STOP_FIELD) -> &mut STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stop();
                f(&mut value);
                self.set_stop(value)
            }

            pub fn paritytype(&self) -> PARITYTYPE_FIELD {
                let raw = self.raw;
                PARITYTYPE_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_paritytype(&mut self, value: PARITYTYPE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_paritytype_with<F: Fn(&mut PARITYTYPE_FIELD) -> &mut PARITYTYPE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.paritytype();
                f(&mut value);
                self.set_paritytype(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HWFC_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl HWFC_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_FIELD u32 =>
                        // Exclude parity bit
                        Excluded = 0,
        // Include parity bit
                        Included = 7

                    );

        impl PARITY_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STOP_FIELD u32 =>
                        // One stop bit
                        One = 0,
        // Two stop bits
                        Two = 1

                    );

        impl STOP_FIELD {
            pub fn is_one(&self) -> bool {
                *self == Self::One
            }

            pub fn set_one(&mut self) -> &mut Self {
                *self = Self::One;
                self
            }

            pub fn is_two(&self) -> bool {
                *self == Self::Two
            }

            pub fn set_two(&mut self) -> &mut Self {
                *self = Self::Two;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITYTYPE_FIELD u32 =>
                        // Even parity
                        Even = 0,
        // Odd parity
                        Odd = 1

                    );

        impl PARITYTYPE_FIELD {
            pub fn is_even(&self) -> bool {
                *self == Self::Even
            }

            pub fn set_even(&mut self) -> &mut Self {
                *self = Self::Even;
                self
            }

            pub fn is_odd(&self) -> bool {
                *self == Self::Odd
            }

            pub fn set_odd(&mut self) -> &mut Self {
                *self = Self::Odd;
                self
            }
        }
    }
}

pub mod uarte0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct UARTE0 {
        _hidden: (),
    }

    impl UARTE0 {
        const BASE_ADDRESS: u32 = 0x40002000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for UARTE0 {
        type Target = UARTE0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for UARTE0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct UARTE0_REGISTERS {
        _hidden: (),
        /// Start UART receiver
        pub tasks_startrx: TaskRegister,
        /// Stop UART receiver
        pub tasks_stoprx: TaskRegister,
        /// Start UART transmitter
        pub tasks_starttx: TaskRegister,
        /// Stop UART transmitter
        pub tasks_stoptx: TaskRegister,
        _padding_16: [u8; 28],
        /// Flush RX FIFO into RX buffer
        pub tasks_flushrx: TaskRegister,
        _padding_48: [u8; 208],
        /// CTS is activated (set low). Clear To Send.
        pub events_cts: EventRegister,
        /// CTS is deactivated (set high). Not Clear To Send.
        pub events_ncts: EventRegister,
        /// Data received in RXD (but potentially not yet transferred to Data
        /// RAM)
        pub events_rxdrdy: EventRegister,
        _padding_268: [u8; 4],
        /// Receive buffer is filled up
        pub events_endrx: EventRegister,
        _padding_276: [u8; 8],
        /// Data sent from TXD
        pub events_txdrdy: EventRegister,
        /// Last TX byte transmitted
        pub events_endtx: EventRegister,
        /// Error detected
        pub events_error: EventRegister,
        _padding_296: [u8; 28],
        /// Receiver timeout
        pub events_rxto: EventRegister,
        _padding_328: [u8; 4],
        /// UART receiver has started
        pub events_rxstarted: EventRegister,
        /// UART transmitter has started
        pub events_txstarted: EventRegister,
        _padding_340: [u8; 4],
        /// Transmitter stopped
        pub events_txstopped: EventRegister,
        _padding_348: [u8; 164],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 372],
        /// Error source This register is read/write one to clear.
        pub errorsrc: errorsrc::ERRORSRC,
        _padding_1156: [u8; 124],
        /// Enable UART
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1304: [u8; 12],
        /// Baud rate. Accuracy depends on the HFCLK source selected.
        pub baudrate: baudrate::BAUDRATE,
        _padding_1320: [u8; 12],
        pub rxd: rxd::RXD,
        _padding_1344: [u8; 4],
        pub txd: txd::TXD,
        _padding_1360: [u8; 28],
        /// Configuration of parity and hardware flow control
        pub config: config::CONFIG,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endrx_startrx(&self) -> ENDRX_STARTRX_FIELD {
                let raw = self.raw;
                ENDRX_STARTRX_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_endrx_startrx(&mut self, value: ENDRX_STARTRX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endrx_startrx_with<
                F: Fn(&mut ENDRX_STARTRX_FIELD) -> &mut ENDRX_STARTRX_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx_startrx();
                f(&mut value);
                self.set_endrx_startrx(value)
            }

            pub fn endrx_stoprx(&self) -> ENDRX_STOPRX_FIELD {
                let raw = self.raw;
                ENDRX_STOPRX_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_endrx_stoprx(&mut self, value: ENDRX_STOPRX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endrx_stoprx_with<
                F: Fn(&mut ENDRX_STOPRX_FIELD) -> &mut ENDRX_STOPRX_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx_stoprx();
                f(&mut value);
                self.set_endrx_stoprx(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDRX_STARTRX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ENDRX_STARTRX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDRX_STOPRX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ENDRX_STOPRX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts();
                f(&mut value);
                self.set_cts(value)
            }

            pub fn ncts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ncts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ncts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts();
                f(&mut value);
                self.set_ncts(value)
            }

            pub fn rxdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdrdy();
                f(&mut value);
                self.set_rxdrdy(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn txdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdrdy();
                f(&mut value);
                self.set_txdrdy(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_rxto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxto();
                f(&mut value);
                self.set_rxto(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn txstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_txstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_txstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstopped();
                f(&mut value);
                self.set_txstopped(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts();
                f(&mut value);
                self.set_cts(value)
            }

            pub fn ncts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ncts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ncts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts();
                f(&mut value);
                self.set_ncts(value)
            }

            pub fn rxdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdrdy();
                f(&mut value);
                self.set_rxdrdy(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn txdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdrdy();
                f(&mut value);
                self.set_txdrdy(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_rxto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxto();
                f(&mut value);
                self.set_rxto(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn txstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_txstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_txstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstopped();
                f(&mut value);
                self.set_txstopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_cts(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ncts(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_txdrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxto(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cts();
                f(&mut value);
                self.set_cts(value)
            }

            pub fn ncts(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ncts(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ncts_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ncts();
                f(&mut value);
                self.set_ncts(value)
            }

            pub fn rxdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdrdy();
                f(&mut value);
                self.set_rxdrdy(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn txdrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdrdy();
                f(&mut value);
                self.set_txdrdy(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxto(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_rxto(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxto_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxto();
                f(&mut value);
                self.set_rxto(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn txstopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_txstopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_txstopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstopped();
                f(&mut value);
                self.set_txstopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_cts(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ncts(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_txdrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxto(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }
        }
    }

    pub mod errorsrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSRC {
            raw: RawRegister<u32>,
        }

        impl ERRORSRC {
            pub fn write_with<F: Fn(&mut ERRORSRC_WRITE_VALUE) -> &mut ERRORSRC_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ERRORSRC_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSRC {
            type Value = ERRORSRC_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSRC_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSRC {
            type Value = ERRORSRC_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_READ_VALUE {
            raw: u32,
        }

        impl ERRORSRC_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overrun(&self) -> OVERRUN_READ_FIELD {
                let raw = self.raw;
                OVERRUN_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overrun(&mut self, value: OVERRUN_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overrun_with<F: Fn(&mut OVERRUN_READ_FIELD) -> &mut OVERRUN_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overrun();
                f(&mut value);
                self.set_overrun(value)
            }

            pub fn parity(&self) -> PARITY_READ_FIELD {
                let raw = self.raw;
                PARITY_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_parity(&mut self, value: PARITY_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_parity_with<F: Fn(&mut PARITY_READ_FIELD) -> &mut PARITY_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.parity();
                f(&mut value);
                self.set_parity(value)
            }

            pub fn framing(&self) -> FRAMING_READ_FIELD {
                let raw = self.raw;
                FRAMING_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_framing(&mut self, value: FRAMING_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_framing_with<F: Fn(&mut FRAMING_READ_FIELD) -> &mut FRAMING_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.framing();
                f(&mut value);
                self.set_framing(value)
            }

            pub fn r#break(&self) -> BREAK_READ_FIELD {
                let raw = self.raw;
                BREAK_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_break(&mut self, value: BREAK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_break_with<F: Fn(&mut BREAK_READ_FIELD) -> &mut BREAK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.r#break();
                f(&mut value);
                self.set_break(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_WRITE_VALUE {
            raw: u32,
        }

        impl ERRORSRC_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_overrun(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_parity(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_framing(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_break(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERRUN_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl OVERRUN_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl PARITY_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FRAMING_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl FRAMING_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BREAK_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl BREAK_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable UARTE
                        Disabled = 0,
        // Enable UARTE
                        Enabled = 8

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for RTS signal
            pub rts: PinSelectRegister,
            /// Pin select for TXD signal
            pub txd: PinSelectRegister,
            /// Pin select for CTS signal
            pub cts: PinSelectRegister,
            /// Pin select for RXD signal
            pub rxd: PinSelectRegister,
        }
    }

    pub mod baudrate {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BAUDRATE {
            raw: RawRegister<u32>,
        }

        impl BAUDRATE {
            pub fn write_baud1200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud1200)
            }

            pub fn write_baud2400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud2400)
            }

            pub fn write_baud4800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud4800)
            }

            pub fn write_baud9600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud9600)
            }

            pub fn write_baud14400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud14400)
            }

            pub fn write_baud19200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud19200)
            }

            pub fn write_baud28800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud28800)
            }

            pub fn write_baud31250(&mut self) {
                self.write(BAUDRATE_FIELD::Baud31250)
            }

            pub fn write_baud38400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud38400)
            }

            pub fn write_baud56000(&mut self) {
                self.write(BAUDRATE_FIELD::Baud56000)
            }

            pub fn write_baud57600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud57600)
            }

            pub fn write_baud76800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud76800)
            }

            pub fn write_baud115200(&mut self) {
                self.write(BAUDRATE_FIELD::Baud115200)
            }

            pub fn write_baud230400(&mut self) {
                self.write(BAUDRATE_FIELD::Baud230400)
            }

            pub fn write_baud250000(&mut self) {
                self.write(BAUDRATE_FIELD::Baud250000)
            }

            pub fn write_baud460800(&mut self) {
                self.write(BAUDRATE_FIELD::Baud460800)
            }

            pub fn write_baud921600(&mut self) {
                self.write(BAUDRATE_FIELD::Baud921600)
            }

            pub fn write_baud1m(&mut self) {
                self.write(BAUDRATE_FIELD::Baud1M)
            }
        }

        impl RegisterRead for BAUDRATE {
            type Value = BAUDRATE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                BAUDRATE_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for BAUDRATE {
            type Value = BAUDRATE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BAUDRATE_FIELD u32 =>
                        // 1200 baud (actual rate: 1205)
                        Baud1200 = 323584,
        // 2400 baud (actual rate: 2396)
                        Baud2400 = 643072,
        // 4800 baud (actual rate: 4808)
                        Baud4800 = 1290240,
        // 9600 baud (actual rate: 9598)
                        Baud9600 = 2576384,
        // 14400 baud (actual rate: 14401)
                        Baud14400 = 3862528,
        // 19200 baud (actual rate: 19208)
                        Baud19200 = 5152768,
        // 28800 baud (actual rate: 28777)
                        Baud28800 = 7716864,
        // 31250 baud
                        Baud31250 = 8388608,
        // 38400 baud (actual rate: 38369)
                        Baud38400 = 10289152,
        // 56000 baud (actual rate: 55944)
                        Baud56000 = 15007744,
        // 57600 baud (actual rate: 57554)
                        Baud57600 = 15400960,
        // 76800 baud (actual rate: 76923)
                        Baud76800 = 20615168,
        // 115200 baud (actual rate: 115108)
                        Baud115200 = 30801920,
        // 230400 baud (actual rate: 231884)
                        Baud230400 = 61865984,
        // 250000 baud
                        Baud250000 = 67108864,
        // 460800 baud (actual rate: 457143)
                        Baud460800 = 121634816,
        // 921600 baud (actual rate: 941176)
                        Baud921600 = 251658240,
        // 1 megabaud
                        Baud1M = 268435456

                    );

        impl BAUDRATE_FIELD {
            pub fn is_baud1200(&self) -> bool {
                *self == Self::Baud1200
            }

            pub fn set_baud1200(&mut self) -> &mut Self {
                *self = Self::Baud1200;
                self
            }

            pub fn is_baud2400(&self) -> bool {
                *self == Self::Baud2400
            }

            pub fn set_baud2400(&mut self) -> &mut Self {
                *self = Self::Baud2400;
                self
            }

            pub fn is_baud4800(&self) -> bool {
                *self == Self::Baud4800
            }

            pub fn set_baud4800(&mut self) -> &mut Self {
                *self = Self::Baud4800;
                self
            }

            pub fn is_baud9600(&self) -> bool {
                *self == Self::Baud9600
            }

            pub fn set_baud9600(&mut self) -> &mut Self {
                *self = Self::Baud9600;
                self
            }

            pub fn is_baud14400(&self) -> bool {
                *self == Self::Baud14400
            }

            pub fn set_baud14400(&mut self) -> &mut Self {
                *self = Self::Baud14400;
                self
            }

            pub fn is_baud19200(&self) -> bool {
                *self == Self::Baud19200
            }

            pub fn set_baud19200(&mut self) -> &mut Self {
                *self = Self::Baud19200;
                self
            }

            pub fn is_baud28800(&self) -> bool {
                *self == Self::Baud28800
            }

            pub fn set_baud28800(&mut self) -> &mut Self {
                *self = Self::Baud28800;
                self
            }

            pub fn is_baud31250(&self) -> bool {
                *self == Self::Baud31250
            }

            pub fn set_baud31250(&mut self) -> &mut Self {
                *self = Self::Baud31250;
                self
            }

            pub fn is_baud38400(&self) -> bool {
                *self == Self::Baud38400
            }

            pub fn set_baud38400(&mut self) -> &mut Self {
                *self = Self::Baud38400;
                self
            }

            pub fn is_baud56000(&self) -> bool {
                *self == Self::Baud56000
            }

            pub fn set_baud56000(&mut self) -> &mut Self {
                *self = Self::Baud56000;
                self
            }

            pub fn is_baud57600(&self) -> bool {
                *self == Self::Baud57600
            }

            pub fn set_baud57600(&mut self) -> &mut Self {
                *self = Self::Baud57600;
                self
            }

            pub fn is_baud76800(&self) -> bool {
                *self == Self::Baud76800
            }

            pub fn set_baud76800(&mut self) -> &mut Self {
                *self = Self::Baud76800;
                self
            }

            pub fn is_baud115200(&self) -> bool {
                *self == Self::Baud115200
            }

            pub fn set_baud115200(&mut self) -> &mut Self {
                *self = Self::Baud115200;
                self
            }

            pub fn is_baud230400(&self) -> bool {
                *self == Self::Baud230400
            }

            pub fn set_baud230400(&mut self) -> &mut Self {
                *self = Self::Baud230400;
                self
            }

            pub fn is_baud250000(&self) -> bool {
                *self == Self::Baud250000
            }

            pub fn set_baud250000(&mut self) -> &mut Self {
                *self = Self::Baud250000;
                self
            }

            pub fn is_baud460800(&self) -> bool {
                *self == Self::Baud460800
            }

            pub fn set_baud460800(&mut self) -> &mut Self {
                *self = Self::Baud460800;
                self
            }

            pub fn is_baud921600(&self) -> bool {
                *self == Self::Baud921600
            }

            pub fn set_baud921600(&mut self) -> &mut Self {
                *self = Self::Baud921600;
                self
            }

            pub fn is_baud1m(&self) -> bool {
                *self == Self::Baud1M
            }

            pub fn set_baud1m(&mut self) -> &mut Self {
                *self = Self::Baud1M;
                self
            }
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// RXD EasyDMA channel
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in receive buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// TXD EasyDMA channel
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in transmit buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn hwfc(&self) -> HWFC_FIELD {
                let raw = self.raw;
                HWFC_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_hwfc(&mut self, value: HWFC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_hwfc_with<F: Fn(&mut HWFC_FIELD) -> &mut HWFC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.hwfc();
                f(&mut value);
                self.set_hwfc(value)
            }

            pub fn parity(&self) -> PARITY_FIELD {
                let raw = self.raw;
                PARITY_FIELD::from_value((raw & 0x0000000e) >> 1)
            }

            pub fn set_parity(&mut self, value: PARITY_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000000e) | (value << 1);
                self
            }

            pub fn set_parity_with<F: Fn(&mut PARITY_FIELD) -> &mut PARITY_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.parity();
                f(&mut value);
                self.set_parity(value)
            }

            pub fn stop(&self) -> STOP_FIELD {
                let raw = self.raw;
                STOP_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_stop(&mut self, value: STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stop_with<F: Fn(&mut STOP_FIELD) -> &mut STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stop();
                f(&mut value);
                self.set_stop(value)
            }

            pub fn paritytype(&self) -> PARITYTYPE_FIELD {
                let raw = self.raw;
                PARITYTYPE_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_paritytype(&mut self, value: PARITYTYPE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_paritytype_with<F: Fn(&mut PARITYTYPE_FIELD) -> &mut PARITYTYPE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.paritytype();
                f(&mut value);
                self.set_paritytype(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HWFC_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl HWFC_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_FIELD u32 =>
                        // Exclude parity bit
                        Excluded = 0,
        // Include even parity bit
                        Included = 7

                    );

        impl PARITY_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STOP_FIELD u32 =>
                        // One stop bit
                        One = 0,
        // Two stop bits
                        Two = 1

                    );

        impl STOP_FIELD {
            pub fn is_one(&self) -> bool {
                *self == Self::One
            }

            pub fn set_one(&mut self) -> &mut Self {
                *self = Self::One;
                self
            }

            pub fn is_two(&self) -> bool {
                *self == Self::Two
            }

            pub fn set_two(&mut self) -> &mut Self {
                *self = Self::Two;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITYTYPE_FIELD u32 =>
                        // Even parity
                        Even = 0,
        // Odd parity
                        Odd = 1

                    );

        impl PARITYTYPE_FIELD {
            pub fn is_even(&self) -> bool {
                *self == Self::Even
            }

            pub fn set_even(&mut self) -> &mut Self {
                *self = Self::Even;
                self
            }

            pub fn is_odd(&self) -> bool {
                *self == Self::Odd
            }

            pub fn set_odd(&mut self) -> &mut Self {
                *self = Self::Odd;
                self
            }
        }
    }
}

pub mod spi0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPI0 {
        _hidden: (),
    }

    impl SPI0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPI0 {
        type Target = SPI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPI0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct SPI0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 264],
        /// TXD byte sent and RXD byte received
        pub events_ready: EventRegister,
        _padding_268: [u8; 504],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 500],
        /// Enable SPI
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1300: [u8; 4],
        /// RXD register
        pub rxd: rxd::RXD,
        /// TXD register
        pub txd: txd::TXD,
        _padding_1312: [u8; 4],
        /// SPI frequency. Accuracy depends on the HFCLK source selected.
        pub frequency: frequency::FREQUENCY,
        _padding_1320: [u8; 44],
        /// Configuration register
        pub config: config::CONFIG,
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable SPI
                        Disabled = 0,
        // Enable SPI
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCK
            pub sck: PinSelectRegister,
            /// Pin select for MOSI signal
            pub mosi: PinSelectRegister,
            /// Pin select for MISO signal
            pub miso: PinSelectRegister,
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXD {
            raw: RawRegister<u32>,
        }

        impl RXD {}

        impl RegisterRead for RXD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TXD {
            raw: RawRegister<u32>,
        }

        impl TXD {}

        impl RegisterRead for TXD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for TXD {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FREQUENCY {
            raw: RawRegister<u32>,
        }

        impl FREQUENCY {
            pub fn write_k125(&mut self) {
                self.write(FREQUENCY_FIELD::K125)
            }

            pub fn write_k250(&mut self) {
                self.write(FREQUENCY_FIELD::K250)
            }

            pub fn write_k500(&mut self) {
                self.write(FREQUENCY_FIELD::K500)
            }

            pub fn write_m1(&mut self) {
                self.write(FREQUENCY_FIELD::M1)
            }

            pub fn write_m2(&mut self) {
                self.write(FREQUENCY_FIELD::M2)
            }

            pub fn write_m4(&mut self) {
                self.write(FREQUENCY_FIELD::M4)
            }

            pub fn write_m8(&mut self) {
                self.write(FREQUENCY_FIELD::M8)
            }
        }

        impl RegisterRead for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                FREQUENCY_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FREQUENCY_FIELD u32 =>
                        // 125 kbps
                        K125 = 33554432,
        // 250 kbps
                        K250 = 67108864,
        // 500 kbps
                        K500 = 134217728,
        // 1 Mbps
                        M1 = 268435456,
        // 2 Mbps
                        M2 = 536870912,
        // 4 Mbps
                        M4 = 1073741824,
        // 8 Mbps
                        M8 = 2147483648

                    );

        impl FREQUENCY_FIELD {
            pub fn is_k125(&self) -> bool {
                *self == Self::K125
            }

            pub fn set_k125(&mut self) -> &mut Self {
                *self = Self::K125;
                self
            }

            pub fn is_k250(&self) -> bool {
                *self == Self::K250
            }

            pub fn set_k250(&mut self) -> &mut Self {
                *self = Self::K250;
                self
            }

            pub fn is_k500(&self) -> bool {
                *self == Self::K500
            }

            pub fn set_k500(&mut self) -> &mut Self {
                *self = Self::K500;
                self
            }

            pub fn is_m1(&self) -> bool {
                *self == Self::M1
            }

            pub fn set_m1(&mut self) -> &mut Self {
                *self = Self::M1;
                self
            }

            pub fn is_m2(&self) -> bool {
                *self == Self::M2
            }

            pub fn set_m2(&mut self) -> &mut Self {
                *self = Self::M2;
                self
            }

            pub fn is_m4(&self) -> bool {
                *self == Self::M4
            }

            pub fn set_m4(&mut self) -> &mut Self {
                *self = Self::M4;
                self
            }

            pub fn is_m8(&self) -> bool {
                *self == Self::M8
            }

            pub fn set_m8(&mut self) -> &mut Self {
                *self = Self::M8;
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn order(&self) -> ORDER_FIELD {
                let raw = self.raw;
                ORDER_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_order(&mut self, value: ORDER_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_order_with<F: Fn(&mut ORDER_FIELD) -> &mut ORDER_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.order();
                f(&mut value);
                self.set_order(value)
            }

            pub fn cpha(&self) -> CPHA_FIELD {
                let raw = self.raw;
                CPHA_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_cpha(&mut self, value: CPHA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_cpha_with<F: Fn(&mut CPHA_FIELD) -> &mut CPHA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpha();
                f(&mut value);
                self.set_cpha(value)
            }

            pub fn cpol(&self) -> CPOL_FIELD {
                let raw = self.raw;
                CPOL_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_cpol(&mut self, value: CPOL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cpol_with<F: Fn(&mut CPOL_FIELD) -> &mut CPOL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpol();
                f(&mut value);
                self.set_cpol(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ORDER_FIELD u32 =>
                        // Most significant bit shifted out first
                        MsbFirst = 0,
        // Least significant bit shifted out first
                        LsbFirst = 1

                    );

        impl ORDER_FIELD {
            pub fn is_msbfirst(&self) -> bool {
                *self == Self::MsbFirst
            }

            pub fn set_msbfirst(&mut self) -> &mut Self {
                *self = Self::MsbFirst;
                self
            }

            pub fn is_lsbfirst(&self) -> bool {
                *self == Self::LsbFirst
            }

            pub fn set_lsbfirst(&mut self) -> &mut Self {
                *self = Self::LsbFirst;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPHA_FIELD u32 =>
                        // Sample on leading edge of clock, shift serial data on trailing edge
                        Leading = 0,
        // Sample on trailing edge of clock, shift serial data on leading edge
                        Trailing = 1

                    );

        impl CPHA_FIELD {
            pub fn is_leading(&self) -> bool {
                *self == Self::Leading
            }

            pub fn set_leading(&mut self) -> &mut Self {
                *self = Self::Leading;
                self
            }

            pub fn is_trailing(&self) -> bool {
                *self == Self::Trailing
            }

            pub fn set_trailing(&mut self) -> &mut Self {
                *self = Self::Trailing;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPOL_FIELD u32 =>
                        // Active high
                        ActiveHigh = 0,
        // Active low
                        ActiveLow = 1

                    );

        impl CPOL_FIELD {
            pub fn is_activehigh(&self) -> bool {
                *self == Self::ActiveHigh
            }

            pub fn set_activehigh(&mut self) -> &mut Self {
                *self = Self::ActiveHigh;
                self
            }

            pub fn is_activelow(&self) -> bool {
                *self == Self::ActiveLow
            }

            pub fn set_activelow(&mut self) -> &mut Self {
                *self = Self::ActiveLow;
                self
            }
        }
    }
}

pub mod spim0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIM0 {
        _hidden: (),
    }

    impl SPIM0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIM0 {
        type Target = SPIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIM0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct SPIM0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 16],
        /// Start SPI transaction
        pub tasks_start: TaskRegister,
        /// Stop SPI transaction
        pub tasks_stop: TaskRegister,
        _padding_24: [u8; 4],
        /// Suspend SPI transaction
        pub tasks_suspend: TaskRegister,
        /// Resume SPI transaction
        pub tasks_resume: TaskRegister,
        _padding_36: [u8; 224],
        /// SPI transaction has stopped
        pub events_stopped: EventRegister,
        _padding_264: [u8; 8],
        /// End of RXD buffer reached
        pub events_endrx: EventRegister,
        _padding_276: [u8; 4],
        /// End of RXD buffer and TXD buffer reached
        pub events_end: EventRegister,
        _padding_284: [u8; 4],
        /// End of TXD buffer reached
        pub events_endtx: EventRegister,
        _padding_292: [u8; 40],
        /// Transaction started
        pub events_started: EventRegister,
        _padding_336: [u8; 176],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Stall status for EasyDMA RAM accesses. The fields in this register
        /// are set to STALL by hardware whenever a stall occurs and can be
        /// cleared (set to NOSTALL) by the CPU.
        pub stallstat: stallstat::STALLSTAT,
        _padding_1028: [u8; 252],
        /// Enable SPIM
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1304: [u8; 12],
        /// SPI frequency. Accuracy depends on the HFCLK source selected.
        pub frequency: frequency::FREQUENCY,
        _padding_1320: [u8; 12],
        pub rxd: rxd::RXD,
        pub txd: txd::TXD,
        /// Configuration register
        pub config: config::CONFIG,
        _padding_1368: [u8; 8],
        pub iftiming: iftiming::IFTIMING,
        /// Polarity of CSN output
        pub csnpol: csnpol::CSNPOL,
        /// Pin select for DCX signal
        pub pseldcx: pseldcx::PSELDCX,
        /// DCX configuration
        pub dcxcnt: dcxcnt::DCXCNT,
        _padding_1396: [u8; 76],
        /// Byte transmitted after TXD.MAXCNT bytes have been transmitted in the
        /// case when RXD.MAXCNT is greater than TXD.MAXCNT
        pub orc: orc::ORC,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end_start(&self) -> END_START_FIELD {
                let raw = self.raw;
                END_START_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_end_start(&mut self, value: END_START_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_end_start_with<F: Fn(&mut END_START_FIELD) -> &mut END_START_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end_start();
                f(&mut value);
                self.set_end_start(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] END_START_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl END_START_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }
    }

    pub mod stallstat {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct STALLSTAT {
            raw: RawRegister<u32>,
        }

        impl STALLSTAT {
            pub fn write_with<F: Fn(&mut STALLSTAT_VALUE) -> &mut STALLSTAT_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = STALLSTAT_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for STALLSTAT {
            type Value = STALLSTAT_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                STALLSTAT_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for STALLSTAT {
            type Value = STALLSTAT_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct STALLSTAT_VALUE {
            raw: u32,
        }

        impl STALLSTAT_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tx(&self) -> TX_FIELD {
                let raw = self.raw;
                TX_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tx(&mut self, value: TX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tx_with<F: Fn(&mut TX_FIELD) -> &mut TX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tx();
                f(&mut value);
                self.set_tx(value)
            }

            pub fn rx(&self) -> RX_FIELD {
                let raw = self.raw;
                RX_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rx(&mut self, value: RX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rx_with<F: Fn(&mut RX_FIELD) -> &mut RX_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rx();
                f(&mut value);
                self.set_rx(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TX_FIELD u32 =>
                        // No stall
                        NOSTALL = 0,
        // A stall has occurred
                        STALL = 1

                    );

        impl TX_FIELD {
            pub fn is_nostall(&self) -> bool {
                *self == Self::NOSTALL
            }

            pub fn set_nostall(&mut self) -> &mut Self {
                *self = Self::NOSTALL;
                self
            }

            pub fn is_stall(&self) -> bool {
                *self == Self::STALL
            }

            pub fn set_stall(&mut self) -> &mut Self {
                *self = Self::STALL;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RX_FIELD u32 =>
                        // No stall
                        NOSTALL = 0,
        // A stall has occurred
                        STALL = 1

                    );

        impl RX_FIELD {
            pub fn is_nostall(&self) -> bool {
                *self == Self::NOSTALL
            }

            pub fn set_nostall(&mut self) -> &mut Self {
                *self = Self::NOSTALL;
                self
            }

            pub fn is_stall(&self) -> bool {
                *self == Self::STALL
            }

            pub fn set_stall(&mut self) -> &mut Self {
                *self = Self::STALL;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable SPIM
                        Disabled = 0,
        // Enable SPIM
                        Enabled = 7

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCK
            pub sck: PinSelectRegister,
            /// Pin select for MOSI signal
            pub mosi: PinSelectRegister,
            /// Pin select for MISO signal
            pub miso: PinSelectRegister,
            /// Pin select for CSN
            pub csn: PinSelectRegister,
        }
    }

    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FREQUENCY {
            raw: RawRegister<u32>,
        }

        impl FREQUENCY {
            pub fn write_k125(&mut self) {
                self.write(FREQUENCY_FIELD::K125)
            }

            pub fn write_k250(&mut self) {
                self.write(FREQUENCY_FIELD::K250)
            }

            pub fn write_k500(&mut self) {
                self.write(FREQUENCY_FIELD::K500)
            }

            pub fn write_m1(&mut self) {
                self.write(FREQUENCY_FIELD::M1)
            }

            pub fn write_m2(&mut self) {
                self.write(FREQUENCY_FIELD::M2)
            }

            pub fn write_m4(&mut self) {
                self.write(FREQUENCY_FIELD::M4)
            }

            pub fn write_m8(&mut self) {
                self.write(FREQUENCY_FIELD::M8)
            }

            pub fn write_m16(&mut self) {
                self.write(FREQUENCY_FIELD::M16)
            }

            pub fn write_m32(&mut self) {
                self.write(FREQUENCY_FIELD::M32)
            }
        }

        impl RegisterRead for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                FREQUENCY_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FREQUENCY_FIELD u32 =>
                        // 125 kbps
                        K125 = 33554432,
        // 250 kbps
                        K250 = 67108864,
        // 500 kbps
                        K500 = 134217728,
        // 1 Mbps
                        M1 = 268435456,
        // 2 Mbps
                        M2 = 536870912,
        // 4 Mbps
                        M4 = 1073741824,
        // 8 Mbps
                        M8 = 2147483648,
        // 16 Mbps
                        M16 = 167772160,
        // 32 Mbps
                        M32 = 335544320

                    );

        impl FREQUENCY_FIELD {
            pub fn is_k125(&self) -> bool {
                *self == Self::K125
            }

            pub fn set_k125(&mut self) -> &mut Self {
                *self = Self::K125;
                self
            }

            pub fn is_k250(&self) -> bool {
                *self == Self::K250
            }

            pub fn set_k250(&mut self) -> &mut Self {
                *self = Self::K250;
                self
            }

            pub fn is_k500(&self) -> bool {
                *self == Self::K500
            }

            pub fn set_k500(&mut self) -> &mut Self {
                *self = Self::K500;
                self
            }

            pub fn is_m1(&self) -> bool {
                *self == Self::M1
            }

            pub fn set_m1(&mut self) -> &mut Self {
                *self = Self::M1;
                self
            }

            pub fn is_m2(&self) -> bool {
                *self == Self::M2
            }

            pub fn set_m2(&mut self) -> &mut Self {
                *self = Self::M2;
                self
            }

            pub fn is_m4(&self) -> bool {
                *self == Self::M4
            }

            pub fn set_m4(&mut self) -> &mut Self {
                *self = Self::M4;
                self
            }

            pub fn is_m8(&self) -> bool {
                *self == Self::M8
            }

            pub fn set_m8(&mut self) -> &mut Self {
                *self = Self::M8;
                self
            }

            pub fn is_m16(&self) -> bool {
                *self == Self::M16
            }

            pub fn set_m16(&mut self) -> &mut Self {
                *self = Self::M16;
                self
            }

            pub fn is_m32(&self) -> bool {
                *self == Self::M32
            }

            pub fn set_m32(&mut self) -> &mut Self {
                *self = Self::M32;
                self
            }
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// RXD EasyDMA channel
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in receive buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// TXD EasyDMA channel
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Number of bytes in transmit buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn order(&self) -> ORDER_FIELD {
                let raw = self.raw;
                ORDER_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_order(&mut self, value: ORDER_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_order_with<F: Fn(&mut ORDER_FIELD) -> &mut ORDER_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.order();
                f(&mut value);
                self.set_order(value)
            }

            pub fn cpha(&self) -> CPHA_FIELD {
                let raw = self.raw;
                CPHA_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_cpha(&mut self, value: CPHA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_cpha_with<F: Fn(&mut CPHA_FIELD) -> &mut CPHA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpha();
                f(&mut value);
                self.set_cpha(value)
            }

            pub fn cpol(&self) -> CPOL_FIELD {
                let raw = self.raw;
                CPOL_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_cpol(&mut self, value: CPOL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cpol_with<F: Fn(&mut CPOL_FIELD) -> &mut CPOL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpol();
                f(&mut value);
                self.set_cpol(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ORDER_FIELD u32 =>
                        // Most significant bit shifted out first
                        MsbFirst = 0,
        // Least significant bit shifted out first
                        LsbFirst = 1

                    );

        impl ORDER_FIELD {
            pub fn is_msbfirst(&self) -> bool {
                *self == Self::MsbFirst
            }

            pub fn set_msbfirst(&mut self) -> &mut Self {
                *self = Self::MsbFirst;
                self
            }

            pub fn is_lsbfirst(&self) -> bool {
                *self == Self::LsbFirst
            }

            pub fn set_lsbfirst(&mut self) -> &mut Self {
                *self = Self::LsbFirst;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPHA_FIELD u32 =>
                        // Sample on leading edge of clock, shift serial data on trailing edge
                        Leading = 0,
        // Sample on trailing edge of clock, shift serial data on leading edge
                        Trailing = 1

                    );

        impl CPHA_FIELD {
            pub fn is_leading(&self) -> bool {
                *self == Self::Leading
            }

            pub fn set_leading(&mut self) -> &mut Self {
                *self = Self::Leading;
                self
            }

            pub fn is_trailing(&self) -> bool {
                *self == Self::Trailing
            }

            pub fn set_trailing(&mut self) -> &mut Self {
                *self = Self::Trailing;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPOL_FIELD u32 =>
                        // Active high
                        ActiveHigh = 0,
        // Active low
                        ActiveLow = 1

                    );

        impl CPOL_FIELD {
            pub fn is_activehigh(&self) -> bool {
                *self == Self::ActiveHigh
            }

            pub fn set_activehigh(&mut self) -> &mut Self {
                *self = Self::ActiveHigh;
                self
            }

            pub fn is_activelow(&self) -> bool {
                *self == Self::ActiveLow
            }

            pub fn set_activelow(&mut self) -> &mut Self {
                *self = Self::ActiveLow;
                self
            }
        }
    }

    pub mod iftiming {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct IFTIMING {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Sample delay for input serial data on MISO
            pub rxdelay: rxdelay::RXDELAY,
            /// Minimum duration between edge of CSN and edge of SCK and minimum
            /// duration CSN must stay high between transactions
            pub csndur: csndur::CSNDUR,
        }

        pub mod rxdelay {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct RXDELAY {
                raw: RawRegister<u32>,
            }

            impl RXDELAY {}

            impl RegisterRead for RXDELAY {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x00000007) >> 0
                }
            }

            impl RegisterWrite for RXDELAY {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x00000007) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod csndur {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct CSNDUR {
                raw: RawRegister<u32>,
            }

            impl CSNDUR {}

            impl RegisterRead for CSNDUR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x000000ff) >> 0
                }
            }

            impl RegisterWrite for CSNDUR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x000000ff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod csnpol {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CSNPOL {
            raw: RawRegister<u32>,
        }

        impl CSNPOL {
            pub fn write_low(&mut self) {
                self.write(CSNPOL_FIELD::LOW)
            }

            pub fn write_high(&mut self) {
                self.write(CSNPOL_FIELD::HIGH)
            }
        }

        impl RegisterRead for CSNPOL {
            type Value = CSNPOL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                CSNPOL_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for CSNPOL {
            type Value = CSNPOL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CSNPOL_FIELD u32 =>
                        // Active low (idle state high)
                        LOW = 0,
        // Active high (idle state low)
                        HIGH = 1

                    );

        impl CSNPOL_FIELD {
            pub fn is_low(&self) -> bool {
                *self == Self::LOW
            }

            pub fn set_low(&mut self) -> &mut Self {
                *self = Self::LOW;
                self
            }

            pub fn is_high(&self) -> bool {
                *self == Self::HIGH
            }

            pub fn set_high(&mut self) -> &mut Self {
                *self = Self::HIGH;
                self
            }
        }
    }

    pub mod pseldcx {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PSELDCX {
            raw: RawRegister<u32>,
        }

        impl PSELDCX {
            pub fn write_with<F: Fn(&mut PSELDCX_VALUE) -> &mut PSELDCX_VALUE>(&mut self, f: F) {
                let mut v = PSELDCX_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PSELDCX {
            type Value = PSELDCX_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PSELDCX_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PSELDCX {
            type Value = PSELDCX_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PSELDCX_VALUE {
            raw: u32,
        }

        impl PSELDCX_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000001f) >> 0
            }

            pub fn set_pin(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn port(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000020) >> 5
            }

            pub fn set_port(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn connect(&self) -> CONNECT_FIELD {
                let raw = self.raw;
                CONNECT_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_connect(&mut self, value: CONNECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_connect_with<F: Fn(&mut CONNECT_FIELD) -> &mut CONNECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.connect();
                f(&mut value);
                self.set_connect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CONNECT_FIELD u32 =>
                        // Disconnect
                        Disconnected = 1,
        // Connect
                        Connected = 0

                    );

        impl CONNECT_FIELD {
            pub fn is_disconnected(&self) -> bool {
                *self == Self::Disconnected
            }

            pub fn set_disconnected(&mut self) -> &mut Self {
                *self = Self::Disconnected;
                self
            }

            pub fn is_connected(&self) -> bool {
                *self == Self::Connected
            }

            pub fn set_connected(&mut self) -> &mut Self {
                *self = Self::Connected;
                self
            }
        }
    }

    pub mod dcxcnt {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DCXCNT {
            raw: RawRegister<u32>,
        }

        impl DCXCNT {}

        impl RegisterRead for DCXCNT {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000000f) >> 0
            }
        }

        impl RegisterWrite for DCXCNT {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000000f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod orc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ORC {
            raw: RawRegister<u32>,
        }

        impl ORC {}

        impl RegisterRead for ORC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for ORC {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod spis0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIS0 {
        _hidden: (),
    }

    impl SPIS0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIS0 {
        type Target = SPIS0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIS0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct SPIS0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 36],
        /// Acquire SPI semaphore
        pub tasks_acquire: TaskRegister,
        /// Release SPI semaphore, enabling the SPI slave to acquire it
        pub tasks_release: TaskRegister,
        _padding_44: [u8; 216],
        /// Granted transaction completed
        pub events_end: EventRegister,
        _padding_264: [u8; 8],
        /// End of RXD buffer reached
        pub events_endrx: EventRegister,
        _padding_276: [u8; 20],
        /// Semaphore acquired
        pub events_acquired: EventRegister,
        _padding_300: [u8; 212],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Semaphore status register
        pub semstat: semstat::SEMSTAT,
        _padding_1028: [u8; 60],
        /// Status from last transaction
        pub status: status::STATUS,
        _padding_1092: [u8; 188],
        /// Enable SPI slave
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1304: [u8; 28],
        pub rxd: rxd::RXD,
        pub txd: txd::TXD,
        /// Configuration register
        pub config: config::CONFIG,
        _padding_1368: [u8; 4],
        /// Default character. Character clocked out in case of an ignored
        /// transaction.
        pub def: def::DEF,
        _padding_1376: [u8; 96],
        /// Over-read character
        pub orc: orc::ORC,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end_acquire(&self) -> END_ACQUIRE_FIELD {
                let raw = self.raw;
                END_ACQUIRE_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_end_acquire(&mut self, value: END_ACQUIRE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end_acquire_with<F: Fn(&mut END_ACQUIRE_FIELD) -> &mut END_ACQUIRE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end_acquire();
                f(&mut value);
                self.set_end_acquire(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] END_ACQUIRE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl END_ACQUIRE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn acquired(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_acquired(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_acquired_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.acquired();
                f(&mut value);
                self.set_acquired(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_acquired(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn acquired(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_acquired(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_acquired_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.acquired();
                f(&mut value);
                self.set_acquired(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_acquired(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }
        }
    }

    pub mod semstat {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SEMSTAT {
            raw: RawRegister<u32>,
        }

        impl SEMSTAT {}

        impl RegisterRead for SEMSTAT {
            type Value = SEMSTAT_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                SEMSTAT_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SEMSTAT_FIELD u32 =>
                        // Semaphore is free
                        Free = 0,
        // Semaphore is assigned to CPU
                        CPU = 1,
        // Semaphore is assigned to SPI slave
                        SPIS = 2,
        // Semaphore is assigned to SPI but a handover to the CPU is pending
                        CPUPending = 3

                    );

        impl SEMSTAT_FIELD {
            pub fn is_free(&self) -> bool {
                *self == Self::Free
            }

            pub fn set_free(&mut self) -> &mut Self {
                *self = Self::Free;
                self
            }

            pub fn is_cpu(&self) -> bool {
                *self == Self::CPU
            }

            pub fn set_cpu(&mut self) -> &mut Self {
                *self = Self::CPU;
                self
            }

            pub fn is_spis(&self) -> bool {
                *self == Self::SPIS
            }

            pub fn set_spis(&mut self) -> &mut Self {
                *self = Self::SPIS;
                self
            }

            pub fn is_cpupending(&self) -> bool {
                *self == Self::CPUPending
            }

            pub fn set_cpupending(&mut self) -> &mut Self {
                *self = Self::CPUPending;
                self
            }
        }
    }

    pub mod status {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct STATUS {
            raw: RawRegister<u32>,
        }

        impl STATUS {
            pub fn write_with<F: Fn(&mut STATUS_WRITE_VALUE) -> &mut STATUS_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = STATUS_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for STATUS {
            type Value = STATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                STATUS_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for STATUS {
            type Value = STATUS_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct STATUS_READ_VALUE {
            raw: u32,
        }

        impl STATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overread(&self) -> OVERREAD_READ_FIELD {
                let raw = self.raw;
                OVERREAD_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overread(&mut self, value: OVERREAD_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overread_with<
                F: Fn(&mut OVERREAD_READ_FIELD) -> &mut OVERREAD_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overread();
                f(&mut value);
                self.set_overread(value)
            }

            pub fn overflow(&self) -> OVERFLOW_READ_FIELD {
                let raw = self.raw;
                OVERFLOW_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_overflow(&mut self, value: OVERFLOW_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_overflow_with<
                F: Fn(&mut OVERFLOW_READ_FIELD) -> &mut OVERFLOW_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overflow();
                f(&mut value);
                self.set_overflow(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct STATUS_WRITE_VALUE {
            raw: u32,
        }

        impl STATUS_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_overread(&mut self) -> &mut Self {
                let value = OVERREAD_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overflow(&mut self) -> &mut Self {
                let value = OVERFLOW_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERREAD_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl OVERREAD_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERREAD_WRITE_FIELD u32 =>
            // Write: clear error on writing '1'
            Clear = 1

        );

        impl OVERREAD_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERFLOW_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl OVERFLOW_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERFLOW_WRITE_FIELD u32 =>
            // Write: clear error on writing '1'
            Clear = 1

        );

        impl OVERFLOW_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable SPI slave
                        Disabled = 0,
        // Enable SPI slave
                        Enabled = 2

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCK
            pub sck: PinSelectRegister,
            /// Pin select for MISO signal
            pub miso: PinSelectRegister,
            /// Pin select for MOSI signal
            pub mosi: PinSelectRegister,
            /// Pin select for CSN signal
            pub csn: PinSelectRegister,
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// RXD data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in receive buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes received in last granted transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// TXD data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in transmit buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transmitted in last granted transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn order(&self) -> ORDER_FIELD {
                let raw = self.raw;
                ORDER_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_order(&mut self, value: ORDER_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_order_with<F: Fn(&mut ORDER_FIELD) -> &mut ORDER_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.order();
                f(&mut value);
                self.set_order(value)
            }

            pub fn cpha(&self) -> CPHA_FIELD {
                let raw = self.raw;
                CPHA_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_cpha(&mut self, value: CPHA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_cpha_with<F: Fn(&mut CPHA_FIELD) -> &mut CPHA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpha();
                f(&mut value);
                self.set_cpha(value)
            }

            pub fn cpol(&self) -> CPOL_FIELD {
                let raw = self.raw;
                CPOL_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_cpol(&mut self, value: CPOL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cpol_with<F: Fn(&mut CPOL_FIELD) -> &mut CPOL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cpol();
                f(&mut value);
                self.set_cpol(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ORDER_FIELD u32 =>
                        // Most significant bit shifted out first
                        MsbFirst = 0,
        // Least significant bit shifted out first
                        LsbFirst = 1

                    );

        impl ORDER_FIELD {
            pub fn is_msbfirst(&self) -> bool {
                *self == Self::MsbFirst
            }

            pub fn set_msbfirst(&mut self) -> &mut Self {
                *self = Self::MsbFirst;
                self
            }

            pub fn is_lsbfirst(&self) -> bool {
                *self == Self::LsbFirst
            }

            pub fn set_lsbfirst(&mut self) -> &mut Self {
                *self = Self::LsbFirst;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPHA_FIELD u32 =>
                        // Sample on leading edge of clock, shift serial data on trailing edge
                        Leading = 0,
        // Sample on trailing edge of clock, shift serial data on leading edge
                        Trailing = 1

                    );

        impl CPHA_FIELD {
            pub fn is_leading(&self) -> bool {
                *self == Self::Leading
            }

            pub fn set_leading(&mut self) -> &mut Self {
                *self = Self::Leading;
                self
            }

            pub fn is_trailing(&self) -> bool {
                *self == Self::Trailing
            }

            pub fn set_trailing(&mut self) -> &mut Self {
                *self = Self::Trailing;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CPOL_FIELD u32 =>
                        // Active high
                        ActiveHigh = 0,
        // Active low
                        ActiveLow = 1

                    );

        impl CPOL_FIELD {
            pub fn is_activehigh(&self) -> bool {
                *self == Self::ActiveHigh
            }

            pub fn set_activehigh(&mut self) -> &mut Self {
                *self = Self::ActiveHigh;
                self
            }

            pub fn is_activelow(&self) -> bool {
                *self == Self::ActiveLow
            }

            pub fn set_activelow(&mut self) -> &mut Self {
                *self = Self::ActiveLow;
                self
            }
        }
    }

    pub mod def {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DEF {
            raw: RawRegister<u32>,
        }

        impl DEF {}

        impl RegisterRead for DEF {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for DEF {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod orc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ORC {
            raw: RawRegister<u32>,
        }

        impl ORC {}

        impl RegisterRead for ORC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for ORC {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod twi0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWI0 {
        _hidden: (),
    }

    impl TWI0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWI0 {
        type Target = TWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWI0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct TWI0_REGISTERS {
        _hidden: (),
        /// Start TWI receive sequence
        pub tasks_startrx: TaskRegister,
        _padding_4: [u8; 4],
        /// Start TWI transmit sequence
        pub tasks_starttx: TaskRegister,
        _padding_12: [u8; 8],
        /// Stop TWI transaction
        pub tasks_stop: TaskRegister,
        _padding_24: [u8; 4],
        /// Suspend TWI transaction
        pub tasks_suspend: TaskRegister,
        /// Resume TWI transaction
        pub tasks_resume: TaskRegister,
        _padding_36: [u8; 224],
        /// TWI stopped
        pub events_stopped: EventRegister,
        /// TWI RXD byte received
        pub events_rxdready: EventRegister,
        _padding_268: [u8; 16],
        /// TWI TXD byte sent
        pub events_txdsent: EventRegister,
        _padding_288: [u8; 4],
        /// TWI error
        pub events_error: EventRegister,
        _padding_296: [u8; 16],
        /// TWI byte boundary, generated before each byte that is sent or
        /// received
        pub events_bb: EventRegister,
        _padding_316: [u8; 12],
        /// TWI entered the suspended state
        pub events_suspended: EventRegister,
        _padding_332: [u8; 180],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 440],
        /// Error source
        pub errorsrc: errorsrc::ERRORSRC,
        _padding_1224: [u8; 56],
        /// Enable TWI
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1296: [u8; 8],
        /// RXD register
        pub rxd: rxd::RXD,
        /// TXD register
        pub txd: txd::TXD,
        _padding_1312: [u8; 4],
        /// TWI frequency. Accuracy depends on the HFCLK source selected.
        pub frequency: frequency::FREQUENCY,
        _padding_1320: [u8; 96],
        /// Address used in the TWI transfer
        pub address: address::ADDRESS,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn bb_suspend(&self) -> BB_SUSPEND_FIELD {
                let raw = self.raw;
                BB_SUSPEND_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_bb_suspend(&mut self, value: BB_SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_bb_suspend_with<F: Fn(&mut BB_SUSPEND_FIELD) -> &mut BB_SUSPEND_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bb_suspend();
                f(&mut value);
                self.set_bb_suspend(value)
            }

            pub fn bb_stop(&self) -> BB_STOP_FIELD {
                let raw = self.raw;
                BB_STOP_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_bb_stop(&mut self, value: BB_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_bb_stop_with<F: Fn(&mut BB_STOP_FIELD) -> &mut BB_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bb_stop();
                f(&mut value);
                self.set_bb_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BB_SUSPEND_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl BB_SUSPEND_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BB_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl BB_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn rxdready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdready();
                f(&mut value);
                self.set_rxdready(value)
            }

            pub fn txdsent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdsent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdsent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdsent();
                f(&mut value);
                self.set_txdsent(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn bb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_bb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_bb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bb();
                f(&mut value);
                self.set_bb(value)
            }

            pub fn suspended(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_suspended(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_suspended_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspended();
                f(&mut value);
                self.set_suspended(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txdsent(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_bb(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_suspended(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn rxdready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rxdready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rxdready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxdready();
                f(&mut value);
                self.set_rxdready(value)
            }

            pub fn txdsent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_txdsent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_txdsent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txdsent();
                f(&mut value);
                self.set_txdsent(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn bb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_bb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_bb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bb();
                f(&mut value);
                self.set_bb(value)
            }

            pub fn suspended(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_suspended(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_suspended_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspended();
                f(&mut value);
                self.set_suspended(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxdready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txdsent(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_bb(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_suspended(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }
        }
    }

    pub mod errorsrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSRC {
            raw: RawRegister<u32>,
        }

        impl ERRORSRC {
            pub fn write_with<F: Fn(&mut ERRORSRC_WRITE_VALUE) -> &mut ERRORSRC_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ERRORSRC_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSRC {
            type Value = ERRORSRC_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSRC_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSRC {
            type Value = ERRORSRC_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_READ_VALUE {
            raw: u32,
        }

        impl ERRORSRC_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overrun(&self) -> OVERRUN_READ_FIELD {
                let raw = self.raw;
                OVERRUN_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overrun(&mut self, value: OVERRUN_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overrun_with<F: Fn(&mut OVERRUN_READ_FIELD) -> &mut OVERRUN_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overrun();
                f(&mut value);
                self.set_overrun(value)
            }

            pub fn anack(&self) -> ANACK_READ_FIELD {
                let raw = self.raw;
                ANACK_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_anack(&mut self, value: ANACK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_anack_with<F: Fn(&mut ANACK_READ_FIELD) -> &mut ANACK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.anack();
                f(&mut value);
                self.set_anack(value)
            }

            pub fn dnack(&self) -> DNACK_READ_FIELD {
                let raw = self.raw;
                DNACK_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_dnack(&mut self, value: DNACK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_dnack_with<F: Fn(&mut DNACK_READ_FIELD) -> &mut DNACK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dnack();
                f(&mut value);
                self.set_dnack(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_WRITE_VALUE {
            raw: u32,
        }

        impl ERRORSRC_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_overrun(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_anack(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_dnack(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERRUN_READ_FIELD u32 =>
                        // Read: no overrun occured
                        NotPresent = 0,
        // Read: overrun occured
                        Present = 1

                    );

        impl OVERRUN_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ANACK_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl ANACK_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DNACK_READ_FIELD u32 =>
                        // Read: error not present
                        NotPresent = 0,
        // Read: error present
                        Present = 1

                    );

        impl DNACK_READ_FIELD {
            pub fn is_notpresent(&self) -> bool {
                *self == Self::NotPresent
            }

            pub fn set_notpresent(&mut self) -> &mut Self {
                *self = Self::NotPresent;
                self
            }

            pub fn is_present(&self) -> bool {
                *self == Self::Present
            }

            pub fn set_present(&mut self) -> &mut Self {
                *self = Self::Present;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable TWI
                        Disabled = 0,
        // Enable TWI
                        Enabled = 5

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCL
            pub scl: PinSelectRegister,
            /// Pin select for SDA
            pub sda: PinSelectRegister,
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RXD {
            raw: RawRegister<u32>,
        }

        impl RXD {}

        impl RegisterRead for RXD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TXD {
            raw: RawRegister<u32>,
        }

        impl TXD {}

        impl RegisterRead for TXD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for TXD {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FREQUENCY {
            raw: RawRegister<u32>,
        }

        impl FREQUENCY {
            pub fn write_k100(&mut self) {
                self.write(FREQUENCY_FIELD::K100)
            }

            pub fn write_k250(&mut self) {
                self.write(FREQUENCY_FIELD::K250)
            }

            pub fn write_k400(&mut self) {
                self.write(FREQUENCY_FIELD::K400)
            }
        }

        impl RegisterRead for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                FREQUENCY_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FREQUENCY_FIELD u32 =>
                        // 100 kbps
                        K100 = 26738688,
        // 250 kbps
                        K250 = 67108864,
        // 400 kbps (actual rate 410.256 kbps)
                        K400 = 107479040

                    );

        impl FREQUENCY_FIELD {
            pub fn is_k100(&self) -> bool {
                *self == Self::K100
            }

            pub fn set_k100(&mut self) -> &mut Self {
                *self = Self::K100;
                self
            }

            pub fn is_k250(&self) -> bool {
                *self == Self::K250
            }

            pub fn set_k250(&mut self) -> &mut Self {
                *self = Self::K250;
                self
            }

            pub fn is_k400(&self) -> bool {
                *self == Self::K400
            }

            pub fn set_k400(&mut self) -> &mut Self {
                *self = Self::K400;
                self
            }
        }
    }

    pub mod address {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ADDRESS {
            raw: RawRegister<u32>,
        }

        impl ADDRESS {}

        impl RegisterRead for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }

        impl RegisterWrite for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000007f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod twim0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWIM0 {
        _hidden: (),
    }

    impl TWIM0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWIM0 {
        type Target = TWIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWIM0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct TWIM0_REGISTERS {
        _hidden: (),
        /// Start TWI receive sequence
        pub tasks_startrx: TaskRegister,
        _padding_4: [u8; 4],
        /// Start TWI transmit sequence
        pub tasks_starttx: TaskRegister,
        _padding_12: [u8; 8],
        /// Stop TWI transaction. Must be issued while the TWI master is not
        /// suspended.
        pub tasks_stop: TaskRegister,
        _padding_24: [u8; 4],
        /// Suspend TWI transaction
        pub tasks_suspend: TaskRegister,
        /// Resume TWI transaction
        pub tasks_resume: TaskRegister,
        _padding_36: [u8; 224],
        /// TWI stopped
        pub events_stopped: EventRegister,
        _padding_264: [u8; 28],
        /// TWI error
        pub events_error: EventRegister,
        _padding_296: [u8; 32],
        /// SUSPEND task has been issued, TWI traffic is now suspended.
        pub events_suspended: EventRegister,
        /// Receive sequence started
        pub events_rxstarted: EventRegister,
        /// Transmit sequence started
        pub events_txstarted: EventRegister,
        _padding_340: [u8; 8],
        /// Byte boundary, starting to receive the last byte
        pub events_lastrx: EventRegister,
        /// Byte boundary, starting to transmit the last byte
        pub events_lasttx: EventRegister,
        _padding_356: [u8; 156],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 440],
        /// Error source
        pub errorsrc: errorsrc::ERRORSRC,
        _padding_1224: [u8; 56],
        /// Enable TWIM
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1296: [u8; 20],
        /// TWI frequency. Accuracy depends on the HFCLK source selected.
        pub frequency: frequency::FREQUENCY,
        _padding_1320: [u8; 12],
        pub rxd: rxd::RXD,
        pub txd: txd::TXD,
        _padding_1364: [u8; 52],
        /// Address used in the TWI transfer
        pub address: address::ADDRESS,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn lasttx_startrx(&self) -> LASTTX_STARTRX_FIELD {
                let raw = self.raw;
                LASTTX_STARTRX_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_lasttx_startrx(&mut self, value: LASTTX_STARTRX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_lasttx_startrx_with<
                F: Fn(&mut LASTTX_STARTRX_FIELD) -> &mut LASTTX_STARTRX_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx_startrx();
                f(&mut value);
                self.set_lasttx_startrx(value)
            }

            pub fn lasttx_suspend(&self) -> LASTTX_SUSPEND_FIELD {
                let raw = self.raw;
                LASTTX_SUSPEND_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_lasttx_suspend(&mut self, value: LASTTX_SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_lasttx_suspend_with<
                F: Fn(&mut LASTTX_SUSPEND_FIELD) -> &mut LASTTX_SUSPEND_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx_suspend();
                f(&mut value);
                self.set_lasttx_suspend(value)
            }

            pub fn lasttx_stop(&self) -> LASTTX_STOP_FIELD {
                let raw = self.raw;
                LASTTX_STOP_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_lasttx_stop(&mut self, value: LASTTX_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_lasttx_stop_with<F: Fn(&mut LASTTX_STOP_FIELD) -> &mut LASTTX_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx_stop();
                f(&mut value);
                self.set_lasttx_stop(value)
            }

            pub fn lastrx_starttx(&self) -> LASTRX_STARTTX_FIELD {
                let raw = self.raw;
                LASTRX_STARTTX_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_lastrx_starttx(&mut self, value: LASTRX_STARTTX_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_lastrx_starttx_with<
                F: Fn(&mut LASTRX_STARTTX_FIELD) -> &mut LASTRX_STARTTX_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx_starttx();
                f(&mut value);
                self.set_lastrx_starttx(value)
            }

            pub fn lastrx_suspend(&self) -> LASTRX_SUSPEND_FIELD {
                let raw = self.raw;
                LASTRX_SUSPEND_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_lastrx_suspend(&mut self, value: LASTRX_SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_lastrx_suspend_with<
                F: Fn(&mut LASTRX_SUSPEND_FIELD) -> &mut LASTRX_SUSPEND_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx_suspend();
                f(&mut value);
                self.set_lastrx_suspend(value)
            }

            pub fn lastrx_stop(&self) -> LASTRX_STOP_FIELD {
                let raw = self.raw;
                LASTRX_STOP_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_lastrx_stop(&mut self, value: LASTRX_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_lastrx_stop_with<F: Fn(&mut LASTRX_STOP_FIELD) -> &mut LASTRX_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx_stop();
                f(&mut value);
                self.set_lastrx_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTTX_STARTRX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTTX_STARTRX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTTX_SUSPEND_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTTX_SUSPEND_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTTX_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTTX_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTRX_STARTTX_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTRX_STARTTX_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTRX_SUSPEND_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTRX_SUSPEND_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LASTRX_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LASTRX_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn suspended(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_suspended(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_suspended_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspended();
                f(&mut value);
                self.set_suspended(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn lastrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_lastrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_lastrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx();
                f(&mut value);
                self.set_lastrx(value)
            }

            pub fn lasttx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_lasttx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_lasttx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx();
                f(&mut value);
                self.set_lasttx(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn suspended(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_suspended(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_suspended_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspended();
                f(&mut value);
                self.set_suspended(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn lastrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_lastrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_lastrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx();
                f(&mut value);
                self.set_lastrx(value)
            }

            pub fn lasttx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_lasttx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_lasttx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx();
                f(&mut value);
                self.set_lasttx(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_suspended(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_lastrx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_lasttx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn suspended(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_suspended(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_suspended_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspended();
                f(&mut value);
                self.set_suspended(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn lastrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_lastrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_lastrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lastrx();
                f(&mut value);
                self.set_lastrx(value)
            }

            pub fn lasttx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_lasttx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_lasttx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lasttx();
                f(&mut value);
                self.set_lasttx(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_suspended(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_lastrx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_lasttx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }
        }
    }

    pub mod errorsrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSRC {
            raw: RawRegister<u32>,
        }

        impl ERRORSRC {
            pub fn write_with<F: Fn(&mut ERRORSRC_VALUE) -> &mut ERRORSRC_VALUE>(&mut self, f: F) {
                let mut v = ERRORSRC_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSRC {
            type Value = ERRORSRC_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSRC_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSRC {
            type Value = ERRORSRC_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_VALUE {
            raw: u32,
        }

        impl ERRORSRC_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overrun(&self) -> OVERRUN_FIELD {
                let raw = self.raw;
                OVERRUN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overrun(&mut self, value: OVERRUN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overrun_with<F: Fn(&mut OVERRUN_FIELD) -> &mut OVERRUN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overrun();
                f(&mut value);
                self.set_overrun(value)
            }

            pub fn anack(&self) -> ANACK_FIELD {
                let raw = self.raw;
                ANACK_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_anack(&mut self, value: ANACK_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_anack_with<F: Fn(&mut ANACK_FIELD) -> &mut ANACK_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.anack();
                f(&mut value);
                self.set_anack(value)
            }

            pub fn dnack(&self) -> DNACK_FIELD {
                let raw = self.raw;
                DNACK_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_dnack(&mut self, value: DNACK_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_dnack_with<F: Fn(&mut DNACK_FIELD) -> &mut DNACK_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dnack();
                f(&mut value);
                self.set_dnack(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERRUN_FIELD u32 =>
                        // Error did not occur
                        NotReceived = 0,
        // Error occurred
                        Received = 1

                    );

        impl OVERRUN_FIELD {
            pub fn is_notreceived(&self) -> bool {
                *self == Self::NotReceived
            }

            pub fn set_notreceived(&mut self) -> &mut Self {
                *self = Self::NotReceived;
                self
            }

            pub fn is_received(&self) -> bool {
                *self == Self::Received
            }

            pub fn set_received(&mut self) -> &mut Self {
                *self = Self::Received;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ANACK_FIELD u32 =>
                        // Error did not occur
                        NotReceived = 0,
        // Error occurred
                        Received = 1

                    );

        impl ANACK_FIELD {
            pub fn is_notreceived(&self) -> bool {
                *self == Self::NotReceived
            }

            pub fn set_notreceived(&mut self) -> &mut Self {
                *self = Self::NotReceived;
                self
            }

            pub fn is_received(&self) -> bool {
                *self == Self::Received
            }

            pub fn set_received(&mut self) -> &mut Self {
                *self = Self::Received;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DNACK_FIELD u32 =>
                        // Error did not occur
                        NotReceived = 0,
        // Error occurred
                        Received = 1

                    );

        impl DNACK_FIELD {
            pub fn is_notreceived(&self) -> bool {
                *self == Self::NotReceived
            }

            pub fn set_notreceived(&mut self) -> &mut Self {
                *self = Self::NotReceived;
                self
            }

            pub fn is_received(&self) -> bool {
                *self == Self::Received
            }

            pub fn set_received(&mut self) -> &mut Self {
                *self = Self::Received;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable TWIM
                        Disabled = 0,
        // Enable TWIM
                        Enabled = 6

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCL signal
            pub scl: PinSelectRegister,
            /// Pin select for SDA signal
            pub sda: PinSelectRegister,
        }
    }

    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FREQUENCY {
            raw: RawRegister<u32>,
        }

        impl FREQUENCY {
            pub fn write_k100(&mut self) {
                self.write(FREQUENCY_FIELD::K100)
            }

            pub fn write_k250(&mut self) {
                self.write(FREQUENCY_FIELD::K250)
            }

            pub fn write_k400(&mut self) {
                self.write(FREQUENCY_FIELD::K400)
            }
        }

        impl RegisterRead for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                FREQUENCY_FIELD::from_value((raw & 0xffffffff) >> 0)
            }
        }

        impl RegisterWrite for FREQUENCY {
            type Value = FREQUENCY_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FREQUENCY_FIELD u32 =>
                        // 100 kbps
                        K100 = 26738688,
        // 250 kbps
                        K250 = 67108864,
        // 400 kbps
                        K400 = 104857600

                    );

        impl FREQUENCY_FIELD {
            pub fn is_k100(&self) -> bool {
                *self == Self::K100
            }

            pub fn set_k100(&mut self) -> &mut Self {
                *self = Self::K100;
                self
            }

            pub fn is_k250(&self) -> bool {
                *self == Self::K250
            }

            pub fn set_k250(&mut self) -> &mut Self {
                *self = Self::K250;
                self
            }

            pub fn is_k400(&self) -> bool {
                *self == Self::K400
            }

            pub fn set_k400(&mut self) -> &mut Self {
                *self = Self::K400;
                self
            }
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// RXD EasyDMA channel
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in receive buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000007) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// TXD EasyDMA channel
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in transmit buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000007) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod address {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ADDRESS {
            raw: RawRegister<u32>,
        }

        impl ADDRESS {}

        impl RegisterRead for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }

        impl RegisterWrite for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000007f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod twis0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWIS0 {
        _hidden: (),
    }

    impl TWIS0 {
        const BASE_ADDRESS: u32 = 0x40003000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWIS0 {
        type Target = TWIS0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWIS0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct TWIS0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 20],
        /// Stop TWI transaction
        pub tasks_stop: TaskRegister,
        _padding_24: [u8; 4],
        /// Suspend TWI transaction
        pub tasks_suspend: TaskRegister,
        /// Resume TWI transaction
        pub tasks_resume: TaskRegister,
        _padding_36: [u8; 12],
        /// Prepare the TWI slave to respond to a write command
        pub tasks_preparerx: TaskRegister,
        /// Prepare the TWI slave to respond to a read command
        pub tasks_preparetx: TaskRegister,
        _padding_56: [u8; 204],
        /// TWI stopped
        pub events_stopped: EventRegister,
        _padding_264: [u8; 28],
        /// TWI error
        pub events_error: EventRegister,
        _padding_296: [u8; 36],
        /// Receive sequence started
        pub events_rxstarted: EventRegister,
        /// Transmit sequence started
        pub events_txstarted: EventRegister,
        _padding_340: [u8; 16],
        /// Write command received
        pub events_write: EventRegister,
        /// Read command received
        pub events_read: EventRegister,
        _padding_364: [u8; 148],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 452],
        /// Error source
        pub errorsrc: errorsrc::ERRORSRC,
        /// Status register indicating which address had a match
        pub r#match: r#match::MATCH,
        _padding_1240: [u8; 40],
        /// Enable TWIS
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 4],
        pub psel: psel::PSEL,
        _padding_1296: [u8; 36],
        pub rxd: rxd::RXD,
        pub txd: txd::TXD,
        _padding_1364: [u8; 52],
        /// Description collection: TWI slave address n
        pub address: [address::ADDRESS; 2],
        _padding_1424: [u8; 4],
        /// Configuration register for the address match mechanism
        pub config: config::CONFIG,
        _padding_1432: [u8; 40],
        /// Over-read character. Character sent out in case of an over-read of
        /// the transmit buffer.
        pub orc: orc::ORC,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn write_suspend(&self) -> WRITE_SUSPEND_FIELD {
                let raw = self.raw;
                WRITE_SUSPEND_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_write_suspend(&mut self, value: WRITE_SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_write_suspend_with<
                F: Fn(&mut WRITE_SUSPEND_FIELD) -> &mut WRITE_SUSPEND_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.write_suspend();
                f(&mut value);
                self.set_write_suspend(value)
            }

            pub fn read_suspend(&self) -> READ_SUSPEND_FIELD {
                let raw = self.raw;
                READ_SUSPEND_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_read_suspend(&mut self, value: READ_SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_read_suspend_with<
                F: Fn(&mut READ_SUSPEND_FIELD) -> &mut READ_SUSPEND_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.read_suspend();
                f(&mut value);
                self.set_read_suspend(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] WRITE_SUSPEND_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl WRITE_SUSPEND_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READ_SUSPEND_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READ_SUSPEND_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn write(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_write(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_write_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.write();
                f(&mut value);
                self.set_write(value)
            }

            pub fn read(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_read(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_read_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.read();
                f(&mut value);
                self.set_read(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn write(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_write(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_write_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.write();
                f(&mut value);
                self.set_write(value)
            }

            pub fn read(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_read(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_read_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.read();
                f(&mut value);
                self.set_read(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_write(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_read(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_rxstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_rxstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxstarted();
                f(&mut value);
                self.set_rxstarted(value)
            }

            pub fn txstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_txstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_txstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txstarted();
                f(&mut value);
                self.set_txstarted(value)
            }

            pub fn write(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_write(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_write_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.write();
                f(&mut value);
                self.set_write(value)
            }

            pub fn read(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_read(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_read_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.read();
                f(&mut value);
                self.set_read(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_rxstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_txstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_write(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_read(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }
        }
    }

    pub mod errorsrc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSRC {
            raw: RawRegister<u32>,
        }

        impl ERRORSRC {
            pub fn write_with<F: Fn(&mut ERRORSRC_VALUE) -> &mut ERRORSRC_VALUE>(&mut self, f: F) {
                let mut v = ERRORSRC_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSRC {
            type Value = ERRORSRC_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSRC_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSRC {
            type Value = ERRORSRC_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSRC_VALUE {
            raw: u32,
        }

        impl ERRORSRC_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn overflow(&self) -> OVERFLOW_FIELD {
                let raw = self.raw;
                OVERFLOW_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_overflow(&mut self, value: OVERFLOW_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_overflow_with<F: Fn(&mut OVERFLOW_FIELD) -> &mut OVERFLOW_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overflow();
                f(&mut value);
                self.set_overflow(value)
            }

            pub fn dnack(&self) -> DNACK_FIELD {
                let raw = self.raw;
                DNACK_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_dnack(&mut self, value: DNACK_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_dnack_with<F: Fn(&mut DNACK_FIELD) -> &mut DNACK_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dnack();
                f(&mut value);
                self.set_dnack(value)
            }

            pub fn overread(&self) -> OVERREAD_FIELD {
                let raw = self.raw;
                OVERREAD_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_overread(&mut self, value: OVERREAD_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_overread_with<F: Fn(&mut OVERREAD_FIELD) -> &mut OVERREAD_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.overread();
                f(&mut value);
                self.set_overread(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERFLOW_FIELD u32 =>
                        // Error did not occur
                        NotDetected = 0,
        // Error occurred
                        Detected = 1

                    );

        impl OVERFLOW_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DNACK_FIELD u32 =>
                        // Error did not occur
                        NotReceived = 0,
        // Error occurred
                        Received = 1

                    );

        impl DNACK_FIELD {
            pub fn is_notreceived(&self) -> bool {
                *self == Self::NotReceived
            }

            pub fn set_notreceived(&mut self) -> &mut Self {
                *self = Self::NotReceived;
                self
            }

            pub fn is_received(&self) -> bool {
                *self == Self::Received
            }

            pub fn set_received(&mut self) -> &mut Self {
                *self = Self::Received;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERREAD_FIELD u32 =>
                        // Error did not occur
                        NotDetected = 0,
        // Error occurred
                        Detected = 1

                    );

        impl OVERREAD_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }
    }

    pub mod r#match {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MATCH {
            raw: RawRegister<u32>,
        }

        impl MATCH {}

        impl RegisterRead for MATCH {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000001) >> 0
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable TWIS
                        Disabled = 0,
        // Enable TWIS
                        Enabled = 9

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for SCL signal
            pub scl: PinSelectRegister,
            /// Pin select for SDA signal
            pub sda: PinSelectRegister,
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// RXD EasyDMA channel
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// RXD Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in RXD buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last RXD transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// TXD EasyDMA channel
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// TXD Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes in TXD buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last TXD transaction
            pub amount: amount::AMOUNT,
            /// EasyDMA list type
            pub list: list::LIST,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000ffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000ffff) >> 0
                }
            }
        }

        pub mod list {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIST {
                raw: RawRegister<u32>,
            }

            impl LIST {
                pub fn write_disabled(&mut self) {
                    self.write(LIST_FIELD::Disabled)
                }

                pub fn write_arraylist(&mut self) {
                    self.write(LIST_FIELD::ArrayList)
                }
            }

            impl RegisterRead for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    LIST_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for LIST {
                type Value = LIST_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] LIST_FIELD u32 =>
                            // Disable EasyDMA list
                            Disabled = 0,
            // Use array list
                            ArrayList = 1

                        );

            impl LIST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_arraylist(&self) -> bool {
                    *self == Self::ArrayList
                }

                pub fn set_arraylist(&mut self) -> &mut Self {
                    *self = Self::ArrayList;
                    self
                }
            }
        }
    }

    pub mod address {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ADDRESS {
            raw: RawRegister<u32>,
        }

        impl ADDRESS {}

        impl RegisterRead for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000007f) >> 0
            }
        }

        impl RegisterWrite for ADDRESS {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000007f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn address0(&self) -> ADDRESS0_FIELD {
                let raw = self.raw;
                ADDRESS0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_address0(&mut self, value: ADDRESS0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_address0_with<F: Fn(&mut ADDRESS0_FIELD) -> &mut ADDRESS0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address0();
                f(&mut value);
                self.set_address0(value)
            }

            pub fn address1(&self) -> ADDRESS1_FIELD {
                let raw = self.raw;
                ADDRESS1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_address1(&mut self, value: ADDRESS1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_address1_with<F: Fn(&mut ADDRESS1_FIELD) -> &mut ADDRESS1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.address1();
                f(&mut value);
                self.set_address1(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDRESS0_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ADDRESS0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ADDRESS1_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl ADDRESS1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod orc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ORC {
            raw: RawRegister<u32>,
        }

        impl ORC {}

        impl RegisterRead for ORC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for ORC {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod spi1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPI1 {
        _hidden: (),
    }

    impl SPI1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPI1 {
        type Target = spi0::SPI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPI1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spim1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIM1 {
        _hidden: (),
    }

    impl SPIM1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIM1 {
        type Target = spim0::SPIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIM1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spis1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIS1 {
        _hidden: (),
    }

    impl SPIS1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIS1 {
        type Target = spis0::SPIS0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIS1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod twi1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWI1 {
        _hidden: (),
    }

    impl TWI1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWI1 {
        type Target = twi0::TWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWI1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod twim1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWIM1 {
        _hidden: (),
    }

    impl TWIM1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWIM1 {
        type Target = twim0::TWIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWIM1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod twis1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TWIS1 {
        _hidden: (),
    }

    impl TWIS1 {
        const BASE_ADDRESS: u32 = 0x40004000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TWIS1 {
        type Target = twis0::TWIS0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TWIS1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod nfct {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct NFCT {
        _hidden: (),
    }

    impl NFCT {
        const BASE_ADDRESS: u32 = 0x40005000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for NFCT {
        type Target = NFCT_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for NFCT {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct NFCT_REGISTERS {
        _hidden: (),
        /// Activate NFCT peripheral for incoming and outgoing frames, change
        /// state to activated
        pub tasks_activate: TaskRegister,
        /// Disable NFCT peripheral
        pub tasks_disable: TaskRegister,
        /// Enable NFC sense field mode, change state to sense mode
        pub tasks_sense: TaskRegister,
        /// Start transmission of an outgoing frame, change state to transmit
        pub tasks_starttx: TaskRegister,
        _padding_16: [u8; 12],
        /// Initializes the EasyDMA for receive.
        pub tasks_enablerxdata: TaskRegister,
        _padding_32: [u8; 4],
        /// Force state machine to IDLE state
        pub tasks_goidle: TaskRegister,
        /// Force state machine to SLEEP_A state
        pub tasks_gosleep: TaskRegister,
        _padding_44: [u8; 212],
        /// The NFCT peripheral is ready to receive and send frames
        pub events_ready: EventRegister,
        /// Remote NFC field detected
        pub events_fielddetected: EventRegister,
        /// Remote NFC field lost
        pub events_fieldlost: EventRegister,
        /// Marks the start of the first symbol of a transmitted frame
        pub events_txframestart: EventRegister,
        /// Marks the end of the last transmitted on-air symbol of a frame
        pub events_txframeend: EventRegister,
        /// Marks the end of the first symbol of a received frame
        pub events_rxframestart: EventRegister,
        /// Received data has been checked (CRC, parity) and transferred to RAM,
        /// and EasyDMA has ended accessing the RX buffer
        pub events_rxframeend: EventRegister,
        /// NFC error reported. The ERRORSTATUS register contains details on the
        /// source of the error.
        pub events_error: EventRegister,
        _padding_288: [u8; 8],
        /// NFC RX frame error reported. The FRAMESTATUS.RX register contains
        /// details on the source of the error.
        pub events_rxerror: EventRegister,
        /// RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
        pub events_endrx: EventRegister,
        /// Transmission of data in RAM has ended, and EasyDMA has ended
        /// accessing the TX buffer
        pub events_endtx: EventRegister,
        _padding_308: [u8; 4],
        /// Auto collision resolution process has started
        pub events_autocolresstarted: EventRegister,
        _padding_316: [u8; 12],
        /// NFC auto collision resolution error reported.
        pub events_collision: EventRegister,
        /// NFC auto collision resolution successfully completed
        pub events_selected: EventRegister,
        /// EasyDMA is ready to receive or send frames.
        pub events_started: EventRegister,
        _padding_340: [u8; 172],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 248],
        /// NFC Error Status register
        pub errorstatus: errorstatus::ERRORSTATUS,
        _padding_1032: [u8; 4],
        pub framestatus: framestatus::FRAMESTATUS,
        /// NfcTag state register
        pub nfctagstate: nfctagstate::NFCTAGSTATE,
        _padding_1044: [u8; 12],
        /// Sleep state during automatic collision resolution
        pub sleepstate: sleepstate::SLEEPSTATE,
        _padding_1060: [u8; 24],
        /// Indicates the presence or not of a valid field
        pub fieldpresent: fieldpresent::FIELDPRESENT,
        _padding_1088: [u8; 196],
        /// Minimum frame delay
        pub framedelaymin: framedelaymin::FRAMEDELAYMIN,
        /// Maximum frame delay
        pub framedelaymax: framedelaymax::FRAMEDELAYMAX,
        /// Configuration register for the Frame Delay Timer
        pub framedelaymode: framedelaymode::FRAMEDELAYMODE,
        /// Packet pointer for TXD and RXD data storage in Data RAM
        pub packetptr: packetptr::PACKETPTR,
        /// Size of the RAM buffer allocated to TXD and RXD data storage each
        pub maxlen: maxlen::MAXLEN,
        pub txd: txd::TXD,
        pub rxd: rxd::RXD,
        _padding_1320: [u8; 4],
        /// Enables the modulation output to a GPIO pin which can be connected
        /// to a second external antenna.
        pub modulationctrl: modulationctrl::MODULATIONCTRL,
        _padding_1328: [u8; 8],
        /// Pin select for Modulation control.
        pub modulationpsel: modulationpsel::MODULATIONPSEL,
        _padding_1340: [u8; 84],
        /// Last NFCID1 part (4, 7 or 10 bytes ID)
        pub nfcid1_last: nfcid1_last::NFCID1_LAST,
        /// Second last NFCID1 part (7 or 10 bytes ID)
        pub nfcid1_2nd_last: nfcid1_2nd_last::NFCID1_2ND_LAST,
        /// Third last NFCID1 part (10 bytes ID)
        pub nfcid1_3rd_last: nfcid1_3rd_last::NFCID1_3RD_LAST,
        /// Controls the auto collision resolution function. This setting must
        /// be done before the NFCT peripheral is activated.
        pub autocolresconfig: autocolresconfig::AUTOCOLRESCONFIG,
        /// NFC-A SENS_RES auto-response settings
        pub sensres: sensres::SENSRES,
        /// NFC-A SEL_RES auto-response settings
        pub selres: selres::SELRES,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn fielddetected_activate(&self) -> FIELDDETECTED_ACTIVATE_FIELD {
                let raw = self.raw;
                FIELDDETECTED_ACTIVATE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_fielddetected_activate(
                &mut self,
                value: FIELDDETECTED_ACTIVATE_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_fielddetected_activate_with<
                F: Fn(&mut FIELDDETECTED_ACTIVATE_FIELD) -> &mut FIELDDETECTED_ACTIVATE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fielddetected_activate();
                f(&mut value);
                self.set_fielddetected_activate(value)
            }

            pub fn fieldlost_sense(&self) -> FIELDLOST_SENSE_FIELD {
                let raw = self.raw;
                FIELDLOST_SENSE_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_fieldlost_sense(&mut self, value: FIELDLOST_SENSE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fieldlost_sense_with<
                F: Fn(&mut FIELDLOST_SENSE_FIELD) -> &mut FIELDLOST_SENSE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fieldlost_sense();
                f(&mut value);
                self.set_fieldlost_sense(value)
            }

            pub fn txframeend_enablerxdata(&self) -> TXFRAMEEND_ENABLERXDATA_FIELD {
                let raw = self.raw;
                TXFRAMEEND_ENABLERXDATA_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_txframeend_enablerxdata(
                &mut self,
                value: TXFRAMEEND_ENABLERXDATA_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_txframeend_enablerxdata_with<
                F: Fn(&mut TXFRAMEEND_ENABLERXDATA_FIELD) -> &mut TXFRAMEEND_ENABLERXDATA_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframeend_enablerxdata();
                f(&mut value);
                self.set_txframeend_enablerxdata(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FIELDDETECTED_ACTIVATE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl FIELDDETECTED_ACTIVATE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FIELDLOST_SENSE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl FIELDLOST_SENSE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TXFRAMEEND_ENABLERXDATA_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl TXFRAMEEND_ENABLERXDATA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn fielddetected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_fielddetected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fielddetected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fielddetected();
                f(&mut value);
                self.set_fielddetected(value)
            }

            pub fn fieldlost(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_fieldlost(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_fieldlost_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fieldlost();
                f(&mut value);
                self.set_fieldlost(value)
            }

            pub fn txframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_txframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_txframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframestart();
                f(&mut value);
                self.set_txframestart(value)
            }

            pub fn txframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_txframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_txframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframeend();
                f(&mut value);
                self.set_txframeend(value)
            }

            pub fn rxframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rxframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rxframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframestart();
                f(&mut value);
                self.set_rxframestart(value)
            }

            pub fn rxframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rxframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rxframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframeend();
                f(&mut value);
                self.set_rxframeend(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxerror(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_rxerror(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_rxerror_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxerror();
                f(&mut value);
                self.set_rxerror(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn autocolresstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_autocolresstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_autocolresstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.autocolresstarted();
                f(&mut value);
                self.set_autocolresstarted(value)
            }

            pub fn collision(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_collision(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_collision_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.collision();
                f(&mut value);
                self.set_collision(value)
            }

            pub fn selected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_selected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_selected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.selected();
                f(&mut value);
                self.set_selected(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn fielddetected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_fielddetected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fielddetected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fielddetected();
                f(&mut value);
                self.set_fielddetected(value)
            }

            pub fn fieldlost(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_fieldlost(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_fieldlost_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fieldlost();
                f(&mut value);
                self.set_fieldlost(value)
            }

            pub fn txframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_txframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_txframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframestart();
                f(&mut value);
                self.set_txframestart(value)
            }

            pub fn txframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_txframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_txframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframeend();
                f(&mut value);
                self.set_txframeend(value)
            }

            pub fn rxframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rxframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rxframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframestart();
                f(&mut value);
                self.set_rxframestart(value)
            }

            pub fn rxframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rxframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rxframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframeend();
                f(&mut value);
                self.set_rxframeend(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxerror(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_rxerror(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_rxerror_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxerror();
                f(&mut value);
                self.set_rxerror(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn autocolresstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_autocolresstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_autocolresstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.autocolresstarted();
                f(&mut value);
                self.set_autocolresstarted(value)
            }

            pub fn collision(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_collision(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_collision_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.collision();
                f(&mut value);
                self.set_collision(value)
            }

            pub fn selected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_selected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_selected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.selected();
                f(&mut value);
                self.set_selected(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_fielddetected(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fieldlost(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txframestart(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_txframeend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rxframestart(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rxframeend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rxerror(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_autocolresstarted(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_collision(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_selected(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn fielddetected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_fielddetected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fielddetected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fielddetected();
                f(&mut value);
                self.set_fielddetected(value)
            }

            pub fn fieldlost(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_fieldlost(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_fieldlost_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fieldlost();
                f(&mut value);
                self.set_fieldlost(value)
            }

            pub fn txframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_txframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_txframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframestart();
                f(&mut value);
                self.set_txframestart(value)
            }

            pub fn txframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_txframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_txframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txframeend();
                f(&mut value);
                self.set_txframeend(value)
            }

            pub fn rxframestart(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rxframestart(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rxframestart_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframestart();
                f(&mut value);
                self.set_rxframestart(value)
            }

            pub fn rxframeend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rxframeend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rxframeend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxframeend();
                f(&mut value);
                self.set_rxframeend(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }

            pub fn rxerror(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_rxerror(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_rxerror_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxerror();
                f(&mut value);
                self.set_rxerror(value)
            }

            pub fn endrx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endrx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endrx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endrx();
                f(&mut value);
                self.set_endrx(value)
            }

            pub fn endtx(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endtx(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endtx_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endtx();
                f(&mut value);
                self.set_endtx(value)
            }

            pub fn autocolresstarted(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_autocolresstarted(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_autocolresstarted_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.autocolresstarted();
                f(&mut value);
                self.set_autocolresstarted(value)
            }

            pub fn collision(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_collision(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_collision_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.collision();
                f(&mut value);
                self.set_collision(value)
            }

            pub fn selected(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_selected(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_selected_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.selected();
                f(&mut value);
                self.set_selected(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_fielddetected(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_fieldlost(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txframestart(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_txframeend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rxframestart(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rxframeend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rxerror(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_endrx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endtx(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_autocolresstarted(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_collision(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_selected(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }
        }
    }

    pub mod errorstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERRORSTATUS {
            raw: RawRegister<u32>,
        }

        impl ERRORSTATUS {
            pub fn write_with<F: Fn(&mut ERRORSTATUS_VALUE) -> &mut ERRORSTATUS_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ERRORSTATUS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERRORSTATUS {
            type Value = ERRORSTATUS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERRORSTATUS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERRORSTATUS {
            type Value = ERRORSTATUS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERRORSTATUS_VALUE {
            raw: u32,
        }

        impl ERRORSTATUS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn framedelaytimeout(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000001) >> 0
            }

            pub fn set_framedelaytimeout(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod framestatus {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct FRAMESTATUS {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Result of last incoming frame
            pub rx: rx::RX,
        }

        pub mod rx {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct RX {
                raw: RawRegister<u32>,
            }

            impl RX {
                pub fn write_with<F: Fn(&mut RX_VALUE) -> &mut RX_VALUE>(&mut self, f: F) {
                    let mut v = RX_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for RX {
                type Value = RX_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    RX_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for RX {
                type Value = RX_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct RX_VALUE {
                raw: u32,
            }

            impl RX_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn crcerror(&self) -> CRCERROR_FIELD {
                    let raw = self.raw;
                    CRCERROR_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_crcerror(&mut self, value: CRCERROR_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_crcerror_with<F: Fn(&mut CRCERROR_FIELD) -> &mut CRCERROR_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.crcerror();
                    f(&mut value);
                    self.set_crcerror(value)
                }

                pub fn paritystatus(&self) -> PARITYSTATUS_FIELD {
                    let raw = self.raw;
                    PARITYSTATUS_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_paritystatus(&mut self, value: PARITYSTATUS_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_paritystatus_with<
                    F: Fn(&mut PARITYSTATUS_FIELD) -> &mut PARITYSTATUS_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.paritystatus();
                    f(&mut value);
                    self.set_paritystatus(value)
                }

                pub fn overrun(&self) -> OVERRUN_FIELD {
                    let raw = self.raw;
                    OVERRUN_FIELD::from_value((raw & 0x00000008) >> 3)
                }

                pub fn set_overrun(&mut self, value: OVERRUN_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_overrun_with<F: Fn(&mut OVERRUN_FIELD) -> &mut OVERRUN_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.overrun();
                    f(&mut value);
                    self.set_overrun(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CRCERROR_FIELD u32 =>
                            // Valid CRC detected
                            CRCCorrect = 0,
            // CRC received does not match local check
                            CRCError = 1

                        );

            impl CRCERROR_FIELD {
                pub fn is_crccorrect(&self) -> bool {
                    *self == Self::CRCCorrect
                }

                pub fn set_crccorrect(&mut self) -> &mut Self {
                    *self = Self::CRCCorrect;
                    self
                }

                pub fn is_crcerror(&self) -> bool {
                    *self == Self::CRCError
                }

                pub fn set_crcerror(&mut self) -> &mut Self {
                    *self = Self::CRCError;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITYSTATUS_FIELD u32 =>
                            // Frame received with parity OK
                            ParityOK = 0,
            // Frame received with parity error
                            ParityError = 1

                        );

            impl PARITYSTATUS_FIELD {
                pub fn is_parityok(&self) -> bool {
                    *self == Self::ParityOK
                }

                pub fn set_parityok(&mut self) -> &mut Self {
                    *self = Self::ParityOK;
                    self
                }

                pub fn is_parityerror(&self) -> bool {
                    *self == Self::ParityError
                }

                pub fn set_parityerror(&mut self) -> &mut Self {
                    *self = Self::ParityError;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERRUN_FIELD u32 =>
                            // No overrun detected
                            NoOverrun = 0,
            // Overrun error
                            Overrun = 1

                        );

            impl OVERRUN_FIELD {
                pub fn is_nooverrun(&self) -> bool {
                    *self == Self::NoOverrun
                }

                pub fn set_nooverrun(&mut self) -> &mut Self {
                    *self = Self::NoOverrun;
                    self
                }

                pub fn is_overrun(&self) -> bool {
                    *self == Self::Overrun
                }

                pub fn set_overrun(&mut self) -> &mut Self {
                    *self = Self::Overrun;
                    self
                }
            }
        }
    }

    pub mod nfctagstate {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NFCTAGSTATE {
            raw: RawRegister<u32>,
        }

        impl NFCTAGSTATE {}

        impl RegisterRead for NFCTAGSTATE {
            type Value = NFCTAGSTATE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                NFCTAGSTATE_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] NFCTAGSTATE_FIELD u32 =>
                        // Disabled or sense
                        Disabled = 0,
        // RampUp
                        RampUp = 2,
        // Idle
                        Idle = 3,
        // Receive
                        Receive = 4,
        // FrameDelay
                        FrameDelay = 5,
        // Transmit
                        Transmit = 6

                    );

        impl NFCTAGSTATE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_rampup(&self) -> bool {
                *self == Self::RampUp
            }

            pub fn set_rampup(&mut self) -> &mut Self {
                *self = Self::RampUp;
                self
            }

            pub fn is_idle(&self) -> bool {
                *self == Self::Idle
            }

            pub fn set_idle(&mut self) -> &mut Self {
                *self = Self::Idle;
                self
            }

            pub fn is_receive(&self) -> bool {
                *self == Self::Receive
            }

            pub fn set_receive(&mut self) -> &mut Self {
                *self = Self::Receive;
                self
            }

            pub fn is_framedelay(&self) -> bool {
                *self == Self::FrameDelay
            }

            pub fn set_framedelay(&mut self) -> &mut Self {
                *self = Self::FrameDelay;
                self
            }

            pub fn is_transmit(&self) -> bool {
                *self == Self::Transmit
            }

            pub fn set_transmit(&mut self) -> &mut Self {
                *self = Self::Transmit;
                self
            }
        }
    }

    pub mod sleepstate {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SLEEPSTATE {
            raw: RawRegister<u32>,
        }

        impl SLEEPSTATE {}

        impl RegisterRead for SLEEPSTATE {
            type Value = SLEEPSTATE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                SLEEPSTATE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SLEEPSTATE_FIELD u32 =>
                        // State is IDLE.
                        Idle = 0,
        // State is SLEEP_A.
                        SleepA = 1

                    );

        impl SLEEPSTATE_FIELD {
            pub fn is_idle(&self) -> bool {
                *self == Self::Idle
            }

            pub fn set_idle(&mut self) -> &mut Self {
                *self = Self::Idle;
                self
            }

            pub fn is_sleepa(&self) -> bool {
                *self == Self::SleepA
            }

            pub fn set_sleepa(&mut self) -> &mut Self {
                *self = Self::SleepA;
                self
            }
        }
    }

    pub mod fieldpresent {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FIELDPRESENT {
            raw: RawRegister<u32>,
        }

        impl FIELDPRESENT {}

        impl RegisterRead for FIELDPRESENT {
            type Value = FIELDPRESENT_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                FIELDPRESENT_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct FIELDPRESENT_READ_VALUE {
            raw: u32,
        }

        impl FIELDPRESENT_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn fieldpresent(&self) -> FIELDPRESENT_FIELD {
                let raw = self.raw;
                FIELDPRESENT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_fieldpresent(&mut self, value: FIELDPRESENT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_fieldpresent_with<
                F: Fn(&mut FIELDPRESENT_FIELD) -> &mut FIELDPRESENT_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.fieldpresent();
                f(&mut value);
                self.set_fieldpresent(value)
            }

            pub fn lockdetect(&self) -> LOCKDETECT_FIELD {
                let raw = self.raw;
                LOCKDETECT_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_lockdetect(&mut self, value: LOCKDETECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_lockdetect_with<F: Fn(&mut LOCKDETECT_FIELD) -> &mut LOCKDETECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.lockdetect();
                f(&mut value);
                self.set_lockdetect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FIELDPRESENT_FIELD u32 =>
                        // No valid field detected
                        NoField = 0,
        // Valid field detected
                        FieldPresent = 1

                    );

        impl FIELDPRESENT_FIELD {
            pub fn is_nofield(&self) -> bool {
                *self == Self::NoField
            }

            pub fn set_nofield(&mut self) -> &mut Self {
                *self = Self::NoField;
                self
            }

            pub fn is_fieldpresent(&self) -> bool {
                *self == Self::FieldPresent
            }

            pub fn set_fieldpresent(&mut self) -> &mut Self {
                *self = Self::FieldPresent;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOCKDETECT_FIELD u32 =>
                        // Not locked to field
                        NotLocked = 0,
        // Locked to field
                        Locked = 1

                    );

        impl LOCKDETECT_FIELD {
            pub fn is_notlocked(&self) -> bool {
                *self == Self::NotLocked
            }

            pub fn set_notlocked(&mut self) -> &mut Self {
                *self = Self::NotLocked;
                self
            }

            pub fn is_locked(&self) -> bool {
                *self == Self::Locked
            }

            pub fn set_locked(&mut self) -> &mut Self {
                *self = Self::Locked;
                self
            }
        }
    }

    pub mod framedelaymin {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FRAMEDELAYMIN {
            raw: RawRegister<u32>,
        }

        impl FRAMEDELAYMIN {}

        impl RegisterRead for FRAMEDELAYMIN {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000ffff) >> 0
            }
        }

        impl RegisterWrite for FRAMEDELAYMIN {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000ffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod framedelaymax {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FRAMEDELAYMAX {
            raw: RawRegister<u32>,
        }

        impl FRAMEDELAYMAX {}

        impl RegisterRead for FRAMEDELAYMAX {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000fffff) >> 0
            }
        }

        impl RegisterWrite for FRAMEDELAYMAX {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000fffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod framedelaymode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FRAMEDELAYMODE {
            raw: RawRegister<u32>,
        }

        impl FRAMEDELAYMODE {
            pub fn write_freerun(&mut self) {
                self.write(FRAMEDELAYMODE_FIELD::FreeRun)
            }

            pub fn write_window(&mut self) {
                self.write(FRAMEDELAYMODE_FIELD::Window)
            }

            pub fn write_exactval(&mut self) {
                self.write(FRAMEDELAYMODE_FIELD::ExactVal)
            }

            pub fn write_windowgrid(&mut self) {
                self.write(FRAMEDELAYMODE_FIELD::WindowGrid)
            }
        }

        impl RegisterRead for FRAMEDELAYMODE {
            type Value = FRAMEDELAYMODE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                FRAMEDELAYMODE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for FRAMEDELAYMODE {
            type Value = FRAMEDELAYMODE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FRAMEDELAYMODE_FIELD u32 =>
                        // Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout.
                        FreeRun = 0,
        // Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX
                        Window = 1,
        // Frame is transmitted exactly at FRAMEDELAYMAX
                        ExactVal = 2,
        // Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX
                        WindowGrid = 3

                    );

        impl FRAMEDELAYMODE_FIELD {
            pub fn is_freerun(&self) -> bool {
                *self == Self::FreeRun
            }

            pub fn set_freerun(&mut self) -> &mut Self {
                *self = Self::FreeRun;
                self
            }

            pub fn is_window(&self) -> bool {
                *self == Self::Window
            }

            pub fn set_window(&mut self) -> &mut Self {
                *self = Self::Window;
                self
            }

            pub fn is_exactval(&self) -> bool {
                *self == Self::ExactVal
            }

            pub fn set_exactval(&mut self) -> &mut Self {
                *self = Self::ExactVal;
                self
            }

            pub fn is_windowgrid(&self) -> bool {
                *self == Self::WindowGrid
            }

            pub fn set_windowgrid(&mut self) -> &mut Self {
                *self = Self::WindowGrid;
                self
            }
        }
    }

    pub mod packetptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PACKETPTR {
            raw: RawRegister<u32>,
        }

        impl PACKETPTR {
            pub fn write_with<F: Fn(&mut PACKETPTR_VALUE) -> &mut PACKETPTR_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = PACKETPTR_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PACKETPTR {
            type Value = PACKETPTR_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PACKETPTR_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PACKETPTR {
            type Value = PACKETPTR_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PACKETPTR_VALUE {
            raw: u32,
        }

        impl PACKETPTR_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ptr(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xffffffff) >> 0
            }

            pub fn set_ptr(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xffffffff) | (value << 0);
                self
            }
        }
    }

    pub mod maxlen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MAXLEN {
            raw: RawRegister<u32>,
        }

        impl MAXLEN {}

        impl RegisterRead for MAXLEN {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000001ff) >> 0
            }
        }

        impl RegisterWrite for MAXLEN {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000001ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Configuration of outgoing frames
            pub frameconfig: frameconfig::FRAMECONFIG,
            /// Size of outgoing frame
            pub amount: amount::AMOUNT,
        }

        pub mod frameconfig {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct FRAMECONFIG {
                raw: RawRegister<u32>,
            }

            impl FRAMECONFIG {
                pub fn write_with<F: Fn(&mut FRAMECONFIG_VALUE) -> &mut FRAMECONFIG_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = FRAMECONFIG_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for FRAMECONFIG {
                type Value = FRAMECONFIG_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    FRAMECONFIG_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for FRAMECONFIG {
                type Value = FRAMECONFIG_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct FRAMECONFIG_VALUE {
                raw: u32,
            }

            impl FRAMECONFIG_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn parity(&self) -> PARITY_FIELD {
                    let raw = self.raw;
                    PARITY_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_parity(&mut self, value: PARITY_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_parity_with<F: Fn(&mut PARITY_FIELD) -> &mut PARITY_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.parity();
                    f(&mut value);
                    self.set_parity(value)
                }

                pub fn discardmode(&self) -> DISCARDMODE_FIELD {
                    let raw = self.raw;
                    DISCARDMODE_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_discardmode(&mut self, value: DISCARDMODE_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_discardmode_with<
                    F: Fn(&mut DISCARDMODE_FIELD) -> &mut DISCARDMODE_FIELD,
                >(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.discardmode();
                    f(&mut value);
                    self.set_discardmode(value)
                }

                pub fn sof(&self) -> SOF_FIELD {
                    let raw = self.raw;
                    SOF_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_sof(&mut self, value: SOF_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_sof_with<F: Fn(&mut SOF_FIELD) -> &mut SOF_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sof();
                    f(&mut value);
                    self.set_sof(value)
                }

                pub fn crcmodetx(&self) -> CRCMODETX_FIELD {
                    let raw = self.raw;
                    CRCMODETX_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_crcmodetx(&mut self, value: CRCMODETX_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_crcmodetx_with<F: Fn(&mut CRCMODETX_FIELD) -> &mut CRCMODETX_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.crcmodetx();
                    f(&mut value);
                    self.set_crcmodetx(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_FIELD u32 =>
                            // Parity is not added to TX frames
                            NoParity = 0,
            // Parity is added to TX frames
                            Parity = 1

                        );

            impl PARITY_FIELD {
                pub fn is_noparity(&self) -> bool {
                    *self == Self::NoParity
                }

                pub fn set_noparity(&mut self) -> &mut Self {
                    *self = Self::NoParity;
                    self
                }

                pub fn is_parity(&self) -> bool {
                    *self == Self::Parity
                }

                pub fn set_parity(&mut self) -> &mut Self {
                    *self = Self::Parity;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] DISCARDMODE_FIELD u32 =>
                            // Unused bits are discarded at end of frame (EoF)
                            DiscardEnd = 0,
            // Unused bits are discarded at start of frame (SoF)
                            DiscardStart = 1

                        );

            impl DISCARDMODE_FIELD {
                pub fn is_discardend(&self) -> bool {
                    *self == Self::DiscardEnd
                }

                pub fn set_discardend(&mut self) -> &mut Self {
                    *self = Self::DiscardEnd;
                    self
                }

                pub fn is_discardstart(&self) -> bool {
                    *self == Self::DiscardStart
                }

                pub fn set_discardstart(&mut self) -> &mut Self {
                    *self = Self::DiscardStart;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SOF_FIELD u32 =>
                            // SoF symbol not added
                            NoSoF = 0,
            // SoF symbol added
                            SoF = 1

                        );

            impl SOF_FIELD {
                pub fn is_nosof(&self) -> bool {
                    *self == Self::NoSoF
                }

                pub fn set_nosof(&mut self) -> &mut Self {
                    *self = Self::NoSoF;
                    self
                }

                pub fn is_sof(&self) -> bool {
                    *self == Self::SoF
                }

                pub fn set_sof(&mut self) -> &mut Self {
                    *self = Self::SoF;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CRCMODETX_FIELD u32 =>
                            // CRC is not added to the frame
                            NoCRCTX = 0,
            // 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame
                            CRC16TX = 1

                        );

            impl CRCMODETX_FIELD {
                pub fn is_nocrctx(&self) -> bool {
                    *self == Self::NoCRCTX
                }

                pub fn set_nocrctx(&mut self) -> &mut Self {
                    *self = Self::NoCRCTX;
                    self
                }

                pub fn is_crc16tx(&self) -> bool {
                    *self == Self::CRC16TX
                }

                pub fn set_crc16tx(&mut self) -> &mut Self {
                    *self = Self::CRC16TX;
                    self
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {
                pub fn write_with<F: Fn(&mut AMOUNT_VALUE) -> &mut AMOUNT_VALUE>(&mut self, f: F) {
                    let mut v = AMOUNT_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for AMOUNT {
                type Value = AMOUNT_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    AMOUNT_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for AMOUNT {
                type Value = AMOUNT_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct AMOUNT_VALUE {
                raw: u32,
            }

            impl AMOUNT_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn txdatabits(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000007) >> 0
                }

                pub fn set_txdatabits(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000007) | (value << 0);
                    self
                }

                pub fn txdatabytes(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000ff8) >> 3
                }

                pub fn set_txdatabytes(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000ff8) | (value << 3);
                    self
                }
            }
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Configuration of incoming frames
            pub frameconfig: frameconfig::FRAMECONFIG,
            /// Size of last incoming frame
            pub amount: amount::AMOUNT,
        }

        pub mod frameconfig {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct FRAMECONFIG {
                raw: RawRegister<u32>,
            }

            impl FRAMECONFIG {
                pub fn write_with<F: Fn(&mut FRAMECONFIG_VALUE) -> &mut FRAMECONFIG_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = FRAMECONFIG_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for FRAMECONFIG {
                type Value = FRAMECONFIG_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    FRAMECONFIG_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for FRAMECONFIG {
                type Value = FRAMECONFIG_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct FRAMECONFIG_VALUE {
                raw: u32,
            }

            impl FRAMECONFIG_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn parity(&self) -> PARITY_FIELD {
                    let raw = self.raw;
                    PARITY_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_parity(&mut self, value: PARITY_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_parity_with<F: Fn(&mut PARITY_FIELD) -> &mut PARITY_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.parity();
                    f(&mut value);
                    self.set_parity(value)
                }

                pub fn sof(&self) -> SOF_FIELD {
                    let raw = self.raw;
                    SOF_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_sof(&mut self, value: SOF_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_sof_with<F: Fn(&mut SOF_FIELD) -> &mut SOF_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sof();
                    f(&mut value);
                    self.set_sof(value)
                }

                pub fn crcmoderx(&self) -> CRCMODERX_FIELD {
                    let raw = self.raw;
                    CRCMODERX_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_crcmoderx(&mut self, value: CRCMODERX_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_crcmoderx_with<F: Fn(&mut CRCMODERX_FIELD) -> &mut CRCMODERX_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.crcmoderx();
                    f(&mut value);
                    self.set_crcmoderx(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PARITY_FIELD u32 =>
                            // Parity is not expected in RX frames
                            NoParity = 0,
            // Parity is expected in RX frames
                            Parity = 1

                        );

            impl PARITY_FIELD {
                pub fn is_noparity(&self) -> bool {
                    *self == Self::NoParity
                }

                pub fn set_noparity(&mut self) -> &mut Self {
                    *self = Self::NoParity;
                    self
                }

                pub fn is_parity(&self) -> bool {
                    *self == Self::Parity
                }

                pub fn set_parity(&mut self) -> &mut Self {
                    *self = Self::Parity;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SOF_FIELD u32 =>
                            // SoF symbol is not expected in RX frames
                            NoSoF = 0,
            // SoF symbol is expected in RX frames
                            SoF = 1

                        );

            impl SOF_FIELD {
                pub fn is_nosof(&self) -> bool {
                    *self == Self::NoSoF
                }

                pub fn set_nosof(&mut self) -> &mut Self {
                    *self = Self::NoSoF;
                    self
                }

                pub fn is_sof(&self) -> bool {
                    *self == Self::SoF
                }

                pub fn set_sof(&mut self) -> &mut Self {
                    *self = Self::SoF;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CRCMODERX_FIELD u32 =>
                            // CRC is not expected in RX frames
                            NoCRCRX = 0,
            // Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated
                            CRC16RX = 1

                        );

            impl CRCMODERX_FIELD {
                pub fn is_nocrcrx(&self) -> bool {
                    *self == Self::NoCRCRX
                }

                pub fn set_nocrcrx(&mut self) -> &mut Self {
                    *self = Self::NoCRCRX;
                    self
                }

                pub fn is_crc16rx(&self) -> bool {
                    *self == Self::CRC16RX
                }

                pub fn set_crc16rx(&mut self) -> &mut Self {
                    *self = Self::CRC16RX;
                    self
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = AMOUNT_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    AMOUNT_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct AMOUNT_READ_VALUE {
                raw: u32,
            }

            impl AMOUNT_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn rxdatabits(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000007) >> 0
                }

                pub fn set_rxdatabits(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000007) | (value << 0);
                    self
                }

                pub fn rxdatabytes(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00000ff8) >> 3
                }

                pub fn set_rxdatabytes(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000ff8) | (value << 3);
                    self
                }
            }
        }
    }

    pub mod modulationctrl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODULATIONCTRL {
            raw: RawRegister<u32>,
        }

        impl MODULATIONCTRL {
            pub fn write_invalid(&mut self) {
                self.write(MODULATIONCTRL_FIELD::Invalid)
            }

            pub fn write_internal(&mut self) {
                self.write(MODULATIONCTRL_FIELD::Internal)
            }

            pub fn write_modtogpio(&mut self) {
                self.write(MODULATIONCTRL_FIELD::ModToGpio)
            }

            pub fn write_internalandmodtogpio(&mut self) {
                self.write(MODULATIONCTRL_FIELD::InternalAndModToGpio)
            }
        }

        impl RegisterRead for MODULATIONCTRL {
            type Value = MODULATIONCTRL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                MODULATIONCTRL_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for MODULATIONCTRL {
            type Value = MODULATIONCTRL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODULATIONCTRL_FIELD u32 =>
                        // Invalid, defaults to same behaviour as for Internal
                        Invalid = 0,
        // Use internal modulator only
                        Internal = 1,
        // Output digital modulation signal to a GPIO pin.
                        ModToGpio = 2,
        // Use internal modulator and output digital modulation signal to a GPIO pin.
                        InternalAndModToGpio = 3

                    );

        impl MODULATIONCTRL_FIELD {
            pub fn is_invalid(&self) -> bool {
                *self == Self::Invalid
            }

            pub fn set_invalid(&mut self) -> &mut Self {
                *self = Self::Invalid;
                self
            }

            pub fn is_internal(&self) -> bool {
                *self == Self::Internal
            }

            pub fn set_internal(&mut self) -> &mut Self {
                *self = Self::Internal;
                self
            }

            pub fn is_modtogpio(&self) -> bool {
                *self == Self::ModToGpio
            }

            pub fn set_modtogpio(&mut self) -> &mut Self {
                *self = Self::ModToGpio;
                self
            }

            pub fn is_internalandmodtogpio(&self) -> bool {
                *self == Self::InternalAndModToGpio
            }

            pub fn set_internalandmodtogpio(&mut self) -> &mut Self {
                *self = Self::InternalAndModToGpio;
                self
            }
        }
    }

    pub mod modulationpsel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODULATIONPSEL {
            raw: RawRegister<u32>,
        }

        impl MODULATIONPSEL {
            pub fn write_with<F: Fn(&mut MODULATIONPSEL_VALUE) -> &mut MODULATIONPSEL_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = MODULATIONPSEL_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODULATIONPSEL {
            type Value = MODULATIONPSEL_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODULATIONPSEL_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODULATIONPSEL {
            type Value = MODULATIONPSEL_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODULATIONPSEL_VALUE {
            raw: u32,
        }

        impl MODULATIONPSEL_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn pin(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000001f) >> 0
            }

            pub fn set_pin(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn port(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000020) >> 5
            }

            pub fn set_port(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn connect(&self) -> CONNECT_FIELD {
                let raw = self.raw;
                CONNECT_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_connect(&mut self, value: CONNECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_connect_with<F: Fn(&mut CONNECT_FIELD) -> &mut CONNECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.connect();
                f(&mut value);
                self.set_connect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CONNECT_FIELD u32 =>
                        // Disconnect
                        Disconnected = 1,
        // Connect
                        Connected = 0

                    );

        impl CONNECT_FIELD {
            pub fn is_disconnected(&self) -> bool {
                *self == Self::Disconnected
            }

            pub fn set_disconnected(&mut self) -> &mut Self {
                *self = Self::Disconnected;
                self
            }

            pub fn is_connected(&self) -> bool {
                *self == Self::Connected
            }

            pub fn set_connected(&mut self) -> &mut Self {
                *self = Self::Connected;
                self
            }
        }
    }

    pub mod nfcid1_last {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NFCID1_LAST {
            raw: RawRegister<u32>,
        }

        impl NFCID1_LAST {
            pub fn write_with<F: Fn(&mut NFCID1_LAST_VALUE) -> &mut NFCID1_LAST_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = NFCID1_LAST_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NFCID1_LAST {
            type Value = NFCID1_LAST_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NFCID1_LAST_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NFCID1_LAST {
            type Value = NFCID1_LAST_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NFCID1_LAST_VALUE {
            raw: u32,
        }

        impl NFCID1_LAST_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn nfcid1_z(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_nfcid1_z(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn nfcid1_y(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_nfcid1_y(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn nfcid1_x(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_nfcid1_x(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }

            pub fn nfcid1_w(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xff000000) >> 24
            }

            pub fn set_nfcid1_w(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xff000000) | (value << 24);
                self
            }
        }
    }

    pub mod nfcid1_2nd_last {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NFCID1_2ND_LAST {
            raw: RawRegister<u32>,
        }

        impl NFCID1_2ND_LAST {
            pub fn write_with<F: Fn(&mut NFCID1_2ND_LAST_VALUE) -> &mut NFCID1_2ND_LAST_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = NFCID1_2ND_LAST_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NFCID1_2ND_LAST {
            type Value = NFCID1_2ND_LAST_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NFCID1_2ND_LAST_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NFCID1_2ND_LAST {
            type Value = NFCID1_2ND_LAST_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NFCID1_2ND_LAST_VALUE {
            raw: u32,
        }

        impl NFCID1_2ND_LAST_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn nfcid1_v(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_nfcid1_v(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn nfcid1_u(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_nfcid1_u(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn nfcid1_t(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_nfcid1_t(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }
        }
    }

    pub mod nfcid1_3rd_last {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NFCID1_3RD_LAST {
            raw: RawRegister<u32>,
        }

        impl NFCID1_3RD_LAST {
            pub fn write_with<F: Fn(&mut NFCID1_3RD_LAST_VALUE) -> &mut NFCID1_3RD_LAST_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = NFCID1_3RD_LAST_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NFCID1_3RD_LAST {
            type Value = NFCID1_3RD_LAST_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NFCID1_3RD_LAST_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NFCID1_3RD_LAST {
            type Value = NFCID1_3RD_LAST_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NFCID1_3RD_LAST_VALUE {
            raw: u32,
        }

        impl NFCID1_3RD_LAST_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn nfcid1_s(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000000ff) >> 0
            }

            pub fn set_nfcid1_s(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000ff) | (value << 0);
                self
            }

            pub fn nfcid1_r(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000ff00) >> 8
            }

            pub fn set_nfcid1_r(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ff00) | (value << 8);
                self
            }

            pub fn nfcid1_q(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ff0000) >> 16
            }

            pub fn set_nfcid1_q(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ff0000) | (value << 16);
                self
            }
        }
    }

    pub mod autocolresconfig {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct AUTOCOLRESCONFIG {
            raw: RawRegister<u32>,
        }

        impl AUTOCOLRESCONFIG {
            pub fn write_with<F: Fn(&mut AUTOCOLRESCONFIG_VALUE) -> &mut AUTOCOLRESCONFIG_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = AUTOCOLRESCONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for AUTOCOLRESCONFIG {
            type Value = AUTOCOLRESCONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                AUTOCOLRESCONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for AUTOCOLRESCONFIG {
            type Value = AUTOCOLRESCONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct AUTOCOLRESCONFIG_VALUE {
            raw: u32,
        }

        impl AUTOCOLRESCONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn mode(&self) -> MODE_FIELD {
                let raw = self.raw;
                MODE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mode();
                f(&mut value);
                self.set_mode(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // Auto collision resolution enabled
                        Enabled = 0,
        // Auto collision resolution disabled
                        Disabled = 1

                    );

        impl MODE_FIELD {
            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }

            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }
        }
    }

    pub mod sensres {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SENSRES {
            raw: RawRegister<u32>,
        }

        impl SENSRES {
            pub fn write_with<F: Fn(&mut SENSRES_VALUE) -> &mut SENSRES_VALUE>(&mut self, f: F) {
                let mut v = SENSRES_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SENSRES {
            type Value = SENSRES_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SENSRES_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SENSRES {
            type Value = SENSRES_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SENSRES_VALUE {
            raw: u32,
        }

        impl SENSRES_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn bitframesdd(&self) -> BITFRAMESDD_FIELD {
                let raw = self.raw;
                BITFRAMESDD_FIELD::from_value((raw & 0x0000001f) >> 0)
            }

            pub fn set_bitframesdd(&mut self, value: BITFRAMESDD_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn set_bitframesdd_with<F: Fn(&mut BITFRAMESDD_FIELD) -> &mut BITFRAMESDD_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.bitframesdd();
                f(&mut value);
                self.set_bitframesdd(value)
            }

            pub fn rfu5(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000020) >> 5
            }

            pub fn set_rfu5(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn nfcidsize(&self) -> NFCIDSIZE_FIELD {
                let raw = self.raw;
                NFCIDSIZE_FIELD::from_value((raw & 0x000000c0) >> 6)
            }

            pub fn set_nfcidsize(&mut self, value: NFCIDSIZE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000000c0) | (value << 6);
                self
            }

            pub fn set_nfcidsize_with<F: Fn(&mut NFCIDSIZE_FIELD) -> &mut NFCIDSIZE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.nfcidsize();
                f(&mut value);
                self.set_nfcidsize(value)
            }

            pub fn platfconfig(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000f00) >> 8
            }

            pub fn set_platfconfig(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000f00) | (value << 8);
                self
            }

            pub fn rfu74(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000f000) >> 12
            }

            pub fn set_rfu74(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000f000) | (value << 12);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BITFRAMESDD_FIELD u32 =>
                        // SDD pattern 00000
                        SDD00000 = 0,
        // SDD pattern 00001
                        SDD00001 = 1,
        // SDD pattern 00010
                        SDD00010 = 2,
        // SDD pattern 00100
                        SDD00100 = 4,
        // SDD pattern 01000
                        SDD01000 = 8,
        // SDD pattern 10000
                        SDD10000 = 16

                    );

        impl BITFRAMESDD_FIELD {
            pub fn is_sdd00000(&self) -> bool {
                *self == Self::SDD00000
            }

            pub fn set_sdd00000(&mut self) -> &mut Self {
                *self = Self::SDD00000;
                self
            }

            pub fn is_sdd00001(&self) -> bool {
                *self == Self::SDD00001
            }

            pub fn set_sdd00001(&mut self) -> &mut Self {
                *self = Self::SDD00001;
                self
            }

            pub fn is_sdd00010(&self) -> bool {
                *self == Self::SDD00010
            }

            pub fn set_sdd00010(&mut self) -> &mut Self {
                *self = Self::SDD00010;
                self
            }

            pub fn is_sdd00100(&self) -> bool {
                *self == Self::SDD00100
            }

            pub fn set_sdd00100(&mut self) -> &mut Self {
                *self = Self::SDD00100;
                self
            }

            pub fn is_sdd01000(&self) -> bool {
                *self == Self::SDD01000
            }

            pub fn set_sdd01000(&mut self) -> &mut Self {
                *self = Self::SDD01000;
                self
            }

            pub fn is_sdd10000(&self) -> bool {
                *self == Self::SDD10000
            }

            pub fn set_sdd10000(&mut self) -> &mut Self {
                *self = Self::SDD10000;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] NFCIDSIZE_FIELD u32 =>
                        // NFCID1 size: single (4 bytes)
                        NFCID1Single = 0,
        // NFCID1 size: double (7 bytes)
                        NFCID1Double = 1,
        // NFCID1 size: triple (10 bytes)
                        NFCID1Triple = 2

                    );

        impl NFCIDSIZE_FIELD {
            pub fn is_nfcid1single(&self) -> bool {
                *self == Self::NFCID1Single
            }

            pub fn set_nfcid1single(&mut self) -> &mut Self {
                *self = Self::NFCID1Single;
                self
            }

            pub fn is_nfcid1double(&self) -> bool {
                *self == Self::NFCID1Double
            }

            pub fn set_nfcid1double(&mut self) -> &mut Self {
                *self = Self::NFCID1Double;
                self
            }

            pub fn is_nfcid1triple(&self) -> bool {
                *self == Self::NFCID1Triple
            }

            pub fn set_nfcid1triple(&mut self) -> &mut Self {
                *self = Self::NFCID1Triple;
                self
            }
        }
    }

    pub mod selres {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SELRES {
            raw: RawRegister<u32>,
        }

        impl SELRES {
            pub fn write_with<F: Fn(&mut SELRES_VALUE) -> &mut SELRES_VALUE>(&mut self, f: F) {
                let mut v = SELRES_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SELRES {
            type Value = SELRES_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SELRES_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SELRES {
            type Value = SELRES_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SELRES_VALUE {
            raw: u32,
        }

        impl SELRES_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rfu10(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000003) >> 0
            }

            pub fn set_rfu10(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn cascade(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000004) >> 2
            }

            pub fn set_cascade(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn rfu43(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000018) >> 3
            }

            pub fn set_rfu43(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000018) | (value << 3);
                self
            }

            pub fn protocol(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000060) >> 5
            }

            pub fn set_protocol(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000060) | (value << 5);
                self
            }

            pub fn rfu7(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000080) >> 7
            }

            pub fn set_rfu7(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }
        }
    }
}

pub mod gpiote {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct GPIOTE {
        _hidden: (),
    }

    impl GPIOTE {
        const BASE_ADDRESS: u32 = 0x40006000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for GPIOTE {
        type Target = GPIOTE_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for GPIOTE {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct GPIOTE_REGISTERS {
        _hidden: (),
        /// Description collection: Task for writing to pin specified in
        /// CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
        pub tasks_out: [TaskRegister; 8],
        _padding_32: [u8; 16],
        /// Description collection: Task for writing to pin specified in
        /// CONFIG[n].PSEL. Action on pin is to set it high.
        pub tasks_set: [TaskRegister; 8],
        _padding_80: [u8; 16],
        /// Description collection: Task for writing to pin specified in
        /// CONFIG[n].PSEL. Action on pin is to set it low.
        pub tasks_clr: [TaskRegister; 8],
        _padding_128: [u8; 128],
        /// Description collection: Event generated from pin specified in
        /// CONFIG[n].PSEL
        pub events_in: [EventRegister; 8],
        _padding_288: [u8; 92],
        /// Event generated from multiple input GPIO pins with SENSE mechanism
        /// enabled
        pub events_port: EventRegister,
        _padding_384: [u8; 388],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 516],
        /// Description collection: Configuration for OUT[n], SET[n], and CLR[n]
        /// tasks and IN[n] event
        pub config: [config::CONFIG; 8],
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn in0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_in0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_in0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in0();
                f(&mut value);
                self.set_in0(value)
            }

            pub fn in1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_in1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_in1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in1();
                f(&mut value);
                self.set_in1(value)
            }

            pub fn in2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_in2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_in2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in2();
                f(&mut value);
                self.set_in2(value)
            }

            pub fn in3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_in3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_in3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in3();
                f(&mut value);
                self.set_in3(value)
            }

            pub fn in4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_in4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_in4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in4();
                f(&mut value);
                self.set_in4(value)
            }

            pub fn in5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_in5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_in5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in5();
                f(&mut value);
                self.set_in5(value)
            }

            pub fn in6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_in6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_in6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in6();
                f(&mut value);
                self.set_in6(value)
            }

            pub fn in7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_in7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_in7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in7();
                f(&mut value);
                self.set_in7(value)
            }

            pub fn port(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_port(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_port_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.port();
                f(&mut value);
                self.set_port(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_in0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_in1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_in2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_in3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_in4(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_in5(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_in6(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_in7(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_port(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn in0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_in0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_in0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in0();
                f(&mut value);
                self.set_in0(value)
            }

            pub fn in1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_in1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_in1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in1();
                f(&mut value);
                self.set_in1(value)
            }

            pub fn in2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_in2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_in2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in2();
                f(&mut value);
                self.set_in2(value)
            }

            pub fn in3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_in3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_in3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in3();
                f(&mut value);
                self.set_in3(value)
            }

            pub fn in4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_in4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_in4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in4();
                f(&mut value);
                self.set_in4(value)
            }

            pub fn in5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_in5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_in5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in5();
                f(&mut value);
                self.set_in5(value)
            }

            pub fn in6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_in6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_in6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in6();
                f(&mut value);
                self.set_in6(value)
            }

            pub fn in7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_in7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_in7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in7();
                f(&mut value);
                self.set_in7(value)
            }

            pub fn port(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_port(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_port_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.port();
                f(&mut value);
                self.set_port(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_in0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_in1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_in2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_in3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_in4(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_in5(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_in6(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_in7(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_port(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn mode(&self) -> MODE_FIELD {
                let raw = self.raw;
                MODE_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mode();
                f(&mut value);
                self.set_mode(value)
            }

            pub fn psel(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00001f00) >> 8
            }

            pub fn set_psel(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001f00) | (value << 8);
                self
            }

            pub fn port(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00002000) >> 13
            }

            pub fn set_port(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn polarity(&self) -> POLARITY_FIELD {
                let raw = self.raw;
                POLARITY_FIELD::from_value((raw & 0x00030000) >> 16)
            }

            pub fn set_polarity(&mut self, value: POLARITY_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00030000) | (value << 16);
                self
            }

            pub fn set_polarity_with<F: Fn(&mut POLARITY_FIELD) -> &mut POLARITY_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.polarity();
                f(&mut value);
                self.set_polarity(value)
            }

            pub fn outinit(&self) -> OUTINIT_FIELD {
                let raw = self.raw;
                OUTINIT_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_outinit(&mut self, value: OUTINIT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_outinit_with<F: Fn(&mut OUTINIT_FIELD) -> &mut OUTINIT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.outinit();
                f(&mut value);
                self.set_outinit(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module.
                        Disabled = 0,
        // Event mode
                        Event = 1,
        // Task mode
                        Task = 3

                    );

        impl MODE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_event(&self) -> bool {
                *self == Self::Event
            }

            pub fn set_event(&mut self) -> &mut Self {
                *self = Self::Event;
                self
            }

            pub fn is_task(&self) -> bool {
                *self == Self::Task
            }

            pub fn set_task(&mut self) -> &mut Self {
                *self = Self::Task;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] POLARITY_FIELD u32 =>
                        // Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.
                        None = 0,
        // Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.
                        LoToHi = 1,
        // Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.
                        HiToLo = 2,
        // Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.
                        Toggle = 3

                    );

        impl POLARITY_FIELD {
            pub fn is_none(&self) -> bool {
                *self == Self::None
            }

            pub fn set_none(&mut self) -> &mut Self {
                *self = Self::None;
                self
            }

            pub fn is_lotohi(&self) -> bool {
                *self == Self::LoToHi
            }

            pub fn set_lotohi(&mut self) -> &mut Self {
                *self = Self::LoToHi;
                self
            }

            pub fn is_hitolo(&self) -> bool {
                *self == Self::HiToLo
            }

            pub fn set_hitolo(&mut self) -> &mut Self {
                *self = Self::HiToLo;
                self
            }

            pub fn is_toggle(&self) -> bool {
                *self == Self::Toggle
            }

            pub fn set_toggle(&mut self) -> &mut Self {
                *self = Self::Toggle;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUTINIT_FIELD u32 =>
                        // Task mode: Initial value of pin before task triggering is low
                        Low = 0,
        // Task mode: Initial value of pin before task triggering is high
                        High = 1

                    );

        impl OUTINIT_FIELD {
            pub fn is_low(&self) -> bool {
                *self == Self::Low
            }

            pub fn set_low(&mut self) -> &mut Self {
                *self = Self::Low;
                self
            }

            pub fn is_high(&self) -> bool {
                *self == Self::High
            }

            pub fn set_high(&mut self) -> &mut Self {
                *self = Self::High;
                self
            }
        }
    }
}

pub mod saadc {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SAADC {
        _hidden: (),
    }

    impl SAADC {
        const BASE_ADDRESS: u32 = 0x40007000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SAADC {
        type Target = SAADC_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SAADC {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct SAADC_REGISTERS {
        _hidden: (),
        /// Starts the SAADC and prepares the result buffer in RAM
        pub tasks_start: TaskRegister,
        /// Takes one SAADC sample
        pub tasks_sample: TaskRegister,
        /// Stops the SAADC and terminates all on-going conversions
        pub tasks_stop: TaskRegister,
        /// Starts offset auto-calibration
        pub tasks_calibrateoffset: TaskRegister,
        _padding_16: [u8; 240],
        /// The SAADC has started
        pub events_started: EventRegister,
        /// The SAADC has filled up the result buffer
        pub events_end: EventRegister,
        /// A conversion task has been completed. Depending on the
        /// configuration, multiple conversions might be needed for a result to
        /// be transferred to RAM.
        pub events_done: EventRegister,
        /// Result ready for transfer to RAM
        pub events_resultdone: EventRegister,
        /// Calibration is complete
        pub events_calibratedone: EventRegister,
        /// The SAADC has stopped
        pub events_stopped: EventRegister,
        /// Peripheral events.
        pub events_ch: [events_ch::EVENTS_CH; 8],
        _padding_344: [u8; 424],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Status
        pub status: status::STATUS,
        _padding_1028: [u8; 252],
        /// Enable or disable SAADC
        pub enable: enable::ENABLE,
        _padding_1284: [u8; 12],
        /// Unspecified
        pub ch: [ch::CH; 8],
        _padding_1424: [u8; 96],
        /// Resolution configuration
        pub resolution: resolution::RESOLUTION,
        /// Oversampling configuration. The RESOLUTION is applied before
        /// averaging, thus for high OVERSAMPLE a higher RESOLUTION should be
        /// used.
        pub oversample: oversample::OVERSAMPLE,
        /// Controls normal or continuous sample rate
        pub samplerate: samplerate::SAMPLERATE,
        _padding_1532: [u8; 48],
        pub result: result::RESULT,
    }

    pub mod events_ch {
        #[allow(unused_imports)]
        use super::*;

        /// Peripheral events.
        #[repr(C)]
        pub struct EVENTS_CH {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Last result is equal or above
            /// CH[n].LIMIT.HIGH
            pub limith: EventRegister,
            /// Description cluster: Last result is equal or below
            /// CH[n].LIMIT.LOW
            pub limitl: EventRegister,
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn done(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_done(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_done_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.done();
                f(&mut value);
                self.set_done(value)
            }

            pub fn resultdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_resultdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_resultdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resultdone();
                f(&mut value);
                self.set_resultdone(value)
            }

            pub fn calibratedone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_calibratedone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_calibratedone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.calibratedone();
                f(&mut value);
                self.set_calibratedone(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn ch0limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch0limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch0limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limith();
                f(&mut value);
                self.set_ch0limith(value)
            }

            pub fn ch0limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch0limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch0limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limitl();
                f(&mut value);
                self.set_ch0limitl(value)
            }

            pub fn ch1limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch1limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch1limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limith();
                f(&mut value);
                self.set_ch1limith(value)
            }

            pub fn ch1limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch1limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch1limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limitl();
                f(&mut value);
                self.set_ch1limitl(value)
            }

            pub fn ch2limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch2limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch2limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limith();
                f(&mut value);
                self.set_ch2limith(value)
            }

            pub fn ch2limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch2limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch2limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limitl();
                f(&mut value);
                self.set_ch2limitl(value)
            }

            pub fn ch3limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch3limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch3limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limith();
                f(&mut value);
                self.set_ch3limith(value)
            }

            pub fn ch3limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch3limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch3limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limitl();
                f(&mut value);
                self.set_ch3limitl(value)
            }

            pub fn ch4limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch4limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch4limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limith();
                f(&mut value);
                self.set_ch4limith(value)
            }

            pub fn ch4limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch4limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch4limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limitl();
                f(&mut value);
                self.set_ch4limitl(value)
            }

            pub fn ch5limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch5limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch5limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limith();
                f(&mut value);
                self.set_ch5limith(value)
            }

            pub fn ch5limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch5limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch5limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limitl();
                f(&mut value);
                self.set_ch5limitl(value)
            }

            pub fn ch6limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch6limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch6limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limith();
                f(&mut value);
                self.set_ch6limith(value)
            }

            pub fn ch6limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch6limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch6limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limitl();
                f(&mut value);
                self.set_ch6limitl(value)
            }

            pub fn ch7limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch7limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch7limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limith();
                f(&mut value);
                self.set_ch7limith(value)
            }

            pub fn ch7limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch7limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch7limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limitl();
                f(&mut value);
                self.set_ch7limitl(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn done(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_done(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_done_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.done();
                f(&mut value);
                self.set_done(value)
            }

            pub fn resultdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_resultdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_resultdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resultdone();
                f(&mut value);
                self.set_resultdone(value)
            }

            pub fn calibratedone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_calibratedone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_calibratedone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.calibratedone();
                f(&mut value);
                self.set_calibratedone(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn ch0limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch0limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch0limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limith();
                f(&mut value);
                self.set_ch0limith(value)
            }

            pub fn ch0limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch0limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch0limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limitl();
                f(&mut value);
                self.set_ch0limitl(value)
            }

            pub fn ch1limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch1limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch1limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limith();
                f(&mut value);
                self.set_ch1limith(value)
            }

            pub fn ch1limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch1limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch1limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limitl();
                f(&mut value);
                self.set_ch1limitl(value)
            }

            pub fn ch2limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch2limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch2limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limith();
                f(&mut value);
                self.set_ch2limith(value)
            }

            pub fn ch2limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch2limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch2limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limitl();
                f(&mut value);
                self.set_ch2limitl(value)
            }

            pub fn ch3limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch3limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch3limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limith();
                f(&mut value);
                self.set_ch3limith(value)
            }

            pub fn ch3limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch3limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch3limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limitl();
                f(&mut value);
                self.set_ch3limitl(value)
            }

            pub fn ch4limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch4limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch4limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limith();
                f(&mut value);
                self.set_ch4limith(value)
            }

            pub fn ch4limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch4limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch4limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limitl();
                f(&mut value);
                self.set_ch4limitl(value)
            }

            pub fn ch5limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch5limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch5limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limith();
                f(&mut value);
                self.set_ch5limith(value)
            }

            pub fn ch5limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch5limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch5limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limitl();
                f(&mut value);
                self.set_ch5limitl(value)
            }

            pub fn ch6limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch6limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch6limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limith();
                f(&mut value);
                self.set_ch6limith(value)
            }

            pub fn ch6limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch6limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch6limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limitl();
                f(&mut value);
                self.set_ch6limitl(value)
            }

            pub fn ch7limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch7limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch7limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limith();
                f(&mut value);
                self.set_ch7limith(value)
            }

            pub fn ch7limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch7limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch7limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limitl();
                f(&mut value);
                self.set_ch7limitl(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_done(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_resultdone(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_calibratedone(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch0limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch0limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch1limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch1limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch2limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch2limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch3limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch3limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch4limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch4limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch5limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch5limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch6limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch6limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch7limith(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch7limitl(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn done(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_done(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_done_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.done();
                f(&mut value);
                self.set_done(value)
            }

            pub fn resultdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_resultdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_resultdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resultdone();
                f(&mut value);
                self.set_resultdone(value)
            }

            pub fn calibratedone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_calibratedone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_calibratedone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.calibratedone();
                f(&mut value);
                self.set_calibratedone(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn ch0limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch0limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch0limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limith();
                f(&mut value);
                self.set_ch0limith(value)
            }

            pub fn ch0limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch0limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch0limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0limitl();
                f(&mut value);
                self.set_ch0limitl(value)
            }

            pub fn ch1limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch1limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch1limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limith();
                f(&mut value);
                self.set_ch1limith(value)
            }

            pub fn ch1limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch1limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch1limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1limitl();
                f(&mut value);
                self.set_ch1limitl(value)
            }

            pub fn ch2limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch2limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch2limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limith();
                f(&mut value);
                self.set_ch2limith(value)
            }

            pub fn ch2limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch2limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch2limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2limitl();
                f(&mut value);
                self.set_ch2limitl(value)
            }

            pub fn ch3limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch3limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch3limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limith();
                f(&mut value);
                self.set_ch3limith(value)
            }

            pub fn ch3limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch3limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch3limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3limitl();
                f(&mut value);
                self.set_ch3limitl(value)
            }

            pub fn ch4limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch4limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch4limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limith();
                f(&mut value);
                self.set_ch4limith(value)
            }

            pub fn ch4limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch4limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch4limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4limitl();
                f(&mut value);
                self.set_ch4limitl(value)
            }

            pub fn ch5limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch5limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch5limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limith();
                f(&mut value);
                self.set_ch5limith(value)
            }

            pub fn ch5limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch5limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch5limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5limitl();
                f(&mut value);
                self.set_ch5limitl(value)
            }

            pub fn ch6limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch6limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch6limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limith();
                f(&mut value);
                self.set_ch6limith(value)
            }

            pub fn ch6limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch6limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch6limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6limitl();
                f(&mut value);
                self.set_ch6limitl(value)
            }

            pub fn ch7limith(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch7limith(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch7limith_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limith();
                f(&mut value);
                self.set_ch7limith(value)
            }

            pub fn ch7limitl(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch7limitl(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch7limitl_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7limitl();
                f(&mut value);
                self.set_ch7limitl(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_done(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_resultdone(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_calibratedone(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch0limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch0limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch1limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch1limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch2limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch2limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch3limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch3limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch4limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch4limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch5limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch5limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch6limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch6limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch7limith(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch7limitl(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }
        }
    }

    pub mod status {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct STATUS {
            raw: RawRegister<u32>,
        }

        impl STATUS {}

        impl RegisterRead for STATUS {
            type Value = STATUS_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                STATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATUS_FIELD u32 =>
                        // SAADC is ready. No on-going conversions.
                        Ready = 0,
        // SAADC is busy. Conversion in progress.
                        Busy = 1

                    );

        impl STATUS_FIELD {
            pub fn is_ready(&self) -> bool {
                *self == Self::Ready
            }

            pub fn set_ready(&mut self) -> &mut Self {
                *self = Self::Ready;
                self
            }

            pub fn is_busy(&self) -> bool {
                *self == Self::Busy
            }

            pub fn set_busy(&mut self) -> &mut Self {
                *self = Self::Busy;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable SAADC
                        Disabled = 0,
        // Enable SAADC
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod ch {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct CH {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Input positive pin selection for CH[n]
            pub pselp: pselp::PSELP,
            /// Description cluster: Input negative pin selection for CH[n]
            pub pseln: pseln::PSELN,
            /// Description cluster: Input configuration for CH[n]
            pub config: config::CONFIG,
            /// Description cluster: High/low limits for event monitoring of a
            /// channel
            pub limit: limit::LIMIT,
        }

        pub mod pselp {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PSELP {
                raw: RawRegister<u32>,
            }

            impl PSELP {
                pub fn write_nc(&mut self) {
                    self.write(PSELP_FIELD::NC)
                }

                pub fn write_analoginput0(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput0)
                }

                pub fn write_analoginput1(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput1)
                }

                pub fn write_analoginput2(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput2)
                }

                pub fn write_analoginput3(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput3)
                }

                pub fn write_analoginput4(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput4)
                }

                pub fn write_analoginput5(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput5)
                }

                pub fn write_analoginput6(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput6)
                }

                pub fn write_analoginput7(&mut self) {
                    self.write(PSELP_FIELD::AnalogInput7)
                }

                pub fn write_vdd(&mut self) {
                    self.write(PSELP_FIELD::VDD)
                }

                pub fn write_vddhdiv5(&mut self) {
                    self.write(PSELP_FIELD::VDDHDIV5)
                }
            }

            impl RegisterRead for PSELP {
                type Value = PSELP_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    PSELP_FIELD::from_value((raw & 0x0000001f) >> 0)
                }
            }

            impl RegisterWrite for PSELP {
                type Value = PSELP_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PSELP_FIELD u32 =>
                            // Not connected
                            NC = 0,
            // AIN0
                            AnalogInput0 = 1,
            // AIN1
                            AnalogInput1 = 2,
            // AIN2
                            AnalogInput2 = 3,
            // AIN3
                            AnalogInput3 = 4,
            // AIN4
                            AnalogInput4 = 5,
            // AIN5
                            AnalogInput5 = 6,
            // AIN6
                            AnalogInput6 = 7,
            // AIN7
                            AnalogInput7 = 8,
            // VDD
                            VDD = 9,
            // VDDH/5
                            VDDHDIV5 = 13

                        );

            impl PSELP_FIELD {
                pub fn is_nc(&self) -> bool {
                    *self == Self::NC
                }

                pub fn set_nc(&mut self) -> &mut Self {
                    *self = Self::NC;
                    self
                }

                pub fn is_analoginput0(&self) -> bool {
                    *self == Self::AnalogInput0
                }

                pub fn set_analoginput0(&mut self) -> &mut Self {
                    *self = Self::AnalogInput0;
                    self
                }

                pub fn is_analoginput1(&self) -> bool {
                    *self == Self::AnalogInput1
                }

                pub fn set_analoginput1(&mut self) -> &mut Self {
                    *self = Self::AnalogInput1;
                    self
                }

                pub fn is_analoginput2(&self) -> bool {
                    *self == Self::AnalogInput2
                }

                pub fn set_analoginput2(&mut self) -> &mut Self {
                    *self = Self::AnalogInput2;
                    self
                }

                pub fn is_analoginput3(&self) -> bool {
                    *self == Self::AnalogInput3
                }

                pub fn set_analoginput3(&mut self) -> &mut Self {
                    *self = Self::AnalogInput3;
                    self
                }

                pub fn is_analoginput4(&self) -> bool {
                    *self == Self::AnalogInput4
                }

                pub fn set_analoginput4(&mut self) -> &mut Self {
                    *self = Self::AnalogInput4;
                    self
                }

                pub fn is_analoginput5(&self) -> bool {
                    *self == Self::AnalogInput5
                }

                pub fn set_analoginput5(&mut self) -> &mut Self {
                    *self = Self::AnalogInput5;
                    self
                }

                pub fn is_analoginput6(&self) -> bool {
                    *self == Self::AnalogInput6
                }

                pub fn set_analoginput6(&mut self) -> &mut Self {
                    *self = Self::AnalogInput6;
                    self
                }

                pub fn is_analoginput7(&self) -> bool {
                    *self == Self::AnalogInput7
                }

                pub fn set_analoginput7(&mut self) -> &mut Self {
                    *self = Self::AnalogInput7;
                    self
                }

                pub fn is_vdd(&self) -> bool {
                    *self == Self::VDD
                }

                pub fn set_vdd(&mut self) -> &mut Self {
                    *self = Self::VDD;
                    self
                }

                pub fn is_vddhdiv5(&self) -> bool {
                    *self == Self::VDDHDIV5
                }

                pub fn set_vddhdiv5(&mut self) -> &mut Self {
                    *self = Self::VDDHDIV5;
                    self
                }
            }
        }

        pub mod pseln {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PSELN {
                raw: RawRegister<u32>,
            }

            impl PSELN {
                pub fn write_nc(&mut self) {
                    self.write(PSELN_FIELD::NC)
                }

                pub fn write_analoginput0(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput0)
                }

                pub fn write_analoginput1(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput1)
                }

                pub fn write_analoginput2(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput2)
                }

                pub fn write_analoginput3(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput3)
                }

                pub fn write_analoginput4(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput4)
                }

                pub fn write_analoginput5(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput5)
                }

                pub fn write_analoginput6(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput6)
                }

                pub fn write_analoginput7(&mut self) {
                    self.write(PSELN_FIELD::AnalogInput7)
                }

                pub fn write_vdd(&mut self) {
                    self.write(PSELN_FIELD::VDD)
                }

                pub fn write_vddhdiv5(&mut self) {
                    self.write(PSELN_FIELD::VDDHDIV5)
                }
            }

            impl RegisterRead for PSELN {
                type Value = PSELN_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    PSELN_FIELD::from_value((raw & 0x0000001f) >> 0)
                }
            }

            impl RegisterWrite for PSELN {
                type Value = PSELN_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] PSELN_FIELD u32 =>
                            // Not connected
                            NC = 0,
            // AIN0
                            AnalogInput0 = 1,
            // AIN1
                            AnalogInput1 = 2,
            // AIN2
                            AnalogInput2 = 3,
            // AIN3
                            AnalogInput3 = 4,
            // AIN4
                            AnalogInput4 = 5,
            // AIN5
                            AnalogInput5 = 6,
            // AIN6
                            AnalogInput6 = 7,
            // AIN7
                            AnalogInput7 = 8,
            // VDD
                            VDD = 9,
            // VDDH/5
                            VDDHDIV5 = 13

                        );

            impl PSELN_FIELD {
                pub fn is_nc(&self) -> bool {
                    *self == Self::NC
                }

                pub fn set_nc(&mut self) -> &mut Self {
                    *self = Self::NC;
                    self
                }

                pub fn is_analoginput0(&self) -> bool {
                    *self == Self::AnalogInput0
                }

                pub fn set_analoginput0(&mut self) -> &mut Self {
                    *self = Self::AnalogInput0;
                    self
                }

                pub fn is_analoginput1(&self) -> bool {
                    *self == Self::AnalogInput1
                }

                pub fn set_analoginput1(&mut self) -> &mut Self {
                    *self = Self::AnalogInput1;
                    self
                }

                pub fn is_analoginput2(&self) -> bool {
                    *self == Self::AnalogInput2
                }

                pub fn set_analoginput2(&mut self) -> &mut Self {
                    *self = Self::AnalogInput2;
                    self
                }

                pub fn is_analoginput3(&self) -> bool {
                    *self == Self::AnalogInput3
                }

                pub fn set_analoginput3(&mut self) -> &mut Self {
                    *self = Self::AnalogInput3;
                    self
                }

                pub fn is_analoginput4(&self) -> bool {
                    *self == Self::AnalogInput4
                }

                pub fn set_analoginput4(&mut self) -> &mut Self {
                    *self = Self::AnalogInput4;
                    self
                }

                pub fn is_analoginput5(&self) -> bool {
                    *self == Self::AnalogInput5
                }

                pub fn set_analoginput5(&mut self) -> &mut Self {
                    *self = Self::AnalogInput5;
                    self
                }

                pub fn is_analoginput6(&self) -> bool {
                    *self == Self::AnalogInput6
                }

                pub fn set_analoginput6(&mut self) -> &mut Self {
                    *self = Self::AnalogInput6;
                    self
                }

                pub fn is_analoginput7(&self) -> bool {
                    *self == Self::AnalogInput7
                }

                pub fn set_analoginput7(&mut self) -> &mut Self {
                    *self = Self::AnalogInput7;
                    self
                }

                pub fn is_vdd(&self) -> bool {
                    *self == Self::VDD
                }

                pub fn set_vdd(&mut self) -> &mut Self {
                    *self = Self::VDD;
                    self
                }

                pub fn is_vddhdiv5(&self) -> bool {
                    *self == Self::VDDHDIV5
                }

                pub fn set_vddhdiv5(&mut self) -> &mut Self {
                    *self = Self::VDDHDIV5;
                    self
                }
            }
        }

        pub mod config {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct CONFIG {
                raw: RawRegister<u32>,
            }

            impl CONFIG {
                pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                    let mut v = CONFIG_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for CONFIG {
                type Value = CONFIG_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    CONFIG_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for CONFIG {
                type Value = CONFIG_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct CONFIG_VALUE {
                raw: u32,
            }

            impl CONFIG_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn resp(&self) -> RESP_FIELD {
                    let raw = self.raw;
                    RESP_FIELD::from_value((raw & 0x00000003) >> 0)
                }

                pub fn set_resp(&mut self, value: RESP_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000003) | (value << 0);
                    self
                }

                pub fn set_resp_with<F: Fn(&mut RESP_FIELD) -> &mut RESP_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.resp();
                    f(&mut value);
                    self.set_resp(value)
                }

                pub fn resn(&self) -> RESN_FIELD {
                    let raw = self.raw;
                    RESN_FIELD::from_value((raw & 0x00000030) >> 4)
                }

                pub fn set_resn(&mut self, value: RESN_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000030) | (value << 4);
                    self
                }

                pub fn set_resn_with<F: Fn(&mut RESN_FIELD) -> &mut RESN_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.resn();
                    f(&mut value);
                    self.set_resn(value)
                }

                pub fn gain(&self) -> GAIN_FIELD {
                    let raw = self.raw;
                    GAIN_FIELD::from_value((raw & 0x00000700) >> 8)
                }

                pub fn set_gain(&mut self, value: GAIN_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000700) | (value << 8);
                    self
                }

                pub fn set_gain_with<F: Fn(&mut GAIN_FIELD) -> &mut GAIN_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.gain();
                    f(&mut value);
                    self.set_gain(value)
                }

                pub fn refsel(&self) -> REFSEL_FIELD {
                    let raw = self.raw;
                    REFSEL_FIELD::from_value((raw & 0x00001000) >> 12)
                }

                pub fn set_refsel(&mut self, value: REFSEL_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_refsel_with<F: Fn(&mut REFSEL_FIELD) -> &mut REFSEL_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.refsel();
                    f(&mut value);
                    self.set_refsel(value)
                }

                pub fn tacq(&self) -> TACQ_FIELD {
                    let raw = self.raw;
                    TACQ_FIELD::from_value((raw & 0x00070000) >> 16)
                }

                pub fn set_tacq(&mut self, value: TACQ_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00070000) | (value << 16);
                    self
                }

                pub fn set_tacq_with<F: Fn(&mut TACQ_FIELD) -> &mut TACQ_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.tacq();
                    f(&mut value);
                    self.set_tacq(value)
                }

                pub fn mode(&self) -> MODE_FIELD {
                    let raw = self.raw;
                    MODE_FIELD::from_value((raw & 0x00100000) >> 20)
                }

                pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.mode();
                    f(&mut value);
                    self.set_mode(value)
                }

                pub fn burst(&self) -> BURST_FIELD {
                    let raw = self.raw;
                    BURST_FIELD::from_value((raw & 0x01000000) >> 24)
                }

                pub fn set_burst(&mut self, value: BURST_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_burst_with<F: Fn(&mut BURST_FIELD) -> &mut BURST_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.burst();
                    f(&mut value);
                    self.set_burst(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] RESP_FIELD u32 =>
                            // Bypass resistor ladder
                            Bypass = 0,
            // Pull-down to GND
                            Pulldown = 1,
            // Pull-up to VDD
                            Pullup = 2,
            // Set input at VDD/2
                            VDD1_2 = 3

                        );

            impl RESP_FIELD {
                pub fn is_bypass(&self) -> bool {
                    *self == Self::Bypass
                }

                pub fn set_bypass(&mut self) -> &mut Self {
                    *self = Self::Bypass;
                    self
                }

                pub fn is_pulldown(&self) -> bool {
                    *self == Self::Pulldown
                }

                pub fn set_pulldown(&mut self) -> &mut Self {
                    *self = Self::Pulldown;
                    self
                }

                pub fn is_pullup(&self) -> bool {
                    *self == Self::Pullup
                }

                pub fn set_pullup(&mut self) -> &mut Self {
                    *self = Self::Pullup;
                    self
                }

                pub fn is_vdd1_2(&self) -> bool {
                    *self == Self::VDD1_2
                }

                pub fn set_vdd1_2(&mut self) -> &mut Self {
                    *self = Self::VDD1_2;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] RESN_FIELD u32 =>
                            // Bypass resistor ladder
                            Bypass = 0,
            // Pull-down to GND
                            Pulldown = 1,
            // Pull-up to VDD
                            Pullup = 2,
            // Set input at VDD/2
                            VDD1_2 = 3

                        );

            impl RESN_FIELD {
                pub fn is_bypass(&self) -> bool {
                    *self == Self::Bypass
                }

                pub fn set_bypass(&mut self) -> &mut Self {
                    *self = Self::Bypass;
                    self
                }

                pub fn is_pulldown(&self) -> bool {
                    *self == Self::Pulldown
                }

                pub fn set_pulldown(&mut self) -> &mut Self {
                    *self = Self::Pulldown;
                    self
                }

                pub fn is_pullup(&self) -> bool {
                    *self == Self::Pullup
                }

                pub fn set_pullup(&mut self) -> &mut Self {
                    *self = Self::Pullup;
                    self
                }

                pub fn is_vdd1_2(&self) -> bool {
                    *self == Self::VDD1_2
                }

                pub fn set_vdd1_2(&mut self) -> &mut Self {
                    *self = Self::VDD1_2;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] GAIN_FIELD u32 =>
                            // 1/6
                            Gain1_6 = 0,
            // 1/5
                            Gain1_5 = 1,
            // 1/4
                            Gain1_4 = 2,
            // 1/3
                            Gain1_3 = 3,
            // 1/2
                            Gain1_2 = 4,
            // 1
                            Gain1 = 5,
            // 2
                            Gain2 = 6,
            // 4
                            Gain4 = 7

                        );

            impl GAIN_FIELD {
                pub fn is_gain1_6(&self) -> bool {
                    *self == Self::Gain1_6
                }

                pub fn set_gain1_6(&mut self) -> &mut Self {
                    *self = Self::Gain1_6;
                    self
                }

                pub fn is_gain1_5(&self) -> bool {
                    *self == Self::Gain1_5
                }

                pub fn set_gain1_5(&mut self) -> &mut Self {
                    *self = Self::Gain1_5;
                    self
                }

                pub fn is_gain1_4(&self) -> bool {
                    *self == Self::Gain1_4
                }

                pub fn set_gain1_4(&mut self) -> &mut Self {
                    *self = Self::Gain1_4;
                    self
                }

                pub fn is_gain1_3(&self) -> bool {
                    *self == Self::Gain1_3
                }

                pub fn set_gain1_3(&mut self) -> &mut Self {
                    *self = Self::Gain1_3;
                    self
                }

                pub fn is_gain1_2(&self) -> bool {
                    *self == Self::Gain1_2
                }

                pub fn set_gain1_2(&mut self) -> &mut Self {
                    *self = Self::Gain1_2;
                    self
                }

                pub fn is_gain1(&self) -> bool {
                    *self == Self::Gain1
                }

                pub fn set_gain1(&mut self) -> &mut Self {
                    *self = Self::Gain1;
                    self
                }

                pub fn is_gain2(&self) -> bool {
                    *self == Self::Gain2
                }

                pub fn set_gain2(&mut self) -> &mut Self {
                    *self = Self::Gain2;
                    self
                }

                pub fn is_gain4(&self) -> bool {
                    *self == Self::Gain4
                }

                pub fn set_gain4(&mut self) -> &mut Self {
                    *self = Self::Gain4;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] REFSEL_FIELD u32 =>
                            // Internal reference (0.6 V)
                            Internal = 0,
            // VDD/4 as reference
                            VDD1_4 = 1

                        );

            impl REFSEL_FIELD {
                pub fn is_internal(&self) -> bool {
                    *self == Self::Internal
                }

                pub fn set_internal(&mut self) -> &mut Self {
                    *self = Self::Internal;
                    self
                }

                pub fn is_vdd1_4(&self) -> bool {
                    *self == Self::VDD1_4
                }

                pub fn set_vdd1_4(&mut self) -> &mut Self {
                    *self = Self::VDD1_4;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] TACQ_FIELD u32 =>
                            // 3 us
                            _3us = 0,
            // 5 us
                            _5us = 1,
            // 10 us
                            _10us = 2,
            // 15 us
                            _15us = 3,
            // 20 us
                            _20us = 4,
            // 40 us
                            _40us = 5

                        );

            impl TACQ_FIELD {
                pub fn is_3us(&self) -> bool {
                    *self == Self::_3us
                }

                pub fn set_3us(&mut self) -> &mut Self {
                    *self = Self::_3us;
                    self
                }

                pub fn is_5us(&self) -> bool {
                    *self == Self::_5us
                }

                pub fn set_5us(&mut self) -> &mut Self {
                    *self = Self::_5us;
                    self
                }

                pub fn is_10us(&self) -> bool {
                    *self == Self::_10us
                }

                pub fn set_10us(&mut self) -> &mut Self {
                    *self = Self::_10us;
                    self
                }

                pub fn is_15us(&self) -> bool {
                    *self == Self::_15us
                }

                pub fn set_15us(&mut self) -> &mut Self {
                    *self = Self::_15us;
                    self
                }

                pub fn is_20us(&self) -> bool {
                    *self == Self::_20us
                }

                pub fn set_20us(&mut self) -> &mut Self {
                    *self = Self::_20us;
                    self
                }

                pub fn is_40us(&self) -> bool {
                    *self == Self::_40us
                }

                pub fn set_40us(&mut self) -> &mut Self {
                    *self = Self::_40us;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                            // Single-ended, PSELN will be ignored, negative input to SAADC shorted to GND
                            SE = 0,
            // Differential
                            Diff = 1

                        );

            impl MODE_FIELD {
                pub fn is_se(&self) -> bool {
                    *self == Self::SE
                }

                pub fn set_se(&mut self) -> &mut Self {
                    *self = Self::SE;
                    self
                }

                pub fn is_diff(&self) -> bool {
                    *self == Self::Diff
                }

                pub fn set_diff(&mut self) -> &mut Self {
                    *self = Self::Diff;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] BURST_FIELD u32 =>
                            // Burst mode is disabled (normal operation)
                            Disabled = 0,
            // Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM.
                            Enabled = 1

                        );

            impl BURST_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_enabled(&self) -> bool {
                    *self == Self::Enabled
                }

                pub fn set_enabled(&mut self) -> &mut Self {
                    *self = Self::Enabled;
                    self
                }
            }
        }

        pub mod limit {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct LIMIT {
                raw: RawRegister<u32>,
            }

            impl LIMIT {
                pub fn write_with<F: Fn(&mut LIMIT_VALUE) -> &mut LIMIT_VALUE>(&mut self, f: F) {
                    let mut v = LIMIT_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for LIMIT {
                type Value = LIMIT_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    LIMIT_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for LIMIT {
                type Value = LIMIT_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct LIMIT_VALUE {
                raw: u32,
            }

            impl LIMIT_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn low(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000ffff) >> 0
                }

                pub fn set_low(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ffff) | (value << 0);
                    self
                }

                pub fn high(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xffff0000) >> 16
                }

                pub fn set_high(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xffff0000) | (value << 16);
                    self
                }
            }
        }
    }

    pub mod resolution {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RESOLUTION {
            raw: RawRegister<u32>,
        }

        impl RESOLUTION {
            pub fn write_with<F: Fn(&mut RESOLUTION_VALUE) -> &mut RESOLUTION_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = RESOLUTION_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for RESOLUTION {
            type Value = RESOLUTION_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                RESOLUTION_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for RESOLUTION {
            type Value = RESOLUTION_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct RESOLUTION_VALUE {
            raw: u32,
        }

        impl RESOLUTION_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn val(&self) -> VAL_FIELD {
                let raw = self.raw;
                VAL_FIELD::from_value((raw & 0x00000007) >> 0)
            }

            pub fn set_val(&mut self, value: VAL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn set_val_with<F: Fn(&mut VAL_FIELD) -> &mut VAL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.val();
                f(&mut value);
                self.set_val(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VAL_FIELD u32 =>
                        // 8 bits
                        _8bit = 0,
        // 10 bits
                        _10bit = 1,
        // 12 bits
                        _12bit = 2,
        // 14 bits
                        _14bit = 3

                    );

        impl VAL_FIELD {
            pub fn is_8bit(&self) -> bool {
                *self == Self::_8bit
            }

            pub fn set_8bit(&mut self) -> &mut Self {
                *self = Self::_8bit;
                self
            }

            pub fn is_10bit(&self) -> bool {
                *self == Self::_10bit
            }

            pub fn set_10bit(&mut self) -> &mut Self {
                *self = Self::_10bit;
                self
            }

            pub fn is_12bit(&self) -> bool {
                *self == Self::_12bit
            }

            pub fn set_12bit(&mut self) -> &mut Self {
                *self = Self::_12bit;
                self
            }

            pub fn is_14bit(&self) -> bool {
                *self == Self::_14bit
            }

            pub fn set_14bit(&mut self) -> &mut Self {
                *self = Self::_14bit;
                self
            }
        }
    }

    pub mod oversample {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct OVERSAMPLE {
            raw: RawRegister<u32>,
        }

        impl OVERSAMPLE {
            pub fn write_bypass(&mut self) {
                self.write(OVERSAMPLE_FIELD::Bypass)
            }

            pub fn write_over2x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over2x)
            }

            pub fn write_over4x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over4x)
            }

            pub fn write_over8x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over8x)
            }

            pub fn write_over16x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over16x)
            }

            pub fn write_over32x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over32x)
            }

            pub fn write_over64x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over64x)
            }

            pub fn write_over128x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over128x)
            }

            pub fn write_over256x(&mut self) {
                self.write(OVERSAMPLE_FIELD::Over256x)
            }
        }

        impl RegisterRead for OVERSAMPLE {
            type Value = OVERSAMPLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                OVERSAMPLE_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for OVERSAMPLE {
            type Value = OVERSAMPLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVERSAMPLE_FIELD u32 =>
                        // Bypass oversampling
                        Bypass = 0,
        // Oversample 2x
                        Over2x = 1,
        // Oversample 4x
                        Over4x = 2,
        // Oversample 8x
                        Over8x = 3,
        // Oversample 16x
                        Over16x = 4,
        // Oversample 32x
                        Over32x = 5,
        // Oversample 64x
                        Over64x = 6,
        // Oversample 128x
                        Over128x = 7,
        // Oversample 256x
                        Over256x = 8

                    );

        impl OVERSAMPLE_FIELD {
            pub fn is_bypass(&self) -> bool {
                *self == Self::Bypass
            }

            pub fn set_bypass(&mut self) -> &mut Self {
                *self = Self::Bypass;
                self
            }

            pub fn is_over2x(&self) -> bool {
                *self == Self::Over2x
            }

            pub fn set_over2x(&mut self) -> &mut Self {
                *self = Self::Over2x;
                self
            }

            pub fn is_over4x(&self) -> bool {
                *self == Self::Over4x
            }

            pub fn set_over4x(&mut self) -> &mut Self {
                *self = Self::Over4x;
                self
            }

            pub fn is_over8x(&self) -> bool {
                *self == Self::Over8x
            }

            pub fn set_over8x(&mut self) -> &mut Self {
                *self = Self::Over8x;
                self
            }

            pub fn is_over16x(&self) -> bool {
                *self == Self::Over16x
            }

            pub fn set_over16x(&mut self) -> &mut Self {
                *self = Self::Over16x;
                self
            }

            pub fn is_over32x(&self) -> bool {
                *self == Self::Over32x
            }

            pub fn set_over32x(&mut self) -> &mut Self {
                *self = Self::Over32x;
                self
            }

            pub fn is_over64x(&self) -> bool {
                *self == Self::Over64x
            }

            pub fn set_over64x(&mut self) -> &mut Self {
                *self = Self::Over64x;
                self
            }

            pub fn is_over128x(&self) -> bool {
                *self == Self::Over128x
            }

            pub fn set_over128x(&mut self) -> &mut Self {
                *self = Self::Over128x;
                self
            }

            pub fn is_over256x(&self) -> bool {
                *self == Self::Over256x
            }

            pub fn set_over256x(&mut self) -> &mut Self {
                *self = Self::Over256x;
                self
            }
        }
    }

    pub mod samplerate {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SAMPLERATE {
            raw: RawRegister<u32>,
        }

        impl SAMPLERATE {
            pub fn write_with<F: Fn(&mut SAMPLERATE_VALUE) -> &mut SAMPLERATE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = SAMPLERATE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SAMPLERATE {
            type Value = SAMPLERATE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SAMPLERATE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SAMPLERATE {
            type Value = SAMPLERATE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SAMPLERATE_VALUE {
            raw: u32,
        }

        impl SAMPLERATE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cc(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x000007ff) >> 0
            }

            pub fn set_cc(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x000007ff) | (value << 0);
                self
            }

            pub fn mode(&self) -> MODE_FIELD {
                let raw = self.raw;
                MODE_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mode();
                f(&mut value);
                self.set_mode(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // Rate is controlled from SAMPLE task
                        Task = 0,
        // Rate is controlled from local timer (use CC to control the rate)
                        Timers = 1

                    );

        impl MODE_FIELD {
            pub fn is_task(&self) -> bool {
                *self == Self::Task
            }

            pub fn set_task(&mut self) -> &mut Self {
                *self = Self::Task;
                self
            }

            pub fn is_timers(&self) -> bool {
                *self == Self::Timers
            }

            pub fn set_timers(&mut self) -> &mut Self {
                *self = Self::Timers;
                self
            }
        }
    }

    pub mod result {
        #[allow(unused_imports)]
        use super::*;

        /// RESULT EasyDMA channel
        #[repr(C)]
        pub struct RESULT {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of 16-bit samples to be written to output RAM
            /// buffer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of 16-bit samples written to output RAM buffer since the
            /// previous START task
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x00007fff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x00007fff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x00007fff) >> 0
                }
            }
        }
    }
}

pub mod timer0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TIMER0 {
        _hidden: (),
    }

    impl TIMER0 {
        const BASE_ADDRESS: u32 = 0x40008000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TIMER0 {
        type Target = TIMER0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TIMER0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct TIMER0_REGISTERS {
        _hidden: (),
        /// Start Timer
        pub tasks_start: TaskRegister,
        /// Stop Timer
        pub tasks_stop: TaskRegister,
        /// Increment Timer (Counter mode only)
        pub tasks_count: TaskRegister,
        /// Clear time
        pub tasks_clear: TaskRegister,
        /// Deprecated register - Shut down timer
        pub tasks_shutdown: TaskRegister,
        _padding_20: [u8; 44],
        /// Description collection: Capture Timer value to CC[n] register
        pub tasks_capture: [TaskRegister; 6],
        _padding_88: [u8; 232],
        /// Description collection: Compare event on CC[n] match
        pub events_compare: [EventRegister; 6],
        _padding_344: [u8; 168],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 504],
        /// Timer mode selection
        pub mode: mode::MODE,
        /// Configure the number of bits used by the TIMER
        pub bitmode: bitmode::BITMODE,
        _padding_1292: [u8; 4],
        /// Timer prescaler register
        pub prescaler: prescaler::PRESCALER,
        _padding_1300: [u8; 44],
        /// Description collection: Capture/Compare register n
        pub cc: [cc::CC; 6],
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn compare0_clear(&self) -> COMPARE0_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE0_CLEAR_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_compare0_clear(&mut self, value: COMPARE0_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_compare0_clear_with<
                F: Fn(&mut COMPARE0_CLEAR_FIELD) -> &mut COMPARE0_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0_clear();
                f(&mut value);
                self.set_compare0_clear(value)
            }

            pub fn compare1_clear(&self) -> COMPARE1_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE1_CLEAR_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_compare1_clear(&mut self, value: COMPARE1_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_compare1_clear_with<
                F: Fn(&mut COMPARE1_CLEAR_FIELD) -> &mut COMPARE1_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1_clear();
                f(&mut value);
                self.set_compare1_clear(value)
            }

            pub fn compare2_clear(&self) -> COMPARE2_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE2_CLEAR_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_compare2_clear(&mut self, value: COMPARE2_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_compare2_clear_with<
                F: Fn(&mut COMPARE2_CLEAR_FIELD) -> &mut COMPARE2_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2_clear();
                f(&mut value);
                self.set_compare2_clear(value)
            }

            pub fn compare3_clear(&self) -> COMPARE3_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE3_CLEAR_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_compare3_clear(&mut self, value: COMPARE3_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_compare3_clear_with<
                F: Fn(&mut COMPARE3_CLEAR_FIELD) -> &mut COMPARE3_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3_clear();
                f(&mut value);
                self.set_compare3_clear(value)
            }

            pub fn compare4_clear(&self) -> COMPARE4_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE4_CLEAR_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_compare4_clear(&mut self, value: COMPARE4_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_compare4_clear_with<
                F: Fn(&mut COMPARE4_CLEAR_FIELD) -> &mut COMPARE4_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare4_clear();
                f(&mut value);
                self.set_compare4_clear(value)
            }

            pub fn compare5_clear(&self) -> COMPARE5_CLEAR_FIELD {
                let raw = self.raw;
                COMPARE5_CLEAR_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_compare5_clear(&mut self, value: COMPARE5_CLEAR_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_compare5_clear_with<
                F: Fn(&mut COMPARE5_CLEAR_FIELD) -> &mut COMPARE5_CLEAR_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare5_clear();
                f(&mut value);
                self.set_compare5_clear(value)
            }

            pub fn compare0_stop(&self) -> COMPARE0_STOP_FIELD {
                let raw = self.raw;
                COMPARE0_STOP_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_compare0_stop(&mut self, value: COMPARE0_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_compare0_stop_with<
                F: Fn(&mut COMPARE0_STOP_FIELD) -> &mut COMPARE0_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0_stop();
                f(&mut value);
                self.set_compare0_stop(value)
            }

            pub fn compare1_stop(&self) -> COMPARE1_STOP_FIELD {
                let raw = self.raw;
                COMPARE1_STOP_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_compare1_stop(&mut self, value: COMPARE1_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_compare1_stop_with<
                F: Fn(&mut COMPARE1_STOP_FIELD) -> &mut COMPARE1_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1_stop();
                f(&mut value);
                self.set_compare1_stop(value)
            }

            pub fn compare2_stop(&self) -> COMPARE2_STOP_FIELD {
                let raw = self.raw;
                COMPARE2_STOP_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_compare2_stop(&mut self, value: COMPARE2_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_compare2_stop_with<
                F: Fn(&mut COMPARE2_STOP_FIELD) -> &mut COMPARE2_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2_stop();
                f(&mut value);
                self.set_compare2_stop(value)
            }

            pub fn compare3_stop(&self) -> COMPARE3_STOP_FIELD {
                let raw = self.raw;
                COMPARE3_STOP_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_compare3_stop(&mut self, value: COMPARE3_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_compare3_stop_with<
                F: Fn(&mut COMPARE3_STOP_FIELD) -> &mut COMPARE3_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3_stop();
                f(&mut value);
                self.set_compare3_stop(value)
            }

            pub fn compare4_stop(&self) -> COMPARE4_STOP_FIELD {
                let raw = self.raw;
                COMPARE4_STOP_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_compare4_stop(&mut self, value: COMPARE4_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_compare4_stop_with<
                F: Fn(&mut COMPARE4_STOP_FIELD) -> &mut COMPARE4_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare4_stop();
                f(&mut value);
                self.set_compare4_stop(value)
            }

            pub fn compare5_stop(&self) -> COMPARE5_STOP_FIELD {
                let raw = self.raw;
                COMPARE5_STOP_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_compare5_stop(&mut self, value: COMPARE5_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_compare5_stop_with<
                F: Fn(&mut COMPARE5_STOP_FIELD) -> &mut COMPARE5_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare5_stop();
                f(&mut value);
                self.set_compare5_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE0_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE1_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE2_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE3_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE4_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE4_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE5_CLEAR_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE5_CLEAR_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE0_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE1_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE2_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE3_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE4_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE4_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE5_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl COMPARE5_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn compare0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }

            pub fn compare4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_compare4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_compare4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare4();
                f(&mut value);
                self.set_compare4(value)
            }

            pub fn compare5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_compare5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_compare5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare5();
                f(&mut value);
                self.set_compare5(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare4(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_compare5(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn compare0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }

            pub fn compare4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_compare4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_compare4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare4();
                f(&mut value);
                self.set_compare4(value)
            }

            pub fn compare5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_compare5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_compare5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare5();
                f(&mut value);
                self.set_compare5(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare4(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_compare5(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_timer(&mut self) {
                self.write(MODE_FIELD::Timer)
            }

            pub fn write_counter(&mut self) {
                self.write(MODE_FIELD::Counter)
            }

            pub fn write_lowpowercounter(&mut self) {
                self.write(MODE_FIELD::LowPowerCounter)
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                MODE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // Select Timer mode
                        Timer = 0,
        // Deprecated enumerator -  Select Counter mode
                        Counter = 1,
        // Select Low Power Counter mode
                        LowPowerCounter = 2

                    );

        impl MODE_FIELD {
            pub fn is_timer(&self) -> bool {
                *self == Self::Timer
            }

            pub fn set_timer(&mut self) -> &mut Self {
                *self = Self::Timer;
                self
            }

            pub fn is_counter(&self) -> bool {
                *self == Self::Counter
            }

            pub fn set_counter(&mut self) -> &mut Self {
                *self = Self::Counter;
                self
            }

            pub fn is_lowpowercounter(&self) -> bool {
                *self == Self::LowPowerCounter
            }

            pub fn set_lowpowercounter(&mut self) -> &mut Self {
                *self = Self::LowPowerCounter;
                self
            }
        }
    }

    pub mod bitmode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BITMODE {
            raw: RawRegister<u32>,
        }

        impl BITMODE {
            pub fn write_16bit(&mut self) {
                self.write(BITMODE_FIELD::_16Bit)
            }

            pub fn write_08bit(&mut self) {
                self.write(BITMODE_FIELD::_08Bit)
            }

            pub fn write_24bit(&mut self) {
                self.write(BITMODE_FIELD::_24Bit)
            }

            pub fn write_32bit(&mut self) {
                self.write(BITMODE_FIELD::_32Bit)
            }
        }

        impl RegisterRead for BITMODE {
            type Value = BITMODE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                BITMODE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for BITMODE {
            type Value = BITMODE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BITMODE_FIELD u32 =>
                        // 16 bit timer bit width
                        _16Bit = 0,
        // 8 bit timer bit width
                        _08Bit = 1,
        // 24 bit timer bit width
                        _24Bit = 2,
        // 32 bit timer bit width
                        _32Bit = 3

                    );

        impl BITMODE_FIELD {
            pub fn is_16bit(&self) -> bool {
                *self == Self::_16Bit
            }

            pub fn set_16bit(&mut self) -> &mut Self {
                *self = Self::_16Bit;
                self
            }

            pub fn is_08bit(&self) -> bool {
                *self == Self::_08Bit
            }

            pub fn set_08bit(&mut self) -> &mut Self {
                *self = Self::_08Bit;
                self
            }

            pub fn is_24bit(&self) -> bool {
                *self == Self::_24Bit
            }

            pub fn set_24bit(&mut self) -> &mut Self {
                *self = Self::_24Bit;
                self
            }

            pub fn is_32bit(&self) -> bool {
                *self == Self::_32Bit
            }

            pub fn set_32bit(&mut self) -> &mut Self {
                *self = Self::_32Bit;
                self
            }
        }
    }

    pub mod prescaler {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PRESCALER {
            raw: RawRegister<u32>,
        }

        impl PRESCALER {}

        impl RegisterRead for PRESCALER {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000000f) >> 0
            }
        }

        impl RegisterWrite for PRESCALER {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000000f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod cc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CC {
            raw: RawRegister<u32>,
        }

        impl CC {}

        impl RegisterRead for CC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for CC {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod timer1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TIMER1 {
        _hidden: (),
    }

    impl TIMER1 {
        const BASE_ADDRESS: u32 = 0x40009000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TIMER1 {
        type Target = timer0::TIMER0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TIMER1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod timer2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TIMER2 {
        _hidden: (),
    }

    impl TIMER2 {
        const BASE_ADDRESS: u32 = 0x4000a000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TIMER2 {
        type Target = timer0::TIMER0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TIMER2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod rtc0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct RTC0 {
        _hidden: (),
    }

    impl RTC0 {
        const BASE_ADDRESS: u32 = 0x4000b000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for RTC0 {
        type Target = RTC0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for RTC0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct RTC0_REGISTERS {
        _hidden: (),
        /// Start RTC COUNTER
        pub tasks_start: TaskRegister,
        /// Stop RTC COUNTER
        pub tasks_stop: TaskRegister,
        /// Clear RTC COUNTER
        pub tasks_clear: TaskRegister,
        /// Set COUNTER to 0xFFFFF0
        pub tasks_trigovrflw: TaskRegister,
        _padding_16: [u8; 240],
        /// Event on COUNTER increment
        pub events_tick: EventRegister,
        /// Event on COUNTER overflow
        pub events_ovrflw: EventRegister,
        _padding_264: [u8; 56],
        /// Description collection: Compare event on CC[n] match
        pub events_compare: [EventRegister; 4],
        _padding_336: [u8; 436],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 52],
        /// Enable or disable event routing
        pub evten: evten::EVTEN,
        /// Enable event routing
        pub evtenset: evtenset::EVTENSET,
        /// Disable event routing
        pub evtenclr: evtenclr::EVTENCLR,
        _padding_844: [u8; 440],
        /// Current COUNTER value
        pub counter: counter::COUNTER,
        /// 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must
        /// be written when RTC is stopped.
        pub prescaler: prescaler::PRESCALER,
        _padding_1292: [u8; 52],
        /// Description collection: Compare register n
        pub cc: [cc::CC; 4],
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tick(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tick(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tick_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tick();
                f(&mut value);
                self.set_tick(value)
            }

            pub fn ovrflw(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ovrflw(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ovrflw_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ovrflw();
                f(&mut value);
                self.set_ovrflw(value)
            }

            pub fn compare0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_tick(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ovrflw(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tick(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tick(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tick_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tick();
                f(&mut value);
                self.set_tick(value)
            }

            pub fn ovrflw(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ovrflw(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ovrflw_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ovrflw();
                f(&mut value);
                self.set_ovrflw(value)
            }

            pub fn compare0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_tick(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ovrflw(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }
    }

    pub mod evten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EVTEN {
            raw: RawRegister<u32>,
        }

        impl EVTEN {
            pub fn write_with<F: Fn(&mut EVTEN_VALUE) -> &mut EVTEN_VALUE>(&mut self, f: F) {
                let mut v = EVTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EVTEN {
            type Value = EVTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EVTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EVTEN {
            type Value = EVTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVTEN_VALUE {
            raw: u32,
        }

        impl EVTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tick(&self) -> TICK_FIELD {
                let raw = self.raw;
                TICK_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tick(&mut self, value: TICK_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tick_with<F: Fn(&mut TICK_FIELD) -> &mut TICK_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tick();
                f(&mut value);
                self.set_tick(value)
            }

            pub fn ovrflw(&self) -> OVRFLW_FIELD {
                let raw = self.raw;
                OVRFLW_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ovrflw(&mut self, value: OVRFLW_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ovrflw_with<F: Fn(&mut OVRFLW_FIELD) -> &mut OVRFLW_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ovrflw();
                f(&mut value);
                self.set_ovrflw(value)
            }

            pub fn compare0(&self) -> COMPARE0_FIELD {
                let raw = self.raw;
                COMPARE0_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: COMPARE0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<F: Fn(&mut COMPARE0_FIELD) -> &mut COMPARE0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> COMPARE1_FIELD {
                let raw = self.raw;
                COMPARE1_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: COMPARE1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<F: Fn(&mut COMPARE1_FIELD) -> &mut COMPARE1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> COMPARE2_FIELD {
                let raw = self.raw;
                COMPARE2_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: COMPARE2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<F: Fn(&mut COMPARE2_FIELD) -> &mut COMPARE2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> COMPARE3_FIELD {
                let raw = self.raw;
                COMPARE3_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: COMPARE3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<F: Fn(&mut COMPARE3_FIELD) -> &mut COMPARE3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TICK_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl TICK_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVRFLW_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl OVRFLW_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl COMPARE0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl COMPARE1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl COMPARE2_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Disable
                        Enabled = 1

                    );

        impl COMPARE3_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod evtenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EVTENSET {
            raw: RawRegister<u32>,
        }

        impl EVTENSET {
            pub fn write_with<F: Fn(&mut EVTENSET_WRITE_VALUE) -> &mut EVTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = EVTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EVTENSET {
            type Value = EVTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EVTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EVTENSET {
            type Value = EVTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVTENSET_READ_VALUE {
            raw: u32,
        }

        impl EVTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tick(&self) -> TICK_READ_FIELD {
                let raw = self.raw;
                TICK_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tick(&mut self, value: TICK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tick_with<F: Fn(&mut TICK_READ_FIELD) -> &mut TICK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tick();
                f(&mut value);
                self.set_tick(value)
            }

            pub fn ovrflw(&self) -> OVRFLW_READ_FIELD {
                let raw = self.raw;
                OVRFLW_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ovrflw(&mut self, value: OVRFLW_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ovrflw_with<F: Fn(&mut OVRFLW_READ_FIELD) -> &mut OVRFLW_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ovrflw();
                f(&mut value);
                self.set_ovrflw(value)
            }

            pub fn compare0(&self) -> COMPARE0_READ_FIELD {
                let raw = self.raw;
                COMPARE0_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: COMPARE0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<
                F: Fn(&mut COMPARE0_READ_FIELD) -> &mut COMPARE0_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> COMPARE1_READ_FIELD {
                let raw = self.raw;
                COMPARE1_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: COMPARE1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<
                F: Fn(&mut COMPARE1_READ_FIELD) -> &mut COMPARE1_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> COMPARE2_READ_FIELD {
                let raw = self.raw;
                COMPARE2_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: COMPARE2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<
                F: Fn(&mut COMPARE2_READ_FIELD) -> &mut COMPARE2_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> COMPARE3_READ_FIELD {
                let raw = self.raw;
                COMPARE3_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: COMPARE3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<
                F: Fn(&mut COMPARE3_READ_FIELD) -> &mut COMPARE3_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl EVTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_tick(&mut self) -> &mut Self {
                let value = TICK_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ovrflw(&mut self) -> &mut Self {
                let value = OVRFLW_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = COMPARE0_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = COMPARE1_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = COMPARE2_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = COMPARE3_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TICK_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl TICK_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TICK_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl TICK_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVRFLW_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl OVRFLW_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVRFLW_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl OVRFLW_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE0_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl COMPARE0_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE1_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl COMPARE1_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE2_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl COMPARE2_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE3_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl COMPARE3_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod evtenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EVTENCLR {
            raw: RawRegister<u32>,
        }

        impl EVTENCLR {
            pub fn write_with<F: Fn(&mut EVTENCLR_WRITE_VALUE) -> &mut EVTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = EVTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EVTENCLR {
            type Value = EVTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EVTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EVTENCLR {
            type Value = EVTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVTENCLR_READ_VALUE {
            raw: u32,
        }

        impl EVTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn tick(&self) -> TICK_READ_FIELD {
                let raw = self.raw;
                TICK_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_tick(&mut self, value: TICK_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_tick_with<F: Fn(&mut TICK_READ_FIELD) -> &mut TICK_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.tick();
                f(&mut value);
                self.set_tick(value)
            }

            pub fn ovrflw(&self) -> OVRFLW_READ_FIELD {
                let raw = self.raw;
                OVRFLW_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ovrflw(&mut self, value: OVRFLW_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ovrflw_with<F: Fn(&mut OVRFLW_READ_FIELD) -> &mut OVRFLW_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ovrflw();
                f(&mut value);
                self.set_ovrflw(value)
            }

            pub fn compare0(&self) -> COMPARE0_READ_FIELD {
                let raw = self.raw;
                COMPARE0_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_compare0(&mut self, value: COMPARE0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare0_with<
                F: Fn(&mut COMPARE0_READ_FIELD) -> &mut COMPARE0_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare0();
                f(&mut value);
                self.set_compare0(value)
            }

            pub fn compare1(&self) -> COMPARE1_READ_FIELD {
                let raw = self.raw;
                COMPARE1_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_compare1(&mut self, value: COMPARE1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare1_with<
                F: Fn(&mut COMPARE1_READ_FIELD) -> &mut COMPARE1_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare1();
                f(&mut value);
                self.set_compare1(value)
            }

            pub fn compare2(&self) -> COMPARE2_READ_FIELD {
                let raw = self.raw;
                COMPARE2_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_compare2(&mut self, value: COMPARE2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare2_with<
                F: Fn(&mut COMPARE2_READ_FIELD) -> &mut COMPARE2_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare2();
                f(&mut value);
                self.set_compare2(value)
            }

            pub fn compare3(&self) -> COMPARE3_READ_FIELD {
                let raw = self.raw;
                COMPARE3_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_compare3(&mut self, value: COMPARE3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_compare3_with<
                F: Fn(&mut COMPARE3_READ_FIELD) -> &mut COMPARE3_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.compare3();
                f(&mut value);
                self.set_compare3(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl EVTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_tick(&mut self) -> &mut Self {
                let value = TICK_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ovrflw(&mut self) -> &mut Self {
                let value = OVRFLW_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_compare0(&mut self) -> &mut Self {
                let value = COMPARE0_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_compare1(&mut self) -> &mut Self {
                let value = COMPARE1_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_compare2(&mut self) -> &mut Self {
                let value = COMPARE2_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_compare3(&mut self) -> &mut Self {
                let value = COMPARE3_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TICK_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl TICK_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TICK_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl TICK_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVRFLW_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl OVRFLW_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OVRFLW_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl OVRFLW_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE0_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE0_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl COMPARE0_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE1_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE1_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl COMPARE1_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE2_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE2_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl COMPARE2_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl COMPARE3_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] COMPARE3_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl COMPARE3_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod counter {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct COUNTER {
            raw: RawRegister<u32>,
        }

        impl COUNTER {}

        impl RegisterRead for COUNTER {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00ffffff) >> 0
            }
        }
    }

    pub mod prescaler {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PRESCALER {
            raw: RawRegister<u32>,
        }

        impl PRESCALER {}

        impl RegisterRead for PRESCALER {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for PRESCALER {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod cc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CC {
            raw: RawRegister<u32>,
        }

        impl CC {
            pub fn write_with<F: Fn(&mut CC_VALUE) -> &mut CC_VALUE>(&mut self, f: F) {
                let mut v = CC_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CC {
            type Value = CC_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CC_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CC {
            type Value = CC_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CC_VALUE {
            raw: u32,
        }

        impl CC_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn compare(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00ffffff) >> 0
            }

            pub fn set_compare(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00ffffff) | (value << 0);
                self
            }
        }
    }
}

pub mod temp {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TEMP {
        _hidden: (),
    }

    impl TEMP {
        const BASE_ADDRESS: u32 = 0x4000c000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TEMP {
        type Target = TEMP_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TEMP {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct TEMP_REGISTERS {
        _hidden: (),
        /// Start temperature measurement
        pub tasks_start: TaskRegister,
        /// Stop temperature measurement
        pub tasks_stop: TaskRegister,
        _padding_8: [u8; 248],
        /// Temperature measurement complete, data ready
        pub events_datardy: EventRegister,
        _padding_260: [u8; 512],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 508],
        /// Temperature in degC (0.25deg steps)
        pub temp: temp::TEMP,
        _padding_1292: [u8; 20],
        /// Slope of first piecewise linear function
        pub a0: a0::A0,
        /// Slope of second piecewise linear function
        pub a1: a1::A1,
        /// Slope of third piecewise linear function
        pub a2: a2::A2,
        /// Slope of fourth piecewise linear function
        pub a3: a3::A3,
        /// Slope of fifth piecewise linear function
        pub a4: a4::A4,
        /// Slope of sixth piecewise linear function
        pub a5: a5::A5,
        _padding_1336: [u8; 8],
        /// y-intercept of first piecewise linear function
        pub b0: b0::B0,
        /// y-intercept of second piecewise linear function
        pub b1: b1::B1,
        /// y-intercept of third piecewise linear function
        pub b2: b2::B2,
        /// y-intercept of fourth piecewise linear function
        pub b3: b3::B3,
        /// y-intercept of fifth piecewise linear function
        pub b4: b4::B4,
        /// y-intercept of sixth piecewise linear function
        pub b5: b5::B5,
        _padding_1368: [u8; 8],
        /// End point of first piecewise linear function
        pub t0: t0::T0,
        /// End point of second piecewise linear function
        pub t1: t1::T1,
        /// End point of third piecewise linear function
        pub t2: t2::T2,
        /// End point of fourth piecewise linear function
        pub t3: t3::T3,
        /// End point of fifth piecewise linear function
        pub t4: t4::T4,
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn datardy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_datardy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_datardy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.datardy();
                f(&mut value);
                self.set_datardy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_datardy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn datardy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_datardy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_datardy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.datardy();
                f(&mut value);
                self.set_datardy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_datardy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod temp {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TEMP {
            raw: RawRegister<u32>,
        }

        impl TEMP {}

        impl RegisterRead for TEMP {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod a0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A0 {
            raw: RawRegister<u32>,
        }

        impl A0 {}

        impl RegisterRead for A0 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A0 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod a1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A1 {
            raw: RawRegister<u32>,
        }

        impl A1 {}

        impl RegisterRead for A1 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A1 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod a2 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A2 {
            raw: RawRegister<u32>,
        }

        impl A2 {}

        impl RegisterRead for A2 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A2 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod a3 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A3 {
            raw: RawRegister<u32>,
        }

        impl A3 {}

        impl RegisterRead for A3 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A3 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod a4 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A4 {
            raw: RawRegister<u32>,
        }

        impl A4 {}

        impl RegisterRead for A4 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A4 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod a5 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct A5 {
            raw: RawRegister<u32>,
        }

        impl A5 {}

        impl RegisterRead for A5 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00000fff) >> 0
            }
        }

        impl RegisterWrite for A5 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00000fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B0 {
            raw: RawRegister<u32>,
        }

        impl B0 {}

        impl RegisterRead for B0 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B0 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B1 {
            raw: RawRegister<u32>,
        }

        impl B1 {}

        impl RegisterRead for B1 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B1 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b2 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B2 {
            raw: RawRegister<u32>,
        }

        impl B2 {}

        impl RegisterRead for B2 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B2 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b3 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B3 {
            raw: RawRegister<u32>,
        }

        impl B3 {}

        impl RegisterRead for B3 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B3 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b4 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B4 {
            raw: RawRegister<u32>,
        }

        impl B4 {}

        impl RegisterRead for B4 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B4 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod b5 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct B5 {
            raw: RawRegister<u32>,
        }

        impl B5 {}

        impl RegisterRead for B5 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00003fff) >> 0
            }
        }

        impl RegisterWrite for B5 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00003fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod t0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct T0 {
            raw: RawRegister<u32>,
        }

        impl T0 {}

        impl RegisterRead for T0 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for T0 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod t1 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct T1 {
            raw: RawRegister<u32>,
        }

        impl T1 {}

        impl RegisterRead for T1 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for T1 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod t2 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct T2 {
            raw: RawRegister<u32>,
        }

        impl T2 {}

        impl RegisterRead for T2 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for T2 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod t3 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct T3 {
            raw: RawRegister<u32>,
        }

        impl T3 {}

        impl RegisterRead for T3 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for T3 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod t4 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct T4 {
            raw: RawRegister<u32>,
        }

        impl T4 {}

        impl RegisterRead for T4 {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for T4 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod rng {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct RNG {
        _hidden: (),
    }

    impl RNG {
        const BASE_ADDRESS: u32 = 0x4000d000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for RNG {
        type Target = RNG_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for RNG {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct RNG_REGISTERS {
        _hidden: (),
        /// Task starting the random number generator
        pub tasks_start: TaskRegister,
        /// Task stopping the random number generator
        pub tasks_stop: TaskRegister,
        _padding_8: [u8; 248],
        /// Event being generated for every new random number written to the
        /// VALUE register
        pub events_valrdy: EventRegister,
        _padding_260: [u8; 252],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 504],
        /// Configuration register
        pub config: config::CONFIG,
        /// Output random number
        pub value: value::VALUE,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn valrdy_stop(&self) -> VALRDY_STOP_FIELD {
                let raw = self.raw;
                VALRDY_STOP_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_valrdy_stop(&mut self, value: VALRDY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_valrdy_stop_with<F: Fn(&mut VALRDY_STOP_FIELD) -> &mut VALRDY_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.valrdy_stop();
                f(&mut value);
                self.set_valrdy_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VALRDY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl VALRDY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn valrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_valrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_valrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.valrdy();
                f(&mut value);
                self.set_valrdy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_valrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn valrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_valrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_valrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.valrdy();
                f(&mut value);
                self.set_valrdy(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_valrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn dercen(&self) -> DERCEN_FIELD {
                let raw = self.raw;
                DERCEN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_dercen(&mut self, value: DERCEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_dercen_with<F: Fn(&mut DERCEN_FIELD) -> &mut DERCEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dercen();
                f(&mut value);
                self.set_dercen(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DERCEN_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enabled
                        Enabled = 1

                    );

        impl DERCEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod value {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct VALUE {
            raw: RawRegister<u32>,
        }

        impl VALUE {}

        impl RegisterRead for VALUE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }
}

pub mod ecb {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct ECB {
        _hidden: (),
    }

    impl ECB {
        const BASE_ADDRESS: u32 = 0x4000e000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for ECB {
        type Target = ECB_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for ECB {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct ECB_REGISTERS {
        _hidden: (),
        /// Start ECB block encrypt
        pub tasks_startecb: TaskRegister,
        /// Abort a possible executing ECB operation
        pub tasks_stopecb: TaskRegister,
        _padding_8: [u8; 248],
        /// ECB block encrypt complete
        pub events_endecb: EventRegister,
        /// ECB block encrypt aborted because of a STOPECB task or due to an
        /// error
        pub events_errorecb: EventRegister,
        _padding_264: [u8; 508],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 504],
        /// ECB block encrypt memory pointers
        pub ecbdataptr: ecbdataptr::ECBDATAPTR,
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endecb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_endecb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endecb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endecb();
                f(&mut value);
                self.set_endecb(value)
            }

            pub fn errorecb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_errorecb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_errorecb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.errorecb();
                f(&mut value);
                self.set_errorecb(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_endecb(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_errorecb(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endecb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_endecb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endecb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endecb();
                f(&mut value);
                self.set_endecb(value)
            }

            pub fn errorecb(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_errorecb(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_errorecb_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.errorecb();
                f(&mut value);
                self.set_errorecb(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_endecb(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_errorecb(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }
        }
    }

    pub mod ecbdataptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ECBDATAPTR {
            raw: RawRegister<u32>,
        }

        impl ECBDATAPTR {}

        impl RegisterRead for ECBDATAPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for ECBDATAPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod aar {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct AAR {
        _hidden: (),
    }

    impl AAR {
        const BASE_ADDRESS: u32 = 0x4000f000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for AAR {
        type Target = AAR_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for AAR {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct AAR_REGISTERS {
        _hidden: (),
        /// Start resolving addresses based on IRKs specified in the IRK data
        /// structure
        pub tasks_start: TaskRegister,
        _padding_4: [u8; 4],
        /// Stop resolving addresses
        pub tasks_stop: TaskRegister,
        _padding_12: [u8; 244],
        /// Address resolution procedure complete
        pub events_end: EventRegister,
        /// Address resolved
        pub events_resolved: EventRegister,
        /// Address not resolved
        pub events_notresolved: EventRegister,
        _padding_268: [u8; 504],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Resolution status
        pub status: status::STATUS,
        _padding_1028: [u8; 252],
        /// Enable AAR
        pub enable: enable::ENABLE,
        /// Number of IRKs
        pub nirk: nirk::NIRK,
        /// Pointer to IRK data structure
        pub irkptr: irkptr::IRKPTR,
        _padding_1292: [u8; 4],
        /// Pointer to the resolvable address
        pub addrptr: addrptr::ADDRPTR,
        /// Pointer to data area used for temporary storage
        pub scratchptr: scratchptr::SCRATCHPTR,
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn resolved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_resolved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_resolved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resolved();
                f(&mut value);
                self.set_resolved(value)
            }

            pub fn notresolved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_notresolved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_notresolved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.notresolved();
                f(&mut value);
                self.set_notresolved(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_resolved(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_notresolved(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }

            pub fn resolved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_resolved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_resolved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resolved();
                f(&mut value);
                self.set_resolved(value)
            }

            pub fn notresolved(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_notresolved(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_notresolved_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.notresolved();
                f(&mut value);
                self.set_notresolved(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_resolved(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_notresolved(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod status {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct STATUS {
            raw: RawRegister<u32>,
        }

        impl STATUS {}

        impl RegisterRead for STATUS {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000000f) >> 0
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 3

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod nirk {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NIRK {
            raw: RawRegister<u32>,
        }

        impl NIRK {}

        impl RegisterRead for NIRK {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000001f) >> 0
            }
        }

        impl RegisterWrite for NIRK {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x0000001f) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod irkptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct IRKPTR {
            raw: RawRegister<u32>,
        }

        impl IRKPTR {}

        impl RegisterRead for IRKPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for IRKPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod addrptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ADDRPTR {
            raw: RawRegister<u32>,
        }

        impl ADDRPTR {}

        impl RegisterRead for ADDRPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for ADDRPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod scratchptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SCRATCHPTR {
            raw: RawRegister<u32>,
        }

        impl SCRATCHPTR {}

        impl RegisterRead for SCRATCHPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for SCRATCHPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod ccm {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct CCM {
        _hidden: (),
    }

    impl CCM {
        const BASE_ADDRESS: u32 = 0x4000f000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for CCM {
        type Target = CCM_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for CCM {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct CCM_REGISTERS {
        _hidden: (),
        /// Start generation of keystream. This operation will stop by itself
        /// when completed.
        pub tasks_ksgen: TaskRegister,
        /// Start encryption/decryption. This operation will stop by itself when
        /// completed.
        pub tasks_crypt: TaskRegister,
        /// Stop encryption/decryption
        pub tasks_stop: TaskRegister,
        /// Override DATARATE setting in MODE register with the contents of the
        /// RATEOVERRIDE register for any ongoing encryption/decryption
        pub tasks_rateoverride: TaskRegister,
        _padding_16: [u8; 240],
        /// Keystream generation complete
        pub events_endksgen: EventRegister,
        /// Encrypt/decrypt complete
        pub events_endcrypt: EventRegister,
        /// Deprecated register - CCM error event
        pub events_error: EventRegister,
        _padding_268: [u8; 244],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// MIC check result
        pub micstatus: micstatus::MICSTATUS,
        _padding_1028: [u8; 252],
        /// Enable
        pub enable: enable::ENABLE,
        /// Operation mode
        pub mode: mode::MODE,
        /// Pointer to data structure holding the AES key and the NONCE vector
        pub cnfptr: cnfptr::CNFPTR,
        /// Input pointer
        pub inptr: inptr::INPTR,
        /// Output pointer
        pub outptr: outptr::OUTPTR,
        /// Pointer to data area used for temporary storage
        pub scratchptr: scratchptr::SCRATCHPTR,
        /// Length of keystream generated when MODE.LENGTH = Extended
        pub maxpacketsize: maxpacketsize::MAXPACKETSIZE,
        /// Data rate override setting.
        pub rateoverride: rateoverride::RATEOVERRIDE,
        /// Header (S0) mask.
        pub headermask: headermask::HEADERMASK,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endksgen_crypt(&self) -> ENDKSGEN_CRYPT_FIELD {
                let raw = self.raw;
                ENDKSGEN_CRYPT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_endksgen_crypt(&mut self, value: ENDKSGEN_CRYPT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endksgen_crypt_with<
                F: Fn(&mut ENDKSGEN_CRYPT_FIELD) -> &mut ENDKSGEN_CRYPT_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endksgen_crypt();
                f(&mut value);
                self.set_endksgen_crypt(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDKSGEN_CRYPT_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ENDKSGEN_CRYPT_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endksgen(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_endksgen(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endksgen_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endksgen();
                f(&mut value);
                self.set_endksgen(value)
            }

            pub fn endcrypt(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_endcrypt(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endcrypt_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endcrypt();
                f(&mut value);
                self.set_endcrypt(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_endksgen(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endcrypt(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn endksgen(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_endksgen(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endksgen_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endksgen();
                f(&mut value);
                self.set_endksgen(value)
            }

            pub fn endcrypt(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_endcrypt(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endcrypt_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endcrypt();
                f(&mut value);
                self.set_endcrypt(value)
            }

            pub fn error(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_error(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_error_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.error();
                f(&mut value);
                self.set_error(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_endksgen(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_endcrypt(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_error(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod micstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MICSTATUS {
            raw: RawRegister<u32>,
        }

        impl MICSTATUS {}

        impl RegisterRead for MICSTATUS {
            type Value = MICSTATUS_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                MICSTATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MICSTATUS_FIELD u32 =>
                        // MIC check failed
                        CheckFailed = 0,
        // MIC check passed
                        CheckPassed = 1

                    );

        impl MICSTATUS_FIELD {
            pub fn is_checkfailed(&self) -> bool {
                *self == Self::CheckFailed
            }

            pub fn set_checkfailed(&mut self) -> &mut Self {
                *self = Self::CheckFailed;
                self
            }

            pub fn is_checkpassed(&self) -> bool {
                *self == Self::CheckPassed
            }

            pub fn set_checkpassed(&mut self) -> &mut Self {
                *self = Self::CheckPassed;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 2

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_with<F: Fn(&mut MODE_VALUE) -> &mut MODE_VALUE>(&mut self, f: F) {
                let mut v = MODE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODE_VALUE {
            raw: u32,
        }

        impl MODE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn mode(&self) -> MODE_FIELD {
                let raw = self.raw;
                MODE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mode();
                f(&mut value);
                self.set_mode(value)
            }

            pub fn datarate(&self) -> DATARATE_FIELD {
                let raw = self.raw;
                DATARATE_FIELD::from_value((raw & 0x00030000) >> 16)
            }

            pub fn set_datarate(&mut self, value: DATARATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00030000) | (value << 16);
                self
            }

            pub fn set_datarate_with<F: Fn(&mut DATARATE_FIELD) -> &mut DATARATE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.datarate();
                f(&mut value);
                self.set_datarate(value)
            }

            pub fn length(&self) -> LENGTH_FIELD {
                let raw = self.raw;
                LENGTH_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_length(&mut self, value: LENGTH_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_length_with<F: Fn(&mut LENGTH_FIELD) -> &mut LENGTH_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.length();
                f(&mut value);
                self.set_length(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // AES CCM packet encryption mode
                        Encryption = 0,
        // AES CCM packet decryption mode
                        Decryption = 1

                    );

        impl MODE_FIELD {
            pub fn is_encryption(&self) -> bool {
                *self == Self::Encryption
            }

            pub fn set_encryption(&mut self) -> &mut Self {
                *self = Self::Encryption;
                self
            }

            pub fn is_decryption(&self) -> bool {
                *self == Self::Decryption
            }

            pub fn set_decryption(&mut self) -> &mut Self {
                *self = Self::Decryption;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DATARATE_FIELD u32 =>
                        // 1 Mbps
                        _1Mbit = 0,
        // 2 Mbps
                        _2Mbit = 1,
        // 125 kbps
                        _125Kbps = 2,
        // 500 kbps
                        _500Kbps = 3

                    );

        impl DATARATE_FIELD {
            pub fn is_1mbit(&self) -> bool {
                *self == Self::_1Mbit
            }

            pub fn set_1mbit(&mut self) -> &mut Self {
                *self = Self::_1Mbit;
                self
            }

            pub fn is_2mbit(&self) -> bool {
                *self == Self::_2Mbit
            }

            pub fn set_2mbit(&mut self) -> &mut Self {
                *self = Self::_2Mbit;
                self
            }

            pub fn is_125kbps(&self) -> bool {
                *self == Self::_125Kbps
            }

            pub fn set_125kbps(&mut self) -> &mut Self {
                *self = Self::_125Kbps;
                self
            }

            pub fn is_500kbps(&self) -> bool {
                *self == Self::_500Kbps
            }

            pub fn set_500kbps(&mut self) -> &mut Self {
                *self = Self::_500Kbps;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LENGTH_FIELD u32 =>
                        // Default length. Effective length of LENGTH field in encrypted/decrypted packet is 5 bits. A keystream for packet payloads up to 27 bytes will be generated.
                        Default = 0,
        // Extended length. Effective length of LENGTH field in encrypted/decrypted packet is 8 bits. A keystream for packet payloads up to MAXPACKETSIZE bytes will be generated.
                        Extended = 1

                    );

        impl LENGTH_FIELD {
            pub fn is_default(&self) -> bool {
                *self == Self::Default
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::Default;
                self
            }

            pub fn is_extended(&self) -> bool {
                *self == Self::Extended
            }

            pub fn set_extended(&mut self) -> &mut Self {
                *self = Self::Extended;
                self
            }
        }
    }

    pub mod cnfptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CNFPTR {
            raw: RawRegister<u32>,
        }

        impl CNFPTR {}

        impl RegisterRead for CNFPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for CNFPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod inptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INPTR {
            raw: RawRegister<u32>,
        }

        impl INPTR {}

        impl RegisterRead for INPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for INPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod outptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct OUTPTR {
            raw: RawRegister<u32>,
        }

        impl OUTPTR {}

        impl RegisterRead for OUTPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for OUTPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod scratchptr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SCRATCHPTR {
            raw: RawRegister<u32>,
        }

        impl SCRATCHPTR {}

        impl RegisterRead for SCRATCHPTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for SCRATCHPTR {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod maxpacketsize {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MAXPACKETSIZE {
            raw: RawRegister<u32>,
        }

        impl MAXPACKETSIZE {}

        impl RegisterRead for MAXPACKETSIZE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for MAXPACKETSIZE {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod rateoverride {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RATEOVERRIDE {
            raw: RawRegister<u32>,
        }

        impl RATEOVERRIDE {
            pub fn write_1mbit(&mut self) {
                self.write(RATEOVERRIDE_FIELD::_1Mbit)
            }

            pub fn write_2mbit(&mut self) {
                self.write(RATEOVERRIDE_FIELD::_2Mbit)
            }

            pub fn write_125kbps(&mut self) {
                self.write(RATEOVERRIDE_FIELD::_125Kbps)
            }

            pub fn write_500kbps(&mut self) {
                self.write(RATEOVERRIDE_FIELD::_500Kbps)
            }
        }

        impl RegisterRead for RATEOVERRIDE {
            type Value = RATEOVERRIDE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                RATEOVERRIDE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for RATEOVERRIDE {
            type Value = RATEOVERRIDE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RATEOVERRIDE_FIELD u32 =>
                        // 1 Mbps
                        _1Mbit = 0,
        // 2 Mbps
                        _2Mbit = 1,
        // 125 kbps
                        _125Kbps = 2,
        // 500 kbps
                        _500Kbps = 3

                    );

        impl RATEOVERRIDE_FIELD {
            pub fn is_1mbit(&self) -> bool {
                *self == Self::_1Mbit
            }

            pub fn set_1mbit(&mut self) -> &mut Self {
                *self = Self::_1Mbit;
                self
            }

            pub fn is_2mbit(&self) -> bool {
                *self == Self::_2Mbit
            }

            pub fn set_2mbit(&mut self) -> &mut Self {
                *self = Self::_2Mbit;
                self
            }

            pub fn is_125kbps(&self) -> bool {
                *self == Self::_125Kbps
            }

            pub fn set_125kbps(&mut self) -> &mut Self {
                *self = Self::_125Kbps;
                self
            }

            pub fn is_500kbps(&self) -> bool {
                *self == Self::_500Kbps
            }

            pub fn set_500kbps(&mut self) -> &mut Self {
                *self = Self::_500Kbps;
                self
            }
        }
    }

    pub mod headermask {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HEADERMASK {
            raw: RawRegister<u32>,
        }

        impl HEADERMASK {}

        impl RegisterRead for HEADERMASK {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }

        impl RegisterWrite for HEADERMASK {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000000ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }
}

pub mod wdt {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct WDT {
        _hidden: (),
    }

    impl WDT {
        const BASE_ADDRESS: u32 = 0x40010000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for WDT {
        type Target = WDT_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for WDT {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct WDT_REGISTERS {
        _hidden: (),
        /// Start the watchdog
        pub tasks_start: TaskRegister,
        _padding_4: [u8; 252],
        /// Watchdog timeout
        pub events_timeout: EventRegister,
        _padding_260: [u8; 512],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Run status
        pub runstatus: runstatus::RUNSTATUS,
        /// Request status
        pub reqstatus: reqstatus::REQSTATUS,
        _padding_1032: [u8; 252],
        /// Counter reload value
        pub crv: crv::CRV,
        /// Enable register for reload request registers
        pub rren: rren::RREN,
        /// Configuration register
        pub config: config::CONFIG,
        _padding_1296: [u8; 240],
        /// Description collection: Reload request n
        pub rr: [rr::RR; 8],
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn timeout(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_timeout(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_timeout_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.timeout();
                f(&mut value);
                self.set_timeout(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_timeout(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn timeout(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_timeout(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_timeout_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.timeout();
                f(&mut value);
                self.set_timeout(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_timeout(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }
        }
    }

    pub mod runstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RUNSTATUS {
            raw: RawRegister<u32>,
        }

        impl RUNSTATUS {}

        impl RegisterRead for RUNSTATUS {
            type Value = RUNSTATUS_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                RUNSTATUS_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RUNSTATUS_FIELD u32 =>
                        // Watchdog not running
                        NotRunning = 0,
        // Watchdog is running
                        Running = 1

                    );

        impl RUNSTATUS_FIELD {
            pub fn is_notrunning(&self) -> bool {
                *self == Self::NotRunning
            }

            pub fn set_notrunning(&mut self) -> &mut Self {
                *self = Self::NotRunning;
                self
            }

            pub fn is_running(&self) -> bool {
                *self == Self::Running
            }

            pub fn set_running(&mut self) -> &mut Self {
                *self = Self::Running;
                self
            }
        }
    }

    pub mod reqstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REQSTATUS {
            raw: RawRegister<u32>,
        }

        impl REQSTATUS {}

        impl RegisterRead for REQSTATUS {
            type Value = REQSTATUS_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                REQSTATUS_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REQSTATUS_READ_VALUE {
            raw: u32,
        }

        impl REQSTATUS_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rr0(&self) -> RR0_FIELD {
                let raw = self.raw;
                RR0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_rr0(&mut self, value: RR0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rr0_with<F: Fn(&mut RR0_FIELD) -> &mut RR0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr0();
                f(&mut value);
                self.set_rr0(value)
            }

            pub fn rr1(&self) -> RR1_FIELD {
                let raw = self.raw;
                RR1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rr1(&mut self, value: RR1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rr1_with<F: Fn(&mut RR1_FIELD) -> &mut RR1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr1();
                f(&mut value);
                self.set_rr1(value)
            }

            pub fn rr2(&self) -> RR2_FIELD {
                let raw = self.raw;
                RR2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rr2(&mut self, value: RR2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rr2_with<F: Fn(&mut RR2_FIELD) -> &mut RR2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr2();
                f(&mut value);
                self.set_rr2(value)
            }

            pub fn rr3(&self) -> RR3_FIELD {
                let raw = self.raw;
                RR3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_rr3(&mut self, value: RR3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rr3_with<F: Fn(&mut RR3_FIELD) -> &mut RR3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr3();
                f(&mut value);
                self.set_rr3(value)
            }

            pub fn rr4(&self) -> RR4_FIELD {
                let raw = self.raw;
                RR4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_rr4(&mut self, value: RR4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rr4_with<F: Fn(&mut RR4_FIELD) -> &mut RR4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr4();
                f(&mut value);
                self.set_rr4(value)
            }

            pub fn rr5(&self) -> RR5_FIELD {
                let raw = self.raw;
                RR5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rr5(&mut self, value: RR5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rr5_with<F: Fn(&mut RR5_FIELD) -> &mut RR5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr5();
                f(&mut value);
                self.set_rr5(value)
            }

            pub fn rr6(&self) -> RR6_FIELD {
                let raw = self.raw;
                RR6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rr6(&mut self, value: RR6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rr6_with<F: Fn(&mut RR6_FIELD) -> &mut RR6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr6();
                f(&mut value);
                self.set_rr6(value)
            }

            pub fn rr7(&self) -> RR7_FIELD {
                let raw = self.raw;
                RR7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rr7(&mut self, value: RR7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rr7_with<F: Fn(&mut RR7_FIELD) -> &mut RR7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr7();
                f(&mut value);
                self.set_rr7(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR0_FIELD u32 =>
                        // RR[0] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[0] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR0_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR1_FIELD u32 =>
                        // RR[1] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[1] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR1_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR2_FIELD u32 =>
                        // RR[2] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[2] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR2_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR3_FIELD u32 =>
                        // RR[3] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[3] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR3_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR4_FIELD u32 =>
                        // RR[4] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[4] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR4_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR5_FIELD u32 =>
                        // RR[5] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[5] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR5_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR6_FIELD u32 =>
                        // RR[6] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[6] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR6_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR7_FIELD u32 =>
                        // RR[7] register is not enabled, or are already requesting reload
                        DisabledOrRequested = 0,
        // RR[7] register is enabled, and are not yet requesting reload
                        EnabledAndUnrequested = 1

                    );

        impl RR7_FIELD {
            pub fn is_disabledorrequested(&self) -> bool {
                *self == Self::DisabledOrRequested
            }

            pub fn set_disabledorrequested(&mut self) -> &mut Self {
                *self = Self::DisabledOrRequested;
                self
            }

            pub fn is_enabledandunrequested(&self) -> bool {
                *self == Self::EnabledAndUnrequested
            }

            pub fn set_enabledandunrequested(&mut self) -> &mut Self {
                *self = Self::EnabledAndUnrequested;
                self
            }
        }
    }

    pub mod crv {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CRV {
            raw: RawRegister<u32>,
        }

        impl CRV {}

        impl RegisterRead for CRV {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }

        impl RegisterWrite for CRV {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod rren {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RREN {
            raw: RawRegister<u32>,
        }

        impl RREN {
            pub fn write_with<F: Fn(&mut RREN_VALUE) -> &mut RREN_VALUE>(&mut self, f: F) {
                let mut v = RREN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for RREN {
            type Value = RREN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                RREN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for RREN {
            type Value = RREN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct RREN_VALUE {
            raw: u32,
        }

        impl RREN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rr0(&self) -> RR0_FIELD {
                let raw = self.raw;
                RR0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_rr0(&mut self, value: RR0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rr0_with<F: Fn(&mut RR0_FIELD) -> &mut RR0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr0();
                f(&mut value);
                self.set_rr0(value)
            }

            pub fn rr1(&self) -> RR1_FIELD {
                let raw = self.raw;
                RR1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rr1(&mut self, value: RR1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rr1_with<F: Fn(&mut RR1_FIELD) -> &mut RR1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr1();
                f(&mut value);
                self.set_rr1(value)
            }

            pub fn rr2(&self) -> RR2_FIELD {
                let raw = self.raw;
                RR2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rr2(&mut self, value: RR2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rr2_with<F: Fn(&mut RR2_FIELD) -> &mut RR2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr2();
                f(&mut value);
                self.set_rr2(value)
            }

            pub fn rr3(&self) -> RR3_FIELD {
                let raw = self.raw;
                RR3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_rr3(&mut self, value: RR3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rr3_with<F: Fn(&mut RR3_FIELD) -> &mut RR3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr3();
                f(&mut value);
                self.set_rr3(value)
            }

            pub fn rr4(&self) -> RR4_FIELD {
                let raw = self.raw;
                RR4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_rr4(&mut self, value: RR4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rr4_with<F: Fn(&mut RR4_FIELD) -> &mut RR4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr4();
                f(&mut value);
                self.set_rr4(value)
            }

            pub fn rr5(&self) -> RR5_FIELD {
                let raw = self.raw;
                RR5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rr5(&mut self, value: RR5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rr5_with<F: Fn(&mut RR5_FIELD) -> &mut RR5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr5();
                f(&mut value);
                self.set_rr5(value)
            }

            pub fn rr6(&self) -> RR6_FIELD {
                let raw = self.raw;
                RR6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rr6(&mut self, value: RR6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rr6_with<F: Fn(&mut RR6_FIELD) -> &mut RR6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr6();
                f(&mut value);
                self.set_rr6(value)
            }

            pub fn rr7(&self) -> RR7_FIELD {
                let raw = self.raw;
                RR7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rr7(&mut self, value: RR7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rr7_with<F: Fn(&mut RR7_FIELD) -> &mut RR7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rr7();
                f(&mut value);
                self.set_rr7(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR0_FIELD u32 =>
                        // Disable RR[0] register
                        Disabled = 0,
        // Enable RR[0] register
                        Enabled = 1

                    );

        impl RR0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR1_FIELD u32 =>
                        // Disable RR[1] register
                        Disabled = 0,
        // Enable RR[1] register
                        Enabled = 1

                    );

        impl RR1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR2_FIELD u32 =>
                        // Disable RR[2] register
                        Disabled = 0,
        // Enable RR[2] register
                        Enabled = 1

                    );

        impl RR2_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR3_FIELD u32 =>
                        // Disable RR[3] register
                        Disabled = 0,
        // Enable RR[3] register
                        Enabled = 1

                    );

        impl RR3_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR4_FIELD u32 =>
                        // Disable RR[4] register
                        Disabled = 0,
        // Enable RR[4] register
                        Enabled = 1

                    );

        impl RR4_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR5_FIELD u32 =>
                        // Disable RR[5] register
                        Disabled = 0,
        // Enable RR[5] register
                        Enabled = 1

                    );

        impl RR5_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR6_FIELD u32 =>
                        // Disable RR[6] register
                        Disabled = 0,
        // Enable RR[6] register
                        Enabled = 1

                    );

        impl RR6_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR7_FIELD u32 =>
                        // Disable RR[7] register
                        Disabled = 0,
        // Enable RR[7] register
                        Enabled = 1

                    );

        impl RR7_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn sleep(&self) -> SLEEP_FIELD {
                let raw = self.raw;
                SLEEP_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_sleep(&mut self, value: SLEEP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_sleep_with<F: Fn(&mut SLEEP_FIELD) -> &mut SLEEP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sleep();
                f(&mut value);
                self.set_sleep(value)
            }

            pub fn halt(&self) -> HALT_FIELD {
                let raw = self.raw;
                HALT_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_halt(&mut self, value: HALT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_halt_with<F: Fn(&mut HALT_FIELD) -> &mut HALT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.halt();
                f(&mut value);
                self.set_halt(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SLEEP_FIELD u32 =>
                        // Pause watchdog while the CPU is sleeping
                        Pause = 0,
        // Keep the watchdog running while the CPU is sleeping
                        Run = 1

                    );

        impl SLEEP_FIELD {
            pub fn is_pause(&self) -> bool {
                *self == Self::Pause
            }

            pub fn set_pause(&mut self) -> &mut Self {
                *self = Self::Pause;
                self
            }

            pub fn is_run(&self) -> bool {
                *self == Self::Run
            }

            pub fn set_run(&mut self) -> &mut Self {
                *self = Self::Run;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HALT_FIELD u32 =>
                        // Pause watchdog while the CPU is halted by the debugger
                        Pause = 0,
        // Keep the watchdog running while the CPU is halted by the debugger
                        Run = 1

                    );

        impl HALT_FIELD {
            pub fn is_pause(&self) -> bool {
                *self == Self::Pause
            }

            pub fn set_pause(&mut self) -> &mut Self {
                *self = Self::Pause;
                self
            }

            pub fn is_run(&self) -> bool {
                *self == Self::Run
            }

            pub fn set_run(&mut self) -> &mut Self {
                *self = Self::Run;
                self
            }
        }
    }

    pub mod rr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RR {
            raw: RawRegister<u32>,
        }

        impl RR {
            pub fn write_reload(&mut self) {
                self.write(RR_FIELD::Reload)
            }
        }

        impl RegisterWrite for RR {
            type Value = RR_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RR_FIELD u32 =>
            // Value to request a reload of the watchdog timer
            Reload = 1850885685

        );

        impl RR_FIELD {
            pub fn is_reload(&self) -> bool {
                *self == Self::Reload
            }

            pub fn set_reload(&mut self) -> &mut Self {
                *self = Self::Reload;
                self
            }
        }
    }
}

pub mod rtc1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct RTC1 {
        _hidden: (),
    }

    impl RTC1 {
        const BASE_ADDRESS: u32 = 0x40011000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for RTC1 {
        type Target = rtc0::RTC0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for RTC1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod qdec {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct QDEC {
        _hidden: (),
    }

    impl QDEC {
        const BASE_ADDRESS: u32 = 0x40012000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for QDEC {
        type Target = QDEC_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for QDEC {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct QDEC_REGISTERS {
        _hidden: (),
        /// Task starting the quadrature decoder
        pub tasks_start: TaskRegister,
        /// Task stopping the quadrature decoder
        pub tasks_stop: TaskRegister,
        /// Read and clear ACC and ACCDBL
        pub tasks_readclracc: TaskRegister,
        /// Read and clear ACC
        pub tasks_rdclracc: TaskRegister,
        /// Read and clear ACCDBL
        pub tasks_rdclrdbl: TaskRegister,
        _padding_20: [u8; 236],
        /// Event being generated for every new sample value written to the
        /// SAMPLE register
        pub events_samplerdy: EventRegister,
        /// Non-null report ready
        pub events_reportrdy: EventRegister,
        /// ACC or ACCDBL register overflow
        pub events_accof: EventRegister,
        /// Double displacement(s) detected
        pub events_dblrdy: EventRegister,
        /// QDEC has been stopped
        pub events_stopped: EventRegister,
        _padding_276: [u8; 236],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 500],
        /// Enable the quadrature decoder
        pub enable: enable::ENABLE,
        /// LED output pin polarity
        pub ledpol: ledpol::LEDPOL,
        /// Sample period
        pub sampleper: sampleper::SAMPLEPER,
        /// Motion sample value
        pub sample: sample::SAMPLE,
        /// Number of samples to be taken before REPORTRDY and DBLRDY events can
        /// be generated
        pub reportper: reportper::REPORTPER,
        /// Register accumulating the valid transitions
        pub acc: acc::ACC,
        /// Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC
        /// task
        pub accread: accread::ACCREAD,
        pub psel: psel::PSEL,
        /// Enable input debounce filters
        pub dbfen: dbfen::DBFEN,
        _padding_1324: [u8; 20],
        /// Time period the LED is switched ON prior to sampling
        pub ledpre: ledpre::LEDPRE,
        /// Register accumulating the number of detected double transitions
        pub accdbl: accdbl::ACCDBL,
        /// Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
        pub accdblread: accdblread::ACCDBLREAD,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn reportrdy_readclracc(&self) -> REPORTRDY_READCLRACC_FIELD {
                let raw = self.raw;
                REPORTRDY_READCLRACC_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_reportrdy_readclracc(
                &mut self,
                value: REPORTRDY_READCLRACC_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_reportrdy_readclracc_with<
                F: Fn(&mut REPORTRDY_READCLRACC_FIELD) -> &mut REPORTRDY_READCLRACC_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.reportrdy_readclracc();
                f(&mut value);
                self.set_reportrdy_readclracc(value)
            }

            pub fn samplerdy_stop(&self) -> SAMPLERDY_STOP_FIELD {
                let raw = self.raw;
                SAMPLERDY_STOP_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_samplerdy_stop(&mut self, value: SAMPLERDY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_samplerdy_stop_with<
                F: Fn(&mut SAMPLERDY_STOP_FIELD) -> &mut SAMPLERDY_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.samplerdy_stop();
                f(&mut value);
                self.set_samplerdy_stop(value)
            }

            pub fn reportrdy_rdclracc(&self) -> REPORTRDY_RDCLRACC_FIELD {
                let raw = self.raw;
                REPORTRDY_RDCLRACC_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_reportrdy_rdclracc(&mut self, value: REPORTRDY_RDCLRACC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_reportrdy_rdclracc_with<
                F: Fn(&mut REPORTRDY_RDCLRACC_FIELD) -> &mut REPORTRDY_RDCLRACC_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.reportrdy_rdclracc();
                f(&mut value);
                self.set_reportrdy_rdclracc(value)
            }

            pub fn reportrdy_stop(&self) -> REPORTRDY_STOP_FIELD {
                let raw = self.raw;
                REPORTRDY_STOP_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_reportrdy_stop(&mut self, value: REPORTRDY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_reportrdy_stop_with<
                F: Fn(&mut REPORTRDY_STOP_FIELD) -> &mut REPORTRDY_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.reportrdy_stop();
                f(&mut value);
                self.set_reportrdy_stop(value)
            }

            pub fn dblrdy_rdclrdbl(&self) -> DBLRDY_RDCLRDBL_FIELD {
                let raw = self.raw;
                DBLRDY_RDCLRDBL_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_dblrdy_rdclrdbl(&mut self, value: DBLRDY_RDCLRDBL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_dblrdy_rdclrdbl_with<
                F: Fn(&mut DBLRDY_RDCLRDBL_FIELD) -> &mut DBLRDY_RDCLRDBL_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dblrdy_rdclrdbl();
                f(&mut value);
                self.set_dblrdy_rdclrdbl(value)
            }

            pub fn dblrdy_stop(&self) -> DBLRDY_STOP_FIELD {
                let raw = self.raw;
                DBLRDY_STOP_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_dblrdy_stop(&mut self, value: DBLRDY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_dblrdy_stop_with<F: Fn(&mut DBLRDY_STOP_FIELD) -> &mut DBLRDY_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dblrdy_stop();
                f(&mut value);
                self.set_dblrdy_stop(value)
            }

            pub fn samplerdy_readclracc(&self) -> SAMPLERDY_READCLRACC_FIELD {
                let raw = self.raw;
                SAMPLERDY_READCLRACC_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_samplerdy_readclracc(
                &mut self,
                value: SAMPLERDY_READCLRACC_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_samplerdy_readclracc_with<
                F: Fn(&mut SAMPLERDY_READCLRACC_FIELD) -> &mut SAMPLERDY_READCLRACC_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.samplerdy_readclracc();
                f(&mut value);
                self.set_samplerdy_readclracc(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REPORTRDY_READCLRACC_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl REPORTRDY_READCLRACC_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SAMPLERDY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl SAMPLERDY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REPORTRDY_RDCLRACC_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl REPORTRDY_RDCLRACC_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REPORTRDY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl REPORTRDY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DBLRDY_RDCLRDBL_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DBLRDY_RDCLRDBL_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DBLRDY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DBLRDY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SAMPLERDY_READCLRACC_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl SAMPLERDY_READCLRACC_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn samplerdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_samplerdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_samplerdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.samplerdy();
                f(&mut value);
                self.set_samplerdy(value)
            }

            pub fn reportrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_reportrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_reportrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.reportrdy();
                f(&mut value);
                self.set_reportrdy(value)
            }

            pub fn accof(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_accof(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_accof_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.accof();
                f(&mut value);
                self.set_accof(value)
            }

            pub fn dblrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_dblrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_dblrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dblrdy();
                f(&mut value);
                self.set_dblrdy(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_samplerdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_reportrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_accof(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_dblrdy(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn samplerdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_samplerdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_samplerdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.samplerdy();
                f(&mut value);
                self.set_samplerdy(value)
            }

            pub fn reportrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_reportrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_reportrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.reportrdy();
                f(&mut value);
                self.set_reportrdy(value)
            }

            pub fn accof(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_accof(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_accof_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.accof();
                f(&mut value);
                self.set_accof(value)
            }

            pub fn dblrdy(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_dblrdy(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_dblrdy_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.dblrdy();
                f(&mut value);
                self.set_dblrdy(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_samplerdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_reportrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_accof(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_dblrdy(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod ledpol {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LEDPOL {
            raw: RawRegister<u32>,
        }

        impl LEDPOL {
            pub fn write_activelow(&mut self) {
                self.write(LEDPOL_FIELD::ActiveLow)
            }

            pub fn write_activehigh(&mut self) {
                self.write(LEDPOL_FIELD::ActiveHigh)
            }
        }

        impl RegisterRead for LEDPOL {
            type Value = LEDPOL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                LEDPOL_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for LEDPOL {
            type Value = LEDPOL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LEDPOL_FIELD u32 =>
                        // Led active on output pin low
                        ActiveLow = 0,
        // Led active on output pin high
                        ActiveHigh = 1

                    );

        impl LEDPOL_FIELD {
            pub fn is_activelow(&self) -> bool {
                *self == Self::ActiveLow
            }

            pub fn set_activelow(&mut self) -> &mut Self {
                *self = Self::ActiveLow;
                self
            }

            pub fn is_activehigh(&self) -> bool {
                *self == Self::ActiveHigh
            }

            pub fn set_activehigh(&mut self) -> &mut Self {
                *self = Self::ActiveHigh;
                self
            }
        }
    }

    pub mod sampleper {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SAMPLEPER {
            raw: RawRegister<u32>,
        }

        impl SAMPLEPER {
            pub fn write_128us(&mut self) {
                self.write(SAMPLEPER_FIELD::_128us)
            }

            pub fn write_256us(&mut self) {
                self.write(SAMPLEPER_FIELD::_256us)
            }

            pub fn write_512us(&mut self) {
                self.write(SAMPLEPER_FIELD::_512us)
            }

            pub fn write_1024us(&mut self) {
                self.write(SAMPLEPER_FIELD::_1024us)
            }

            pub fn write_2048us(&mut self) {
                self.write(SAMPLEPER_FIELD::_2048us)
            }

            pub fn write_4096us(&mut self) {
                self.write(SAMPLEPER_FIELD::_4096us)
            }

            pub fn write_8192us(&mut self) {
                self.write(SAMPLEPER_FIELD::_8192us)
            }

            pub fn write_16384us(&mut self) {
                self.write(SAMPLEPER_FIELD::_16384us)
            }

            pub fn write_32ms(&mut self) {
                self.write(SAMPLEPER_FIELD::_32ms)
            }

            pub fn write_65ms(&mut self) {
                self.write(SAMPLEPER_FIELD::_65ms)
            }

            pub fn write_131ms(&mut self) {
                self.write(SAMPLEPER_FIELD::_131ms)
            }
        }

        impl RegisterRead for SAMPLEPER {
            type Value = SAMPLEPER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                SAMPLEPER_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for SAMPLEPER {
            type Value = SAMPLEPER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SAMPLEPER_FIELD u32 =>
                        // 128 us
                        _128us = 0,
        // 256 us
                        _256us = 1,
        // 512 us
                        _512us = 2,
        // 1024 us
                        _1024us = 3,
        // 2048 us
                        _2048us = 4,
        // 4096 us
                        _4096us = 5,
        // 8192 us
                        _8192us = 6,
        // 16384 us
                        _16384us = 7,
        // 32768 us
                        _32ms = 8,
        // 65536 us
                        _65ms = 9,
        // 131072 us
                        _131ms = 10

                    );

        impl SAMPLEPER_FIELD {
            pub fn is_128us(&self) -> bool {
                *self == Self::_128us
            }

            pub fn set_128us(&mut self) -> &mut Self {
                *self = Self::_128us;
                self
            }

            pub fn is_256us(&self) -> bool {
                *self == Self::_256us
            }

            pub fn set_256us(&mut self) -> &mut Self {
                *self = Self::_256us;
                self
            }

            pub fn is_512us(&self) -> bool {
                *self == Self::_512us
            }

            pub fn set_512us(&mut self) -> &mut Self {
                *self = Self::_512us;
                self
            }

            pub fn is_1024us(&self) -> bool {
                *self == Self::_1024us
            }

            pub fn set_1024us(&mut self) -> &mut Self {
                *self = Self::_1024us;
                self
            }

            pub fn is_2048us(&self) -> bool {
                *self == Self::_2048us
            }

            pub fn set_2048us(&mut self) -> &mut Self {
                *self = Self::_2048us;
                self
            }

            pub fn is_4096us(&self) -> bool {
                *self == Self::_4096us
            }

            pub fn set_4096us(&mut self) -> &mut Self {
                *self = Self::_4096us;
                self
            }

            pub fn is_8192us(&self) -> bool {
                *self == Self::_8192us
            }

            pub fn set_8192us(&mut self) -> &mut Self {
                *self = Self::_8192us;
                self
            }

            pub fn is_16384us(&self) -> bool {
                *self == Self::_16384us
            }

            pub fn set_16384us(&mut self) -> &mut Self {
                *self = Self::_16384us;
                self
            }

            pub fn is_32ms(&self) -> bool {
                *self == Self::_32ms
            }

            pub fn set_32ms(&mut self) -> &mut Self {
                *self = Self::_32ms;
                self
            }

            pub fn is_65ms(&self) -> bool {
                *self == Self::_65ms
            }

            pub fn set_65ms(&mut self) -> &mut Self {
                *self = Self::_65ms;
                self
            }

            pub fn is_131ms(&self) -> bool {
                *self == Self::_131ms
            }

            pub fn set_131ms(&mut self) -> &mut Self {
                *self = Self::_131ms;
                self
            }
        }
    }

    pub mod sample {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SAMPLE {
            raw: RawRegister<u32>,
        }

        impl SAMPLE {}

        impl RegisterRead for SAMPLE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod reportper {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REPORTPER {
            raw: RawRegister<u32>,
        }

        impl REPORTPER {
            pub fn write_10smpl(&mut self) {
                self.write(REPORTPER_FIELD::_10Smpl)
            }

            pub fn write_40smpl(&mut self) {
                self.write(REPORTPER_FIELD::_40Smpl)
            }

            pub fn write_80smpl(&mut self) {
                self.write(REPORTPER_FIELD::_80Smpl)
            }

            pub fn write_120smpl(&mut self) {
                self.write(REPORTPER_FIELD::_120Smpl)
            }

            pub fn write_160smpl(&mut self) {
                self.write(REPORTPER_FIELD::_160Smpl)
            }

            pub fn write_200smpl(&mut self) {
                self.write(REPORTPER_FIELD::_200Smpl)
            }

            pub fn write_240smpl(&mut self) {
                self.write(REPORTPER_FIELD::_240Smpl)
            }

            pub fn write_280smpl(&mut self) {
                self.write(REPORTPER_FIELD::_280Smpl)
            }

            pub fn write_1smpl(&mut self) {
                self.write(REPORTPER_FIELD::_1Smpl)
            }
        }

        impl RegisterRead for REPORTPER {
            type Value = REPORTPER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                REPORTPER_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for REPORTPER {
            type Value = REPORTPER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REPORTPER_FIELD u32 =>
                        // 10 samples/report
                        _10Smpl = 0,
        // 40 samples/report
                        _40Smpl = 1,
        // 80 samples/report
                        _80Smpl = 2,
        // 120 samples/report
                        _120Smpl = 3,
        // 160 samples/report
                        _160Smpl = 4,
        // 200 samples/report
                        _200Smpl = 5,
        // 240 samples/report
                        _240Smpl = 6,
        // 280 samples/report
                        _280Smpl = 7,
        // 1 sample/report
                        _1Smpl = 8

                    );

        impl REPORTPER_FIELD {
            pub fn is_10smpl(&self) -> bool {
                *self == Self::_10Smpl
            }

            pub fn set_10smpl(&mut self) -> &mut Self {
                *self = Self::_10Smpl;
                self
            }

            pub fn is_40smpl(&self) -> bool {
                *self == Self::_40Smpl
            }

            pub fn set_40smpl(&mut self) -> &mut Self {
                *self = Self::_40Smpl;
                self
            }

            pub fn is_80smpl(&self) -> bool {
                *self == Self::_80Smpl
            }

            pub fn set_80smpl(&mut self) -> &mut Self {
                *self = Self::_80Smpl;
                self
            }

            pub fn is_120smpl(&self) -> bool {
                *self == Self::_120Smpl
            }

            pub fn set_120smpl(&mut self) -> &mut Self {
                *self = Self::_120Smpl;
                self
            }

            pub fn is_160smpl(&self) -> bool {
                *self == Self::_160Smpl
            }

            pub fn set_160smpl(&mut self) -> &mut Self {
                *self = Self::_160Smpl;
                self
            }

            pub fn is_200smpl(&self) -> bool {
                *self == Self::_200Smpl
            }

            pub fn set_200smpl(&mut self) -> &mut Self {
                *self = Self::_200Smpl;
                self
            }

            pub fn is_240smpl(&self) -> bool {
                *self == Self::_240Smpl
            }

            pub fn set_240smpl(&mut self) -> &mut Self {
                *self = Self::_240Smpl;
                self
            }

            pub fn is_280smpl(&self) -> bool {
                *self == Self::_280Smpl
            }

            pub fn set_280smpl(&mut self) -> &mut Self {
                *self = Self::_280Smpl;
                self
            }

            pub fn is_1smpl(&self) -> bool {
                *self == Self::_1Smpl
            }

            pub fn set_1smpl(&mut self) -> &mut Self {
                *self = Self::_1Smpl;
                self
            }
        }
    }

    pub mod acc {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ACC {
            raw: RawRegister<u32>,
        }

        impl ACC {}

        impl RegisterRead for ACC {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod accread {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ACCREAD {
            raw: RawRegister<u32>,
        }

        impl ACCREAD {}

        impl RegisterRead for ACCREAD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0xffffffff) >> 0
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for LED signal
            pub led: PinSelectRegister,
            /// Pin select for A signal
            pub a: PinSelectRegister,
            /// Pin select for B signal
            pub b: PinSelectRegister,
        }
    }

    pub mod dbfen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DBFEN {
            raw: RawRegister<u32>,
        }

        impl DBFEN {
            pub fn write_disabled(&mut self) {
                self.write(DBFEN_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(DBFEN_FIELD::Enabled)
            }
        }

        impl RegisterRead for DBFEN {
            type Value = DBFEN_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                DBFEN_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for DBFEN {
            type Value = DBFEN_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DBFEN_FIELD u32 =>
                        // Debounce input filters disabled
                        Disabled = 0,
        // Debounce input filters enabled
                        Enabled = 1

                    );

        impl DBFEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod ledpre {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LEDPRE {
            raw: RawRegister<u32>,
        }

        impl LEDPRE {}

        impl RegisterRead for LEDPRE {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000001ff) >> 0
            }
        }

        impl RegisterWrite for LEDPRE {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x000001ff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod accdbl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ACCDBL {
            raw: RawRegister<u32>,
        }

        impl ACCDBL {}

        impl RegisterRead for ACCDBL {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000000f) >> 0
            }
        }
    }

    pub mod accdblread {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ACCDBLREAD {
            raw: RawRegister<u32>,
        }

        impl ACCDBLREAD {}

        impl RegisterRead for ACCDBLREAD {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x0000000f) >> 0
            }
        }
    }
}

pub mod comp {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct COMP {
        _hidden: (),
    }

    impl COMP {
        const BASE_ADDRESS: u32 = 0x40013000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for COMP {
        type Target = COMP_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for COMP {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct COMP_REGISTERS {
        _hidden: (),
        /// Start comparator
        pub tasks_start: TaskRegister,
        /// Stop comparator
        pub tasks_stop: TaskRegister,
        /// Sample comparator value
        pub tasks_sample: TaskRegister,
        _padding_12: [u8; 244],
        /// COMP is ready and output is valid
        pub events_ready: EventRegister,
        /// Downward crossing
        pub events_down: EventRegister,
        /// Upward crossing
        pub events_up: EventRegister,
        /// Downward or upward crossing
        pub events_cross: EventRegister,
        _padding_272: [u8; 240],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Compare result
        pub result: result::RESULT,
        _padding_1028: [u8; 252],
        /// COMP enable
        pub enable: enable::ENABLE,
        /// Pin select
        pub psel: psel::PSEL,
        /// Reference source select for single-ended mode
        pub refsel: refsel::REFSEL,
        /// External reference select
        pub extrefsel: extrefsel::EXTREFSEL,
        _padding_1296: [u8; 32],
        /// Threshold configuration for hysteresis unit
        pub th: th::TH,
        /// Mode configuration
        pub mode: mode::MODE,
        /// Comparator hysteresis enable
        pub hyst: hyst::HYST,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready_sample(&self) -> READY_SAMPLE_FIELD {
                let raw = self.raw;
                READY_SAMPLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready_sample(&mut self, value: READY_SAMPLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_sample_with<
                F: Fn(&mut READY_SAMPLE_FIELD) -> &mut READY_SAMPLE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_sample();
                f(&mut value);
                self.set_ready_sample(value)
            }

            pub fn ready_stop(&self) -> READY_STOP_FIELD {
                let raw = self.raw;
                READY_STOP_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ready_stop(&mut self, value: READY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ready_stop_with<F: Fn(&mut READY_STOP_FIELD) -> &mut READY_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_stop();
                f(&mut value);
                self.set_ready_stop(value)
            }

            pub fn down_stop(&self) -> DOWN_STOP_FIELD {
                let raw = self.raw;
                DOWN_STOP_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_down_stop(&mut self, value: DOWN_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_down_stop_with<F: Fn(&mut DOWN_STOP_FIELD) -> &mut DOWN_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down_stop();
                f(&mut value);
                self.set_down_stop(value)
            }

            pub fn up_stop(&self) -> UP_STOP_FIELD {
                let raw = self.raw;
                UP_STOP_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_up_stop(&mut self, value: UP_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_up_stop_with<F: Fn(&mut UP_STOP_FIELD) -> &mut UP_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up_stop();
                f(&mut value);
                self.set_up_stop(value)
            }

            pub fn cross_stop(&self) -> CROSS_STOP_FIELD {
                let raw = self.raw;
                CROSS_STOP_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_cross_stop(&mut self, value: CROSS_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_cross_stop_with<F: Fn(&mut CROSS_STOP_FIELD) -> &mut CROSS_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross_stop();
                f(&mut value);
                self.set_cross_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_SAMPLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_SAMPLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DOWN_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DOWN_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] UP_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl UP_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CROSS_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CROSS_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn down(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_down(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_down_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down();
                f(&mut value);
                self.set_down(value)
            }

            pub fn up(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_up(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_up_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up();
                f(&mut value);
                self.set_up(value)
            }

            pub fn cross(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cross(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cross_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross();
                f(&mut value);
                self.set_cross(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn down(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_down(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_down_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down();
                f(&mut value);
                self.set_down(value)
            }

            pub fn up(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_up(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_up_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up();
                f(&mut value);
                self.set_up(value)
            }

            pub fn cross(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cross(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cross_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross();
                f(&mut value);
                self.set_cross(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_down(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_up(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cross(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn down(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_down(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_down_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down();
                f(&mut value);
                self.set_down(value)
            }

            pub fn up(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_up(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_up_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up();
                f(&mut value);
                self.set_up(value)
            }

            pub fn cross(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cross(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cross_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross();
                f(&mut value);
                self.set_cross(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_down(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_up(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cross(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }
    }

    pub mod result {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RESULT {
            raw: RawRegister<u32>,
        }

        impl RESULT {}

        impl RegisterRead for RESULT {
            type Value = RESULT_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                RESULT_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RESULT_FIELD u32 =>
                        // Input voltage is below the threshold (VIN+ &lt; VIN-)
                        Below = 0,
        // Input voltage is above the threshold (VIN+ &gt; VIN-)
                        Above = 1

                    );

        impl RESULT_FIELD {
            pub fn is_below(&self) -> bool {
                *self == Self::Below
            }

            pub fn set_below(&mut self) -> &mut Self {
                *self = Self::Below;
                self
            }

            pub fn is_above(&self) -> bool {
                *self == Self::Above
            }

            pub fn set_above(&mut self) -> &mut Self {
                *self = Self::Above;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 2

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PSEL {
            raw: RawRegister<u32>,
        }

        impl PSEL {
            pub fn write_analoginput0(&mut self) {
                self.write(PSEL_FIELD::AnalogInput0)
            }

            pub fn write_analoginput1(&mut self) {
                self.write(PSEL_FIELD::AnalogInput1)
            }

            pub fn write_analoginput2(&mut self) {
                self.write(PSEL_FIELD::AnalogInput2)
            }

            pub fn write_analoginput3(&mut self) {
                self.write(PSEL_FIELD::AnalogInput3)
            }

            pub fn write_analoginput4(&mut self) {
                self.write(PSEL_FIELD::AnalogInput4)
            }

            pub fn write_analoginput5(&mut self) {
                self.write(PSEL_FIELD::AnalogInput5)
            }

            pub fn write_analoginput6(&mut self) {
                self.write(PSEL_FIELD::AnalogInput6)
            }

            pub fn write_analoginput7(&mut self) {
                self.write(PSEL_FIELD::AnalogInput7)
            }
        }

        impl RegisterRead for PSEL {
            type Value = PSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                PSEL_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        impl RegisterWrite for PSEL {
            type Value = PSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PSEL_FIELD u32 =>
                        // AIN0 selected as analog input
                        AnalogInput0 = 0,
        // AIN1 selected as analog input
                        AnalogInput1 = 1,
        // AIN2 selected as analog input
                        AnalogInput2 = 2,
        // AIN3 selected as analog input
                        AnalogInput3 = 3,
        // AIN4 selected as analog input
                        AnalogInput4 = 4,
        // AIN5 selected as analog input
                        AnalogInput5 = 5,
        // AIN6 selected as analog input
                        AnalogInput6 = 6,
        // AIN7 selected as analog input
                        AnalogInput7 = 7

                    );

        impl PSEL_FIELD {
            pub fn is_analoginput0(&self) -> bool {
                *self == Self::AnalogInput0
            }

            pub fn set_analoginput0(&mut self) -> &mut Self {
                *self = Self::AnalogInput0;
                self
            }

            pub fn is_analoginput1(&self) -> bool {
                *self == Self::AnalogInput1
            }

            pub fn set_analoginput1(&mut self) -> &mut Self {
                *self = Self::AnalogInput1;
                self
            }

            pub fn is_analoginput2(&self) -> bool {
                *self == Self::AnalogInput2
            }

            pub fn set_analoginput2(&mut self) -> &mut Self {
                *self = Self::AnalogInput2;
                self
            }

            pub fn is_analoginput3(&self) -> bool {
                *self == Self::AnalogInput3
            }

            pub fn set_analoginput3(&mut self) -> &mut Self {
                *self = Self::AnalogInput3;
                self
            }

            pub fn is_analoginput4(&self) -> bool {
                *self == Self::AnalogInput4
            }

            pub fn set_analoginput4(&mut self) -> &mut Self {
                *self = Self::AnalogInput4;
                self
            }

            pub fn is_analoginput5(&self) -> bool {
                *self == Self::AnalogInput5
            }

            pub fn set_analoginput5(&mut self) -> &mut Self {
                *self = Self::AnalogInput5;
                self
            }

            pub fn is_analoginput6(&self) -> bool {
                *self == Self::AnalogInput6
            }

            pub fn set_analoginput6(&mut self) -> &mut Self {
                *self = Self::AnalogInput6;
                self
            }

            pub fn is_analoginput7(&self) -> bool {
                *self == Self::AnalogInput7
            }

            pub fn set_analoginput7(&mut self) -> &mut Self {
                *self = Self::AnalogInput7;
                self
            }
        }
    }

    pub mod refsel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REFSEL {
            raw: RawRegister<u32>,
        }

        impl REFSEL {
            pub fn write_int1v2(&mut self) {
                self.write(REFSEL_FIELD::Int1V2)
            }

            pub fn write_int1v8(&mut self) {
                self.write(REFSEL_FIELD::Int1V8)
            }

            pub fn write_int2v4(&mut self) {
                self.write(REFSEL_FIELD::Int2V4)
            }

            pub fn write_vdd(&mut self) {
                self.write(REFSEL_FIELD::VDD)
            }

            pub fn write_aref(&mut self) {
                self.write(REFSEL_FIELD::ARef)
            }
        }

        impl RegisterRead for REFSEL {
            type Value = REFSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                REFSEL_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        impl RegisterWrite for REFSEL {
            type Value = REFSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REFSEL_FIELD u32 =>
                        // VREF = internal 1.2 V reference (VDD &gt;= 1.7 V)
                        Int1V2 = 0,
        // VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V)
                        Int1V8 = 1,
        // VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V)
                        Int2V4 = 2,
        // VREF = VDD
                        VDD = 4,
        // VREF = AREF
                        ARef = 5

                    );

        impl REFSEL_FIELD {
            pub fn is_int1v2(&self) -> bool {
                *self == Self::Int1V2
            }

            pub fn set_int1v2(&mut self) -> &mut Self {
                *self = Self::Int1V2;
                self
            }

            pub fn is_int1v8(&self) -> bool {
                *self == Self::Int1V8
            }

            pub fn set_int1v8(&mut self) -> &mut Self {
                *self = Self::Int1V8;
                self
            }

            pub fn is_int2v4(&self) -> bool {
                *self == Self::Int2V4
            }

            pub fn set_int2v4(&mut self) -> &mut Self {
                *self = Self::Int2V4;
                self
            }

            pub fn is_vdd(&self) -> bool {
                *self == Self::VDD
            }

            pub fn set_vdd(&mut self) -> &mut Self {
                *self = Self::VDD;
                self
            }

            pub fn is_aref(&self) -> bool {
                *self == Self::ARef
            }

            pub fn set_aref(&mut self) -> &mut Self {
                *self = Self::ARef;
                self
            }
        }
    }

    pub mod extrefsel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EXTREFSEL {
            raw: RawRegister<u32>,
        }

        impl EXTREFSEL {
            pub fn write_analogreference0(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference0)
            }

            pub fn write_analogreference1(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference1)
            }

            pub fn write_analogreference2(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference2)
            }

            pub fn write_analogreference3(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference3)
            }

            pub fn write_analogreference4(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference4)
            }

            pub fn write_analogreference5(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference5)
            }

            pub fn write_analogreference6(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference6)
            }

            pub fn write_analogreference7(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference7)
            }
        }

        impl RegisterRead for EXTREFSEL {
            type Value = EXTREFSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                EXTREFSEL_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        impl RegisterWrite for EXTREFSEL {
            type Value = EXTREFSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EXTREFSEL_FIELD u32 =>
                        // Use AIN0 as external analog reference
                        AnalogReference0 = 0,
        // Use AIN1 as external analog reference
                        AnalogReference1 = 1,
        // Use AIN2 as external analog reference
                        AnalogReference2 = 2,
        // Use AIN3 as external analog reference
                        AnalogReference3 = 3,
        // Use AIN4 as external analog reference
                        AnalogReference4 = 4,
        // Use AIN5 as external analog reference
                        AnalogReference5 = 5,
        // Use AIN6 as external analog reference
                        AnalogReference6 = 6,
        // Use AIN7 as external analog reference
                        AnalogReference7 = 7

                    );

        impl EXTREFSEL_FIELD {
            pub fn is_analogreference0(&self) -> bool {
                *self == Self::AnalogReference0
            }

            pub fn set_analogreference0(&mut self) -> &mut Self {
                *self = Self::AnalogReference0;
                self
            }

            pub fn is_analogreference1(&self) -> bool {
                *self == Self::AnalogReference1
            }

            pub fn set_analogreference1(&mut self) -> &mut Self {
                *self = Self::AnalogReference1;
                self
            }

            pub fn is_analogreference2(&self) -> bool {
                *self == Self::AnalogReference2
            }

            pub fn set_analogreference2(&mut self) -> &mut Self {
                *self = Self::AnalogReference2;
                self
            }

            pub fn is_analogreference3(&self) -> bool {
                *self == Self::AnalogReference3
            }

            pub fn set_analogreference3(&mut self) -> &mut Self {
                *self = Self::AnalogReference3;
                self
            }

            pub fn is_analogreference4(&self) -> bool {
                *self == Self::AnalogReference4
            }

            pub fn set_analogreference4(&mut self) -> &mut Self {
                *self = Self::AnalogReference4;
                self
            }

            pub fn is_analogreference5(&self) -> bool {
                *self == Self::AnalogReference5
            }

            pub fn set_analogreference5(&mut self) -> &mut Self {
                *self = Self::AnalogReference5;
                self
            }

            pub fn is_analogreference6(&self) -> bool {
                *self == Self::AnalogReference6
            }

            pub fn set_analogreference6(&mut self) -> &mut Self {
                *self = Self::AnalogReference6;
                self
            }

            pub fn is_analogreference7(&self) -> bool {
                *self == Self::AnalogReference7
            }

            pub fn set_analogreference7(&mut self) -> &mut Self {
                *self = Self::AnalogReference7;
                self
            }
        }
    }

    pub mod th {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct TH {
            raw: RawRegister<u32>,
        }

        impl TH {
            pub fn write_with<F: Fn(&mut TH_VALUE) -> &mut TH_VALUE>(&mut self, f: F) {
                let mut v = TH_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for TH {
            type Value = TH_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                TH_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for TH {
            type Value = TH_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct TH_VALUE {
            raw: u32,
        }

        impl TH_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn thdown(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000003f) >> 0
            }

            pub fn set_thdown(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000003f) | (value << 0);
                self
            }

            pub fn thup(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00003f00) >> 8
            }

            pub fn set_thup(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00003f00) | (value << 8);
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_with<F: Fn(&mut MODE_VALUE) -> &mut MODE_VALUE>(&mut self, f: F) {
                let mut v = MODE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODE_VALUE {
            raw: u32,
        }

        impl MODE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn sp(&self) -> SP_FIELD {
                let raw = self.raw;
                SP_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_sp(&mut self, value: SP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_sp_with<F: Fn(&mut SP_FIELD) -> &mut SP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sp();
                f(&mut value);
                self.set_sp(value)
            }

            pub fn main(&self) -> MAIN_FIELD {
                let raw = self.raw;
                MAIN_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_main(&mut self, value: MAIN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_main_with<F: Fn(&mut MAIN_FIELD) -> &mut MAIN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.main();
                f(&mut value);
                self.set_main(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SP_FIELD u32 =>
                        // Low-power mode
                        Low = 0,
        // Normal mode
                        Normal = 1,
        // High-speed mode
                        High = 2

                    );

        impl SP_FIELD {
            pub fn is_low(&self) -> bool {
                *self == Self::Low
            }

            pub fn set_low(&mut self) -> &mut Self {
                *self = Self::Low;
                self
            }

            pub fn is_normal(&self) -> bool {
                *self == Self::Normal
            }

            pub fn set_normal(&mut self) -> &mut Self {
                *self = Self::Normal;
                self
            }

            pub fn is_high(&self) -> bool {
                *self == Self::High
            }

            pub fn set_high(&mut self) -> &mut Self {
                *self = Self::High;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MAIN_FIELD u32 =>
                        // Single-ended mode
                        SE = 0,
        // Differential mode
                        Diff = 1

                    );

        impl MAIN_FIELD {
            pub fn is_se(&self) -> bool {
                *self == Self::SE
            }

            pub fn set_se(&mut self) -> &mut Self {
                *self = Self::SE;
                self
            }

            pub fn is_diff(&self) -> bool {
                *self == Self::Diff
            }

            pub fn set_diff(&mut self) -> &mut Self {
                *self = Self::Diff;
                self
            }
        }
    }

    pub mod hyst {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HYST {
            raw: RawRegister<u32>,
        }

        impl HYST {
            pub fn write_nohyst(&mut self) {
                self.write(HYST_FIELD::NoHyst)
            }

            pub fn write_hyst50mv(&mut self) {
                self.write(HYST_FIELD::Hyst50mV)
            }
        }

        impl RegisterRead for HYST {
            type Value = HYST_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                HYST_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for HYST {
            type Value = HYST_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HYST_FIELD u32 =>
                        // Comparator hysteresis disabled
                        NoHyst = 0,
        // Comparator hysteresis enabled
                        Hyst50mV = 1

                    );

        impl HYST_FIELD {
            pub fn is_nohyst(&self) -> bool {
                *self == Self::NoHyst
            }

            pub fn set_nohyst(&mut self) -> &mut Self {
                *self = Self::NoHyst;
                self
            }

            pub fn is_hyst50mv(&self) -> bool {
                *self == Self::Hyst50mV
            }

            pub fn set_hyst50mv(&mut self) -> &mut Self {
                *self = Self::Hyst50mV;
                self
            }
        }
    }
}

pub mod lpcomp {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct LPCOMP {
        _hidden: (),
    }

    impl LPCOMP {
        const BASE_ADDRESS: u32 = 0x40013000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for LPCOMP {
        type Target = LPCOMP_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for LPCOMP {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct LPCOMP_REGISTERS {
        _hidden: (),
        /// Start comparator
        pub tasks_start: TaskRegister,
        /// Stop comparator
        pub tasks_stop: TaskRegister,
        /// Sample comparator value
        pub tasks_sample: TaskRegister,
        _padding_12: [u8; 244],
        /// LPCOMP is ready and output is valid
        pub events_ready: EventRegister,
        /// Downward crossing
        pub events_down: EventRegister,
        /// Upward crossing
        pub events_up: EventRegister,
        /// Downward or upward crossing
        pub events_cross: EventRegister,
        _padding_272: [u8; 240],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 256],
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Compare result
        pub result: result::RESULT,
        _padding_1028: [u8; 252],
        /// Enable LPCOMP
        pub enable: enable::ENABLE,
        /// Input pin select
        pub psel: psel::PSEL,
        /// Reference select
        pub refsel: refsel::REFSEL,
        /// External reference select
        pub extrefsel: extrefsel::EXTREFSEL,
        _padding_1296: [u8; 16],
        /// Analog detect configuration
        pub anadetect: anadetect::ANADETECT,
        _padding_1316: [u8; 20],
        /// Comparator hysteresis enable
        pub hyst: hyst::HYST,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready_sample(&self) -> READY_SAMPLE_FIELD {
                let raw = self.raw;
                READY_SAMPLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready_sample(&mut self, value: READY_SAMPLE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_sample_with<
                F: Fn(&mut READY_SAMPLE_FIELD) -> &mut READY_SAMPLE_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_sample();
                f(&mut value);
                self.set_ready_sample(value)
            }

            pub fn ready_stop(&self) -> READY_STOP_FIELD {
                let raw = self.raw;
                READY_STOP_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ready_stop(&mut self, value: READY_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ready_stop_with<F: Fn(&mut READY_STOP_FIELD) -> &mut READY_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready_stop();
                f(&mut value);
                self.set_ready_stop(value)
            }

            pub fn down_stop(&self) -> DOWN_STOP_FIELD {
                let raw = self.raw;
                DOWN_STOP_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_down_stop(&mut self, value: DOWN_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_down_stop_with<F: Fn(&mut DOWN_STOP_FIELD) -> &mut DOWN_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down_stop();
                f(&mut value);
                self.set_down_stop(value)
            }

            pub fn up_stop(&self) -> UP_STOP_FIELD {
                let raw = self.raw;
                UP_STOP_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_up_stop(&mut self, value: UP_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_up_stop_with<F: Fn(&mut UP_STOP_FIELD) -> &mut UP_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up_stop();
                f(&mut value);
                self.set_up_stop(value)
            }

            pub fn cross_stop(&self) -> CROSS_STOP_FIELD {
                let raw = self.raw;
                CROSS_STOP_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_cross_stop(&mut self, value: CROSS_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_cross_stop_with<F: Fn(&mut CROSS_STOP_FIELD) -> &mut CROSS_STOP_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross_stop();
                f(&mut value);
                self.set_cross_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_SAMPLE_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_SAMPLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl READY_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DOWN_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl DOWN_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] UP_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl UP_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CROSS_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl CROSS_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn down(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_down(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_down_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down();
                f(&mut value);
                self.set_down(value)
            }

            pub fn up(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_up(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_up_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up();
                f(&mut value);
                self.set_up(value)
            }

            pub fn cross(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cross(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cross_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross();
                f(&mut value);
                self.set_cross(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_down(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_up(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cross(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ready(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ready(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ready_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }

            pub fn down(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_down(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_down_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.down();
                f(&mut value);
                self.set_down(value)
            }

            pub fn up(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_up(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_up_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.up();
                f(&mut value);
                self.set_up(value)
            }

            pub fn cross(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_cross(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_cross_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cross();
                f(&mut value);
                self.set_cross(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ready(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_down(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_up(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_cross(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }
        }
    }

    pub mod result {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RESULT {
            raw: RawRegister<u32>,
        }

        impl RESULT {}

        impl RegisterRead for RESULT {
            type Value = RESULT_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                RESULT_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RESULT_FIELD u32 =>
                        // Input voltage is below the reference threshold (VIN+ &lt; VIN-)
                        Below = 0,
        // Input voltage is above the reference threshold (VIN+ &gt; VIN-)
                        Above = 1

                    );

        impl RESULT_FIELD {
            pub fn is_below(&self) -> bool {
                *self == Self::Below
            }

            pub fn set_below(&mut self) -> &mut Self {
                *self = Self::Below;
                self
            }

            pub fn is_above(&self) -> bool {
                *self == Self::Above
            }

            pub fn set_above(&mut self) -> &mut Self {
                *self = Self::Above;
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PSEL {
            raw: RawRegister<u32>,
        }

        impl PSEL {
            pub fn write_analoginput0(&mut self) {
                self.write(PSEL_FIELD::AnalogInput0)
            }

            pub fn write_analoginput1(&mut self) {
                self.write(PSEL_FIELD::AnalogInput1)
            }

            pub fn write_analoginput2(&mut self) {
                self.write(PSEL_FIELD::AnalogInput2)
            }

            pub fn write_analoginput3(&mut self) {
                self.write(PSEL_FIELD::AnalogInput3)
            }

            pub fn write_analoginput4(&mut self) {
                self.write(PSEL_FIELD::AnalogInput4)
            }

            pub fn write_analoginput5(&mut self) {
                self.write(PSEL_FIELD::AnalogInput5)
            }

            pub fn write_analoginput6(&mut self) {
                self.write(PSEL_FIELD::AnalogInput6)
            }

            pub fn write_analoginput7(&mut self) {
                self.write(PSEL_FIELD::AnalogInput7)
            }
        }

        impl RegisterRead for PSEL {
            type Value = PSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                PSEL_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        impl RegisterWrite for PSEL {
            type Value = PSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PSEL_FIELD u32 =>
                        // AIN0 selected as analog input
                        AnalogInput0 = 0,
        // AIN1 selected as analog input
                        AnalogInput1 = 1,
        // AIN2 selected as analog input
                        AnalogInput2 = 2,
        // AIN3 selected as analog input
                        AnalogInput3 = 3,
        // AIN4 selected as analog input
                        AnalogInput4 = 4,
        // AIN5 selected as analog input
                        AnalogInput5 = 5,
        // AIN6 selected as analog input
                        AnalogInput6 = 6,
        // AIN7 selected as analog input
                        AnalogInput7 = 7

                    );

        impl PSEL_FIELD {
            pub fn is_analoginput0(&self) -> bool {
                *self == Self::AnalogInput0
            }

            pub fn set_analoginput0(&mut self) -> &mut Self {
                *self = Self::AnalogInput0;
                self
            }

            pub fn is_analoginput1(&self) -> bool {
                *self == Self::AnalogInput1
            }

            pub fn set_analoginput1(&mut self) -> &mut Self {
                *self = Self::AnalogInput1;
                self
            }

            pub fn is_analoginput2(&self) -> bool {
                *self == Self::AnalogInput2
            }

            pub fn set_analoginput2(&mut self) -> &mut Self {
                *self = Self::AnalogInput2;
                self
            }

            pub fn is_analoginput3(&self) -> bool {
                *self == Self::AnalogInput3
            }

            pub fn set_analoginput3(&mut self) -> &mut Self {
                *self = Self::AnalogInput3;
                self
            }

            pub fn is_analoginput4(&self) -> bool {
                *self == Self::AnalogInput4
            }

            pub fn set_analoginput4(&mut self) -> &mut Self {
                *self = Self::AnalogInput4;
                self
            }

            pub fn is_analoginput5(&self) -> bool {
                *self == Self::AnalogInput5
            }

            pub fn set_analoginput5(&mut self) -> &mut Self {
                *self = Self::AnalogInput5;
                self
            }

            pub fn is_analoginput6(&self) -> bool {
                *self == Self::AnalogInput6
            }

            pub fn set_analoginput6(&mut self) -> &mut Self {
                *self = Self::AnalogInput6;
                self
            }

            pub fn is_analoginput7(&self) -> bool {
                *self == Self::AnalogInput7
            }

            pub fn set_analoginput7(&mut self) -> &mut Self {
                *self = Self::AnalogInput7;
                self
            }
        }
    }

    pub mod refsel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REFSEL {
            raw: RawRegister<u32>,
        }

        impl REFSEL {
            pub fn write_ref1_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref1_8Vdd)
            }

            pub fn write_ref2_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref2_8Vdd)
            }

            pub fn write_ref3_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref3_8Vdd)
            }

            pub fn write_ref4_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref4_8Vdd)
            }

            pub fn write_ref5_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref5_8Vdd)
            }

            pub fn write_ref6_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref6_8Vdd)
            }

            pub fn write_ref7_8vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref7_8Vdd)
            }

            pub fn write_aref(&mut self) {
                self.write(REFSEL_FIELD::ARef)
            }

            pub fn write_ref1_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref1_16Vdd)
            }

            pub fn write_ref3_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref3_16Vdd)
            }

            pub fn write_ref5_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref5_16Vdd)
            }

            pub fn write_ref7_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref7_16Vdd)
            }

            pub fn write_ref9_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref9_16Vdd)
            }

            pub fn write_ref11_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref11_16Vdd)
            }

            pub fn write_ref13_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref13_16Vdd)
            }

            pub fn write_ref15_16vdd(&mut self) {
                self.write(REFSEL_FIELD::Ref15_16Vdd)
            }
        }

        impl RegisterRead for REFSEL {
            type Value = REFSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                REFSEL_FIELD::from_value((raw & 0x0000000f) >> 0)
            }
        }

        impl RegisterWrite for REFSEL {
            type Value = REFSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REFSEL_FIELD u32 =>
                        // VDD * 1/8 selected as reference
                        Ref1_8Vdd = 0,
        // VDD * 2/8 selected as reference
                        Ref2_8Vdd = 1,
        // VDD * 3/8 selected as reference
                        Ref3_8Vdd = 2,
        // VDD * 4/8 selected as reference
                        Ref4_8Vdd = 3,
        // VDD * 5/8 selected as reference
                        Ref5_8Vdd = 4,
        // VDD * 6/8 selected as reference
                        Ref6_8Vdd = 5,
        // VDD * 7/8 selected as reference
                        Ref7_8Vdd = 6,
        // External analog reference selected
                        ARef = 7,
        // VDD * 1/16 selected as reference
                        Ref1_16Vdd = 8,
        // VDD * 3/16 selected as reference
                        Ref3_16Vdd = 9,
        // VDD * 5/16 selected as reference
                        Ref5_16Vdd = 10,
        // VDD * 7/16 selected as reference
                        Ref7_16Vdd = 11,
        // VDD * 9/16 selected as reference
                        Ref9_16Vdd = 12,
        // VDD * 11/16 selected as reference
                        Ref11_16Vdd = 13,
        // VDD * 13/16 selected as reference
                        Ref13_16Vdd = 14,
        // VDD * 15/16 selected as reference
                        Ref15_16Vdd = 15

                    );

        impl REFSEL_FIELD {
            pub fn is_ref1_8vdd(&self) -> bool {
                *self == Self::Ref1_8Vdd
            }

            pub fn set_ref1_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref1_8Vdd;
                self
            }

            pub fn is_ref2_8vdd(&self) -> bool {
                *self == Self::Ref2_8Vdd
            }

            pub fn set_ref2_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref2_8Vdd;
                self
            }

            pub fn is_ref3_8vdd(&self) -> bool {
                *self == Self::Ref3_8Vdd
            }

            pub fn set_ref3_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref3_8Vdd;
                self
            }

            pub fn is_ref4_8vdd(&self) -> bool {
                *self == Self::Ref4_8Vdd
            }

            pub fn set_ref4_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref4_8Vdd;
                self
            }

            pub fn is_ref5_8vdd(&self) -> bool {
                *self == Self::Ref5_8Vdd
            }

            pub fn set_ref5_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref5_8Vdd;
                self
            }

            pub fn is_ref6_8vdd(&self) -> bool {
                *self == Self::Ref6_8Vdd
            }

            pub fn set_ref6_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref6_8Vdd;
                self
            }

            pub fn is_ref7_8vdd(&self) -> bool {
                *self == Self::Ref7_8Vdd
            }

            pub fn set_ref7_8vdd(&mut self) -> &mut Self {
                *self = Self::Ref7_8Vdd;
                self
            }

            pub fn is_aref(&self) -> bool {
                *self == Self::ARef
            }

            pub fn set_aref(&mut self) -> &mut Self {
                *self = Self::ARef;
                self
            }

            pub fn is_ref1_16vdd(&self) -> bool {
                *self == Self::Ref1_16Vdd
            }

            pub fn set_ref1_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref1_16Vdd;
                self
            }

            pub fn is_ref3_16vdd(&self) -> bool {
                *self == Self::Ref3_16Vdd
            }

            pub fn set_ref3_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref3_16Vdd;
                self
            }

            pub fn is_ref5_16vdd(&self) -> bool {
                *self == Self::Ref5_16Vdd
            }

            pub fn set_ref5_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref5_16Vdd;
                self
            }

            pub fn is_ref7_16vdd(&self) -> bool {
                *self == Self::Ref7_16Vdd
            }

            pub fn set_ref7_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref7_16Vdd;
                self
            }

            pub fn is_ref9_16vdd(&self) -> bool {
                *self == Self::Ref9_16Vdd
            }

            pub fn set_ref9_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref9_16Vdd;
                self
            }

            pub fn is_ref11_16vdd(&self) -> bool {
                *self == Self::Ref11_16Vdd
            }

            pub fn set_ref11_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref11_16Vdd;
                self
            }

            pub fn is_ref13_16vdd(&self) -> bool {
                *self == Self::Ref13_16Vdd
            }

            pub fn set_ref13_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref13_16Vdd;
                self
            }

            pub fn is_ref15_16vdd(&self) -> bool {
                *self == Self::Ref15_16Vdd
            }

            pub fn set_ref15_16vdd(&mut self) -> &mut Self {
                *self = Self::Ref15_16Vdd;
                self
            }
        }
    }

    pub mod extrefsel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EXTREFSEL {
            raw: RawRegister<u32>,
        }

        impl EXTREFSEL {
            pub fn write_analogreference0(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference0)
            }

            pub fn write_analogreference1(&mut self) {
                self.write(EXTREFSEL_FIELD::AnalogReference1)
            }
        }

        impl RegisterRead for EXTREFSEL {
            type Value = EXTREFSEL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                EXTREFSEL_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for EXTREFSEL {
            type Value = EXTREFSEL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EXTREFSEL_FIELD u32 =>
                        // Use AIN0 as external analog reference
                        AnalogReference0 = 0,
        // Use AIN1 as external analog reference
                        AnalogReference1 = 1

                    );

        impl EXTREFSEL_FIELD {
            pub fn is_analogreference0(&self) -> bool {
                *self == Self::AnalogReference0
            }

            pub fn set_analogreference0(&mut self) -> &mut Self {
                *self = Self::AnalogReference0;
                self
            }

            pub fn is_analogreference1(&self) -> bool {
                *self == Self::AnalogReference1
            }

            pub fn set_analogreference1(&mut self) -> &mut Self {
                *self = Self::AnalogReference1;
                self
            }
        }
    }

    pub mod anadetect {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ANADETECT {
            raw: RawRegister<u32>,
        }

        impl ANADETECT {
            pub fn write_cross(&mut self) {
                self.write(ANADETECT_FIELD::Cross)
            }

            pub fn write_up(&mut self) {
                self.write(ANADETECT_FIELD::Up)
            }

            pub fn write_down(&mut self) {
                self.write(ANADETECT_FIELD::Down)
            }
        }

        impl RegisterRead for ANADETECT {
            type Value = ANADETECT_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ANADETECT_FIELD::from_value((raw & 0x00000003) >> 0)
            }
        }

        impl RegisterWrite for ANADETECT {
            type Value = ANADETECT_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ANADETECT_FIELD u32 =>
                        // Generate ANADETECT on crossing, both upward crossing and downward crossing
                        Cross = 0,
        // Generate ANADETECT on upward crossing only
                        Up = 1,
        // Generate ANADETECT on downward crossing only
                        Down = 2

                    );

        impl ANADETECT_FIELD {
            pub fn is_cross(&self) -> bool {
                *self == Self::Cross
            }

            pub fn set_cross(&mut self) -> &mut Self {
                *self = Self::Cross;
                self
            }

            pub fn is_up(&self) -> bool {
                *self == Self::Up
            }

            pub fn set_up(&mut self) -> &mut Self {
                *self = Self::Up;
                self
            }

            pub fn is_down(&self) -> bool {
                *self == Self::Down
            }

            pub fn set_down(&mut self) -> &mut Self {
                *self = Self::Down;
                self
            }
        }
    }

    pub mod hyst {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct HYST {
            raw: RawRegister<u32>,
        }

        impl HYST {
            pub fn write_disabled(&mut self) {
                self.write(HYST_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(HYST_FIELD::Enabled)
            }
        }

        impl RegisterRead for HYST {
            type Value = HYST_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                HYST_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for HYST {
            type Value = HYST_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] HYST_FIELD u32 =>
                        // Comparator hysteresis disabled
                        Disabled = 0,
        // Comparator hysteresis enabled
                        Enabled = 1

                    );

        impl HYST_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }
}

pub mod egu0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU0 {
        _hidden: (),
    }

    impl EGU0 {
        const BASE_ADDRESS: u32 = 0x40014000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU0 {
        type Target = EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct EGU0_REGISTERS {
        _hidden: (),
        /// Description collection: Trigger n for triggering the corresponding
        /// TRIGGERED[n] event
        pub tasks_trigger: [TaskRegister; 16],
        _padding_64: [u8; 192],
        /// Description collection: Event number n generated by triggering the
        /// corresponding TRIGGER[n] task
        pub events_triggered: [EventRegister; 16],
        _padding_320: [u8; 448],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn triggered0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_triggered0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_triggered0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered0();
                f(&mut value);
                self.set_triggered0(value)
            }

            pub fn triggered1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_triggered1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_triggered1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered1();
                f(&mut value);
                self.set_triggered1(value)
            }

            pub fn triggered2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_triggered2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_triggered2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered2();
                f(&mut value);
                self.set_triggered2(value)
            }

            pub fn triggered3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_triggered3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_triggered3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered3();
                f(&mut value);
                self.set_triggered3(value)
            }

            pub fn triggered4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_triggered4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_triggered4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered4();
                f(&mut value);
                self.set_triggered4(value)
            }

            pub fn triggered5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_triggered5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_triggered5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered5();
                f(&mut value);
                self.set_triggered5(value)
            }

            pub fn triggered6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_triggered6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_triggered6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered6();
                f(&mut value);
                self.set_triggered6(value)
            }

            pub fn triggered7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_triggered7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_triggered7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered7();
                f(&mut value);
                self.set_triggered7(value)
            }

            pub fn triggered8(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_triggered8(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_triggered8_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered8();
                f(&mut value);
                self.set_triggered8(value)
            }

            pub fn triggered9(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_triggered9(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_triggered9_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered9();
                f(&mut value);
                self.set_triggered9(value)
            }

            pub fn triggered10(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_triggered10(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_triggered10_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered10();
                f(&mut value);
                self.set_triggered10(value)
            }

            pub fn triggered11(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_triggered11(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_triggered11_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered11();
                f(&mut value);
                self.set_triggered11(value)
            }

            pub fn triggered12(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_triggered12(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_triggered12_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered12();
                f(&mut value);
                self.set_triggered12(value)
            }

            pub fn triggered13(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_triggered13(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_triggered13_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered13();
                f(&mut value);
                self.set_triggered13(value)
            }

            pub fn triggered14(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_triggered14(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_triggered14_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered14();
                f(&mut value);
                self.set_triggered14(value)
            }

            pub fn triggered15(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_triggered15(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_triggered15_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered15();
                f(&mut value);
                self.set_triggered15(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn triggered0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_triggered0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_triggered0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered0();
                f(&mut value);
                self.set_triggered0(value)
            }

            pub fn triggered1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_triggered1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_triggered1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered1();
                f(&mut value);
                self.set_triggered1(value)
            }

            pub fn triggered2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_triggered2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_triggered2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered2();
                f(&mut value);
                self.set_triggered2(value)
            }

            pub fn triggered3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_triggered3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_triggered3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered3();
                f(&mut value);
                self.set_triggered3(value)
            }

            pub fn triggered4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_triggered4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_triggered4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered4();
                f(&mut value);
                self.set_triggered4(value)
            }

            pub fn triggered5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_triggered5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_triggered5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered5();
                f(&mut value);
                self.set_triggered5(value)
            }

            pub fn triggered6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_triggered6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_triggered6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered6();
                f(&mut value);
                self.set_triggered6(value)
            }

            pub fn triggered7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_triggered7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_triggered7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered7();
                f(&mut value);
                self.set_triggered7(value)
            }

            pub fn triggered8(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_triggered8(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_triggered8_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered8();
                f(&mut value);
                self.set_triggered8(value)
            }

            pub fn triggered9(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_triggered9(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_triggered9_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered9();
                f(&mut value);
                self.set_triggered9(value)
            }

            pub fn triggered10(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_triggered10(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_triggered10_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered10();
                f(&mut value);
                self.set_triggered10(value)
            }

            pub fn triggered11(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_triggered11(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_triggered11_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered11();
                f(&mut value);
                self.set_triggered11(value)
            }

            pub fn triggered12(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_triggered12(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_triggered12_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered12();
                f(&mut value);
                self.set_triggered12(value)
            }

            pub fn triggered13(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_triggered13(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_triggered13_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered13();
                f(&mut value);
                self.set_triggered13(value)
            }

            pub fn triggered14(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_triggered14(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_triggered14_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered14();
                f(&mut value);
                self.set_triggered14(value)
            }

            pub fn triggered15(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_triggered15(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_triggered15_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered15();
                f(&mut value);
                self.set_triggered15(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_triggered0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_triggered1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_triggered2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_triggered3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_triggered4(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_triggered5(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_triggered6(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_triggered7(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_triggered8(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_triggered9(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_triggered10(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_triggered11(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_triggered12(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_triggered13(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_triggered14(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_triggered15(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn triggered0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_triggered0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_triggered0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered0();
                f(&mut value);
                self.set_triggered0(value)
            }

            pub fn triggered1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_triggered1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_triggered1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered1();
                f(&mut value);
                self.set_triggered1(value)
            }

            pub fn triggered2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_triggered2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_triggered2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered2();
                f(&mut value);
                self.set_triggered2(value)
            }

            pub fn triggered3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_triggered3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_triggered3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered3();
                f(&mut value);
                self.set_triggered3(value)
            }

            pub fn triggered4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_triggered4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_triggered4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered4();
                f(&mut value);
                self.set_triggered4(value)
            }

            pub fn triggered5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_triggered5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_triggered5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered5();
                f(&mut value);
                self.set_triggered5(value)
            }

            pub fn triggered6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_triggered6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_triggered6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered6();
                f(&mut value);
                self.set_triggered6(value)
            }

            pub fn triggered7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_triggered7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_triggered7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered7();
                f(&mut value);
                self.set_triggered7(value)
            }

            pub fn triggered8(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_triggered8(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_triggered8_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered8();
                f(&mut value);
                self.set_triggered8(value)
            }

            pub fn triggered9(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_triggered9(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_triggered9_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered9();
                f(&mut value);
                self.set_triggered9(value)
            }

            pub fn triggered10(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_triggered10(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_triggered10_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered10();
                f(&mut value);
                self.set_triggered10(value)
            }

            pub fn triggered11(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_triggered11(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_triggered11_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered11();
                f(&mut value);
                self.set_triggered11(value)
            }

            pub fn triggered12(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_triggered12(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_triggered12_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered12();
                f(&mut value);
                self.set_triggered12(value)
            }

            pub fn triggered13(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_triggered13(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_triggered13_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered13();
                f(&mut value);
                self.set_triggered13(value)
            }

            pub fn triggered14(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_triggered14(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_triggered14_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered14();
                f(&mut value);
                self.set_triggered14(value)
            }

            pub fn triggered15(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_triggered15(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_triggered15_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.triggered15();
                f(&mut value);
                self.set_triggered15(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_triggered0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_triggered1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_triggered2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_triggered3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_triggered4(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_triggered5(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_triggered6(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_triggered7(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_triggered8(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_triggered9(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_triggered10(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_triggered11(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_triggered12(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_triggered13(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_triggered14(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_triggered15(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }
        }
    }
}

pub mod swi0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI0 {
        _hidden: (),
    }

    impl SWI0 {
        const BASE_ADDRESS: u32 = 0x40014000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI0 {
        type Target = SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct SWI0_REGISTERS {
        _hidden: (),
        /// Unused.
        pub unused: unused::UNUSED,
    }

    pub mod unused {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct UNUSED {
            raw: RawRegister<u32>,
        }

        impl UNUSED {}

        impl RegisterRead for UNUSED {
            type Value = UNUSED_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                UNUSED_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct UNUSED_READ_VALUE {
            raw: u32,
        }

        impl UNUSED_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }
        }
    }
}

pub mod egu1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU1 {
        _hidden: (),
    }

    impl EGU1 {
        const BASE_ADDRESS: u32 = 0x40015000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU1 {
        type Target = egu0::EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod swi1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI1 {
        _hidden: (),
    }

    impl SWI1 {
        const BASE_ADDRESS: u32 = 0x40015000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI1 {
        type Target = swi0::SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod egu2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU2 {
        _hidden: (),
    }

    impl EGU2 {
        const BASE_ADDRESS: u32 = 0x40016000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU2 {
        type Target = egu0::EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod swi2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI2 {
        _hidden: (),
    }

    impl SWI2 {
        const BASE_ADDRESS: u32 = 0x40016000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI2 {
        type Target = swi0::SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod egu3 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU3 {
        _hidden: (),
    }

    impl EGU3 {
        const BASE_ADDRESS: u32 = 0x40017000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU3 {
        type Target = egu0::EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU3 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod swi3 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI3 {
        _hidden: (),
    }

    impl SWI3 {
        const BASE_ADDRESS: u32 = 0x40017000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI3 {
        type Target = swi0::SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI3 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod egu4 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU4 {
        _hidden: (),
    }

    impl EGU4 {
        const BASE_ADDRESS: u32 = 0x40018000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU4 {
        type Target = egu0::EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU4 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod swi4 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI4 {
        _hidden: (),
    }

    impl SWI4 {
        const BASE_ADDRESS: u32 = 0x40018000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI4 {
        type Target = swi0::SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI4 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod egu5 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct EGU5 {
        _hidden: (),
    }

    impl EGU5 {
        const BASE_ADDRESS: u32 = 0x40019000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for EGU5 {
        type Target = egu0::EGU0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for EGU5 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod swi5 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SWI5 {
        _hidden: (),
    }

    impl SWI5 {
        const BASE_ADDRESS: u32 = 0x40019000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SWI5 {
        type Target = swi0::SWI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SWI5 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod timer3 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TIMER3 {
        _hidden: (),
    }

    impl TIMER3 {
        const BASE_ADDRESS: u32 = 0x4001a000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TIMER3 {
        type Target = timer0::TIMER0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TIMER3 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod timer4 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct TIMER4 {
        _hidden: (),
    }

    impl TIMER4 {
        const BASE_ADDRESS: u32 = 0x4001b000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for TIMER4 {
        type Target = timer0::TIMER0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for TIMER4 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod pwm0 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PWM0 {
        _hidden: (),
    }

    impl PWM0 {
        const BASE_ADDRESS: u32 = 0x4001c000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PWM0 {
        type Target = PWM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PWM0 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct PWM0_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 4],
        /// Stops PWM pulse generation on all channels at the end of current PWM
        /// period, and stops sequence playback
        pub tasks_stop: TaskRegister,
        /// Description collection: Loads the first PWM value on all enabled
        /// channels from sequence n, and starts playing that sequence at the
        /// rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM
        /// generation to start if not running.
        pub tasks_seqstart: [TaskRegister; 2],
        /// Steps by one value in the current sequence on all enabled channels
        /// if DECODER.MODE=NextStep. Does not cause PWM generation to start if
        /// not running.
        pub tasks_nextstep: TaskRegister,
        _padding_20: [u8; 240],
        /// Response to STOP task, emitted when PWM pulses are no longer
        /// generated
        pub events_stopped: EventRegister,
        /// Description collection: First PWM period started on sequence n
        pub events_seqstarted: [EventRegister; 2],
        /// Description collection: Emitted at end of every sequence n, when
        /// last value from RAM has been applied to wave counter
        pub events_seqend: [EventRegister; 2],
        /// Emitted at the end of each PWM period
        pub events_pwmperiodend: EventRegister,
        /// Concatenated sequences have been played the amount of times defined
        /// in LOOP.CNT
        pub events_loopsdone: EventRegister,
        _padding_288: [u8; 224],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 500],
        /// PWM module enable register
        pub enable: enable::ENABLE,
        /// Selects operating mode of the wave counter
        pub mode: mode::MODE,
        /// Value up to which the pulse generator counter counts
        pub countertop: countertop::COUNTERTOP,
        /// Configuration for PWM_CLK
        pub prescaler: prescaler::PRESCALER,
        /// Configuration of the decoder
        pub decoder: decoder::DECODER,
        /// Number of playbacks of a loop
        pub r#loop: r#loop::LOOP,
        _padding_1304: [u8; 8],
        /// Unspecified
        pub seq: [seq::SEQ; 2],
        pub psel: psel::PSEL,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn seqend0_stop(&self) -> SEQEND0_STOP_FIELD {
                let raw = self.raw;
                SEQEND0_STOP_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_seqend0_stop(&mut self, value: SEQEND0_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_seqend0_stop_with<
                F: Fn(&mut SEQEND0_STOP_FIELD) -> &mut SEQEND0_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend0_stop();
                f(&mut value);
                self.set_seqend0_stop(value)
            }

            pub fn seqend1_stop(&self) -> SEQEND1_STOP_FIELD {
                let raw = self.raw;
                SEQEND1_STOP_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_seqend1_stop(&mut self, value: SEQEND1_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_seqend1_stop_with<
                F: Fn(&mut SEQEND1_STOP_FIELD) -> &mut SEQEND1_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend1_stop();
                f(&mut value);
                self.set_seqend1_stop(value)
            }

            pub fn loopsdone_seqstart0(&self) -> LOOPSDONE_SEQSTART0_FIELD {
                let raw = self.raw;
                LOOPSDONE_SEQSTART0_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_loopsdone_seqstart0(
                &mut self,
                value: LOOPSDONE_SEQSTART0_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_loopsdone_seqstart0_with<
                F: Fn(&mut LOOPSDONE_SEQSTART0_FIELD) -> &mut LOOPSDONE_SEQSTART0_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone_seqstart0();
                f(&mut value);
                self.set_loopsdone_seqstart0(value)
            }

            pub fn loopsdone_seqstart1(&self) -> LOOPSDONE_SEQSTART1_FIELD {
                let raw = self.raw;
                LOOPSDONE_SEQSTART1_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_loopsdone_seqstart1(
                &mut self,
                value: LOOPSDONE_SEQSTART1_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_loopsdone_seqstart1_with<
                F: Fn(&mut LOOPSDONE_SEQSTART1_FIELD) -> &mut LOOPSDONE_SEQSTART1_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone_seqstart1();
                f(&mut value);
                self.set_loopsdone_seqstart1(value)
            }

            pub fn loopsdone_stop(&self) -> LOOPSDONE_STOP_FIELD {
                let raw = self.raw;
                LOOPSDONE_STOP_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_loopsdone_stop(&mut self, value: LOOPSDONE_STOP_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_loopsdone_stop_with<
                F: Fn(&mut LOOPSDONE_STOP_FIELD) -> &mut LOOPSDONE_STOP_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone_stop();
                f(&mut value);
                self.set_loopsdone_stop(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SEQEND0_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl SEQEND0_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SEQEND1_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl SEQEND1_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOOPSDONE_SEQSTART0_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LOOPSDONE_SEQSTART0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOOPSDONE_SEQSTART1_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LOOPSDONE_SEQSTART1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOOPSDONE_STOP_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl LOOPSDONE_STOP_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn seqstarted0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_seqstarted0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_seqstarted0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted0();
                f(&mut value);
                self.set_seqstarted0(value)
            }

            pub fn seqstarted1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_seqstarted1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_seqstarted1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted1();
                f(&mut value);
                self.set_seqstarted1(value)
            }

            pub fn seqend0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_seqend0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_seqend0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend0();
                f(&mut value);
                self.set_seqend0(value)
            }

            pub fn seqend1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_seqend1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_seqend1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend1();
                f(&mut value);
                self.set_seqend1(value)
            }

            pub fn pwmperiodend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pwmperiodend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pwmperiodend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pwmperiodend();
                f(&mut value);
                self.set_pwmperiodend(value)
            }

            pub fn loopsdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_loopsdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_loopsdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone();
                f(&mut value);
                self.set_loopsdone(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn seqstarted0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_seqstarted0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_seqstarted0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted0();
                f(&mut value);
                self.set_seqstarted0(value)
            }

            pub fn seqstarted1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_seqstarted1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_seqstarted1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted1();
                f(&mut value);
                self.set_seqstarted1(value)
            }

            pub fn seqend0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_seqend0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_seqend0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend0();
                f(&mut value);
                self.set_seqend0(value)
            }

            pub fn seqend1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_seqend1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_seqend1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend1();
                f(&mut value);
                self.set_seqend1(value)
            }

            pub fn pwmperiodend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pwmperiodend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pwmperiodend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pwmperiodend();
                f(&mut value);
                self.set_pwmperiodend(value)
            }

            pub fn loopsdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_loopsdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_loopsdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone();
                f(&mut value);
                self.set_loopsdone(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_seqstarted0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_seqstarted1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_seqend0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_seqend1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pwmperiodend(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_loopsdone(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn seqstarted0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_seqstarted0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_seqstarted0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted0();
                f(&mut value);
                self.set_seqstarted0(value)
            }

            pub fn seqstarted1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_seqstarted1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_seqstarted1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqstarted1();
                f(&mut value);
                self.set_seqstarted1(value)
            }

            pub fn seqend0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_seqend0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_seqend0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend0();
                f(&mut value);
                self.set_seqend0(value)
            }

            pub fn seqend1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_seqend1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_seqend1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.seqend1();
                f(&mut value);
                self.set_seqend1(value)
            }

            pub fn pwmperiodend(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_pwmperiodend(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_pwmperiodend_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pwmperiodend();
                f(&mut value);
                self.set_pwmperiodend(value)
            }

            pub fn loopsdone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_loopsdone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_loopsdone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.loopsdone();
                f(&mut value);
                self.set_loopsdone(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_seqstarted0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_seqstarted1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_seqend0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_seqend1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_pwmperiodend(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_loopsdone(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disabled
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_with<F: Fn(&mut MODE_VALUE) -> &mut MODE_VALUE>(&mut self, f: F) {
                let mut v = MODE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODE_VALUE {
            raw: u32,
        }

        impl MODE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn updown(&self) -> UPDOWN_FIELD {
                let raw = self.raw;
                UPDOWN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_updown(&mut self, value: UPDOWN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_updown_with<F: Fn(&mut UPDOWN_FIELD) -> &mut UPDOWN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.updown();
                f(&mut value);
                self.set_updown(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] UPDOWN_FIELD u32 =>
                        // Up counter, edge-aligned PWM duty cycle
                        Up = 0,
        // Up and down counter, center-aligned PWM duty cycle
                        UpAndDown = 1

                    );

        impl UPDOWN_FIELD {
            pub fn is_up(&self) -> bool {
                *self == Self::Up
            }

            pub fn set_up(&mut self) -> &mut Self {
                *self = Self::Up;
                self
            }

            pub fn is_upanddown(&self) -> bool {
                *self == Self::UpAndDown
            }

            pub fn set_upanddown(&mut self) -> &mut Self {
                *self = Self::UpAndDown;
                self
            }
        }
    }

    pub mod countertop {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct COUNTERTOP {
            raw: RawRegister<u32>,
        }

        impl COUNTERTOP {}

        impl RegisterRead for COUNTERTOP {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x00007fff) >> 0
            }
        }

        impl RegisterWrite for COUNTERTOP {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0x00007fff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod prescaler {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PRESCALER {
            raw: RawRegister<u32>,
        }

        impl PRESCALER {
            pub fn write_div_1(&mut self) {
                self.write(PRESCALER_FIELD::DIV_1)
            }

            pub fn write_div_2(&mut self) {
                self.write(PRESCALER_FIELD::DIV_2)
            }

            pub fn write_div_4(&mut self) {
                self.write(PRESCALER_FIELD::DIV_4)
            }

            pub fn write_div_8(&mut self) {
                self.write(PRESCALER_FIELD::DIV_8)
            }

            pub fn write_div_16(&mut self) {
                self.write(PRESCALER_FIELD::DIV_16)
            }

            pub fn write_div_32(&mut self) {
                self.write(PRESCALER_FIELD::DIV_32)
            }

            pub fn write_div_64(&mut self) {
                self.write(PRESCALER_FIELD::DIV_64)
            }

            pub fn write_div_128(&mut self) {
                self.write(PRESCALER_FIELD::DIV_128)
            }
        }

        impl RegisterRead for PRESCALER {
            type Value = PRESCALER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                PRESCALER_FIELD::from_value((raw & 0x00000007) >> 0)
            }
        }

        impl RegisterWrite for PRESCALER {
            type Value = PRESCALER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRESCALER_FIELD u32 =>
                        // Divide by 1 (16 MHz)
                        DIV_1 = 0,
        // Divide by 2 (8 MHz)
                        DIV_2 = 1,
        // Divide by 4 (4 MHz)
                        DIV_4 = 2,
        // Divide by 8 (2 MHz)
                        DIV_8 = 3,
        // Divide by 16 (1 MHz)
                        DIV_16 = 4,
        // Divide by 32 (500 kHz)
                        DIV_32 = 5,
        // Divide by 64 (250 kHz)
                        DIV_64 = 6,
        // Divide by 128 (125 kHz)
                        DIV_128 = 7

                    );

        impl PRESCALER_FIELD {
            pub fn is_div_1(&self) -> bool {
                *self == Self::DIV_1
            }

            pub fn set_div_1(&mut self) -> &mut Self {
                *self = Self::DIV_1;
                self
            }

            pub fn is_div_2(&self) -> bool {
                *self == Self::DIV_2
            }

            pub fn set_div_2(&mut self) -> &mut Self {
                *self = Self::DIV_2;
                self
            }

            pub fn is_div_4(&self) -> bool {
                *self == Self::DIV_4
            }

            pub fn set_div_4(&mut self) -> &mut Self {
                *self = Self::DIV_4;
                self
            }

            pub fn is_div_8(&self) -> bool {
                *self == Self::DIV_8
            }

            pub fn set_div_8(&mut self) -> &mut Self {
                *self = Self::DIV_8;
                self
            }

            pub fn is_div_16(&self) -> bool {
                *self == Self::DIV_16
            }

            pub fn set_div_16(&mut self) -> &mut Self {
                *self = Self::DIV_16;
                self
            }

            pub fn is_div_32(&self) -> bool {
                *self == Self::DIV_32
            }

            pub fn set_div_32(&mut self) -> &mut Self {
                *self = Self::DIV_32;
                self
            }

            pub fn is_div_64(&self) -> bool {
                *self == Self::DIV_64
            }

            pub fn set_div_64(&mut self) -> &mut Self {
                *self = Self::DIV_64;
                self
            }

            pub fn is_div_128(&self) -> bool {
                *self == Self::DIV_128
            }

            pub fn set_div_128(&mut self) -> &mut Self {
                *self = Self::DIV_128;
                self
            }
        }
    }

    pub mod decoder {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DECODER {
            raw: RawRegister<u32>,
        }

        impl DECODER {
            pub fn write_with<F: Fn(&mut DECODER_VALUE) -> &mut DECODER_VALUE>(&mut self, f: F) {
                let mut v = DECODER_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DECODER {
            type Value = DECODER_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DECODER_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DECODER {
            type Value = DECODER_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DECODER_VALUE {
            raw: u32,
        }

        impl DECODER_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn load(&self) -> LOAD_FIELD {
                let raw = self.raw;
                LOAD_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_load(&mut self, value: LOAD_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_load_with<F: Fn(&mut LOAD_FIELD) -> &mut LOAD_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.load();
                f(&mut value);
                self.set_load(value)
            }

            pub fn mode(&self) -> MODE_FIELD {
                let raw = self.raw;
                MODE_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_mode(&mut self, value: MODE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_mode_with<F: Fn(&mut MODE_FIELD) -> &mut MODE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.mode();
                f(&mut value);
                self.set_mode(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOAD_FIELD u32 =>
                        // 1st half word (16-bit) used in all PWM channels 0..3
                        Common = 0,
        // 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
                        Grouped = 1,
        // 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
                        Individual = 2,
        // 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
                        WaveForm = 3

                    );

        impl LOAD_FIELD {
            pub fn is_common(&self) -> bool {
                *self == Self::Common
            }

            pub fn set_common(&mut self) -> &mut Self {
                *self = Self::Common;
                self
            }

            pub fn is_grouped(&self) -> bool {
                *self == Self::Grouped
            }

            pub fn set_grouped(&mut self) -> &mut Self {
                *self = Self::Grouped;
                self
            }

            pub fn is_individual(&self) -> bool {
                *self == Self::Individual
            }

            pub fn set_individual(&mut self) -> &mut Self {
                *self = Self::Individual;
                self
            }

            pub fn is_waveform(&self) -> bool {
                *self == Self::WaveForm
            }

            pub fn set_waveform(&mut self) -> &mut Self {
                *self = Self::WaveForm;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                        // SEQ[n].REFRESH is used to determine loading internal compare registers
                        RefreshCount = 0,
        // NEXTSTEP task causes a new value to be loaded to internal compare registers
                        NextStep = 1

                    );

        impl MODE_FIELD {
            pub fn is_refreshcount(&self) -> bool {
                *self == Self::RefreshCount
            }

            pub fn set_refreshcount(&mut self) -> &mut Self {
                *self = Self::RefreshCount;
                self
            }

            pub fn is_nextstep(&self) -> bool {
                *self == Self::NextStep
            }

            pub fn set_nextstep(&mut self) -> &mut Self {
                *self = Self::NextStep;
                self
            }
        }
    }

    pub mod r#loop {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LOOP {
            raw: RawRegister<u32>,
        }

        impl LOOP {
            pub fn write_with<F: Fn(&mut LOOP_VALUE) -> &mut LOOP_VALUE>(&mut self, f: F) {
                let mut v = LOOP_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for LOOP {
            type Value = LOOP_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                LOOP_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for LOOP {
            type Value = LOOP_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct LOOP_VALUE {
            raw: u32,
        }

        impl LOOP_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_cnt(&mut self) -> &mut Self {
                let value = CNT_FIELD::Disabled.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ffff) | (value << 0);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CNT_FIELD u32 =>
            // Looping disabled (stop at the end of the sequence)
            Disabled = 0

        );

        impl CNT_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }
        }
    }

    pub mod seq {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct SEQ {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Beginning address in RAM of this sequence
            pub ptr: ptr::PTR,
            /// Description cluster: Number of values (duty cycles) in this
            /// sequence
            pub cnt: cnt::CNT,
            /// Description cluster: Number of additional PWM periods between
            /// samples loaded into compare register
            pub refresh: refresh::REFRESH,
            /// Description cluster: Time added after the sequence
            pub enddelay: enddelay::ENDDELAY,
            _padding_16: [u8; 16],
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod cnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct CNT {
                raw: RawRegister<u32>,
            }

            impl CNT {
                pub fn write_disabled(&mut self) {
                    self.write(CNT_FIELD::Disabled)
                }
            }

            impl RegisterRead for CNT {
                type Value = CNT_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    CNT_FIELD::from_value((raw & 0x00007fff) >> 0)
                }
            }

            impl RegisterWrite for CNT {
                type Value = CNT_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CNT_FIELD u32 =>
                // Sequence is disabled, and shall not be started as it is empty
                Disabled = 0

            );

            impl CNT_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }
            }
        }

        pub mod refresh {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct REFRESH {
                raw: RawRegister<u32>,
            }

            impl REFRESH {
                pub fn write_with<F: Fn(&mut REFRESH_VALUE) -> &mut REFRESH_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = REFRESH_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for REFRESH {
                type Value = REFRESH_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    REFRESH_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for REFRESH {
                type Value = REFRESH_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct REFRESH_VALUE {
                raw: u32,
            }

            impl REFRESH_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn set_cnt(&mut self) -> &mut Self {
                    let value = CNT_FIELD::Continuous.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ffffff) | (value << 0);
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CNT_FIELD u32 =>
                // Update every PWM period
                Continuous = 0

            );

            impl CNT_FIELD {
                pub fn is_continuous(&self) -> bool {
                    *self == Self::Continuous
                }

                pub fn set_continuous(&mut self) -> &mut Self {
                    *self = Self::Continuous;
                    self
                }
            }
        }

        pub mod enddelay {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct ENDDELAY {
                raw: RawRegister<u32>,
            }

            impl ENDDELAY {
                pub fn write_with<F: Fn(&mut ENDDELAY_VALUE) -> &mut ENDDELAY_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = ENDDELAY_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for ENDDELAY {
                type Value = ENDDELAY_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    ENDDELAY_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for ENDDELAY {
                type Value = ENDDELAY_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct ENDDELAY_VALUE {
                raw: u32,
            }

            impl ENDDELAY_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn cnt(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00ffffff) >> 0
                }

                pub fn set_cnt(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00ffffff) | (value << 0);
                    self
                }
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description collection: Output pin select for PWM channel n
            pub out: [PinSelectRegister; 4],
        }
    }
}

pub mod pdm {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PDM {
        _hidden: (),
    }

    impl PDM {
        const BASE_ADDRESS: u32 = 0x4001d000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PDM {
        type Target = PDM_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PDM {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct PDM_REGISTERS {
        _hidden: (),
        /// Starts continuous PDM transfer
        pub tasks_start: TaskRegister,
        /// Stops PDM transfer
        pub tasks_stop: TaskRegister,
        _padding_8: [u8; 248],
        /// PDM transfer has started
        pub events_started: EventRegister,
        /// PDM transfer has finished
        pub events_stopped: EventRegister,
        /// The PDM has written the last sample specified by SAMPLE.MAXCNT (or
        /// the last sample after a STOP task has been received) to Data RAM
        pub events_end: EventRegister,
        _padding_268: [u8; 500],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 500],
        /// PDM module enable register
        pub enable: enable::ENABLE,
        /// PDM clock generator control
        pub pdmclkctrl: pdmclkctrl::PDMCLKCTRL,
        /// Defines the routing of the connected PDM microphones' signals
        pub mode: mode::MODE,
        _padding_1292: [u8; 12],
        /// Left output gain adjustment
        pub gainl: gainl::GAINL,
        /// Right output gain adjustment
        pub gainr: gainr::GAINR,
        /// Selects the ratio between PDM_CLK and output sample rate. Change
        /// PDMCLKCTRL accordingly.
        pub ratio: ratio::RATIO,
        _padding_1316: [u8; 28],
        pub psel: psel::PSEL,
        _padding_1352: [u8; 24],
        pub sample: sample::SAMPLE,
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn end(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_end(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_end_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.end();
                f(&mut value);
                self.set_end(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_end(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod pdmclkctrl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct PDMCLKCTRL {
            raw: RawRegister<u32>,
        }

        impl PDMCLKCTRL {
            pub fn write_with<F: Fn(&mut PDMCLKCTRL_VALUE) -> &mut PDMCLKCTRL_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = PDMCLKCTRL_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for PDMCLKCTRL {
            type Value = PDMCLKCTRL_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                PDMCLKCTRL_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for PDMCLKCTRL {
            type Value = PDMCLKCTRL_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct PDMCLKCTRL_VALUE {
            raw: u32,
        }

        impl PDMCLKCTRL_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn freq(&self) -> FREQ_FIELD {
                let raw = self.raw;
                FREQ_FIELD::from_value((raw & 0xffffffff) >> 0)
            }

            pub fn set_freq(&mut self, value: FREQ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0xffffffff) | (value << 0);
                self
            }

            pub fn set_freq_with<F: Fn(&mut FREQ_FIELD) -> &mut FREQ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.freq();
                f(&mut value);
                self.set_freq(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] FREQ_FIELD u32 =>
                        // PDM_CLK = 32 MHz / 32 = 1.000 MHz
                        _1000K = 134217728,
        // PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal clock for RATIO=Ratio64.
                        Default = 138412032,
        // PDM_CLK = 32 MHz / 30 = 1.067 MHz
                        _1067K = 142606336,
        // PDM_CLK = 32 MHz / 26 = 1.231 MHz
                        _1231K = 159383552,
        // PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal clock for RATIO=Ratio80.
                        _1280K = 167772160,
        // PDM_CLK = 32 MHz / 24 = 1.333 MHz
                        _1333K = 176160768

                    );

        impl FREQ_FIELD {
            pub fn is_1000k(&self) -> bool {
                *self == Self::_1000K
            }

            pub fn set_1000k(&mut self) -> &mut Self {
                *self = Self::_1000K;
                self
            }

            pub fn is_default(&self) -> bool {
                *self == Self::Default
            }

            pub fn set_default(&mut self) -> &mut Self {
                *self = Self::Default;
                self
            }

            pub fn is_1067k(&self) -> bool {
                *self == Self::_1067K
            }

            pub fn set_1067k(&mut self) -> &mut Self {
                *self = Self::_1067K;
                self
            }

            pub fn is_1231k(&self) -> bool {
                *self == Self::_1231K
            }

            pub fn set_1231k(&mut self) -> &mut Self {
                *self = Self::_1231K;
                self
            }

            pub fn is_1280k(&self) -> bool {
                *self == Self::_1280K
            }

            pub fn set_1280k(&mut self) -> &mut Self {
                *self = Self::_1280K;
                self
            }

            pub fn is_1333k(&self) -> bool {
                *self == Self::_1333K
            }

            pub fn set_1333k(&mut self) -> &mut Self {
                *self = Self::_1333K;
                self
            }
        }
    }

    pub mod mode {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct MODE {
            raw: RawRegister<u32>,
        }

        impl MODE {
            pub fn write_with<F: Fn(&mut MODE_VALUE) -> &mut MODE_VALUE>(&mut self, f: F) {
                let mut v = MODE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                MODE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for MODE {
            type Value = MODE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct MODE_VALUE {
            raw: u32,
        }

        impl MODE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn operation(&self) -> OPERATION_FIELD {
                let raw = self.raw;
                OPERATION_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_operation(&mut self, value: OPERATION_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_operation_with<F: Fn(&mut OPERATION_FIELD) -> &mut OPERATION_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.operation();
                f(&mut value);
                self.set_operation(value)
            }

            pub fn edge(&self) -> EDGE_FIELD {
                let raw = self.raw;
                EDGE_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_edge(&mut self, value: EDGE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_edge_with<F: Fn(&mut EDGE_FIELD) -> &mut EDGE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.edge();
                f(&mut value);
                self.set_edge(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OPERATION_FIELD u32 =>
                        // Sample and store one pair (left + right) of 16-bit samples per RAM word R=[31:16]; L=[15:0]
                        Stereo = 0,
        // Sample and store two successive left samples (16 bits each) per RAM word L1=[31:16]; L0=[15:0]
                        Mono = 1

                    );

        impl OPERATION_FIELD {
            pub fn is_stereo(&self) -> bool {
                *self == Self::Stereo
            }

            pub fn set_stereo(&mut self) -> &mut Self {
                *self = Self::Stereo;
                self
            }

            pub fn is_mono(&self) -> bool {
                *self == Self::Mono
            }

            pub fn set_mono(&mut self) -> &mut Self {
                *self = Self::Mono;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EDGE_FIELD u32 =>
                        // Left (or mono) is sampled on falling edge of PDM_CLK
                        LeftFalling = 0,
        // Left (or mono) is sampled on rising edge of PDM_CLK
                        LeftRising = 1

                    );

        impl EDGE_FIELD {
            pub fn is_leftfalling(&self) -> bool {
                *self == Self::LeftFalling
            }

            pub fn set_leftfalling(&mut self) -> &mut Self {
                *self = Self::LeftFalling;
                self
            }

            pub fn is_leftrising(&self) -> bool {
                *self == Self::LeftRising
            }

            pub fn set_leftrising(&mut self) -> &mut Self {
                *self = Self::LeftRising;
                self
            }
        }
    }

    pub mod gainl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct GAINL {
            raw: RawRegister<u32>,
        }

        impl GAINL {
            pub fn write_mingain(&mut self) {
                self.write(GAINL_FIELD::MinGain)
            }

            pub fn write_defaultgain(&mut self) {
                self.write(GAINL_FIELD::DefaultGain)
            }

            pub fn write_maxgain(&mut self) {
                self.write(GAINL_FIELD::MaxGain)
            }
        }

        impl RegisterRead for GAINL {
            type Value = GAINL_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                GAINL_FIELD::from_value((raw & 0x0000007f) >> 0)
            }
        }

        impl RegisterWrite for GAINL {
            type Value = GAINL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] GAINL_FIELD u32 =>
                        // -20 dB gain adjustment (minimum)
                        MinGain = 0,
        // 0 dB gain adjustment
                        DefaultGain = 40,
        // +20 dB gain adjustment (maximum)
                        MaxGain = 80

                    );

        impl GAINL_FIELD {
            pub fn is_mingain(&self) -> bool {
                *self == Self::MinGain
            }

            pub fn set_mingain(&mut self) -> &mut Self {
                *self = Self::MinGain;
                self
            }

            pub fn is_defaultgain(&self) -> bool {
                *self == Self::DefaultGain
            }

            pub fn set_defaultgain(&mut self) -> &mut Self {
                *self = Self::DefaultGain;
                self
            }

            pub fn is_maxgain(&self) -> bool {
                *self == Self::MaxGain
            }

            pub fn set_maxgain(&mut self) -> &mut Self {
                *self = Self::MaxGain;
                self
            }
        }
    }

    pub mod gainr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct GAINR {
            raw: RawRegister<u32>,
        }

        impl GAINR {
            pub fn write_mingain(&mut self) {
                self.write(GAINR_FIELD::MinGain)
            }

            pub fn write_defaultgain(&mut self) {
                self.write(GAINR_FIELD::DefaultGain)
            }

            pub fn write_maxgain(&mut self) {
                self.write(GAINR_FIELD::MaxGain)
            }
        }

        impl RegisterRead for GAINR {
            type Value = GAINR_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                GAINR_FIELD::from_value((raw & 0x0000007f) >> 0)
            }
        }

        impl RegisterWrite for GAINR {
            type Value = GAINR_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] GAINR_FIELD u32 =>
                        // -20 dB gain adjustment (minimum)
                        MinGain = 0,
        // 0 dB gain adjustment
                        DefaultGain = 40,
        // +20 dB gain adjustment (maximum)
                        MaxGain = 80

                    );

        impl GAINR_FIELD {
            pub fn is_mingain(&self) -> bool {
                *self == Self::MinGain
            }

            pub fn set_mingain(&mut self) -> &mut Self {
                *self = Self::MinGain;
                self
            }

            pub fn is_defaultgain(&self) -> bool {
                *self == Self::DefaultGain
            }

            pub fn set_defaultgain(&mut self) -> &mut Self {
                *self = Self::DefaultGain;
                self
            }

            pub fn is_maxgain(&self) -> bool {
                *self == Self::MaxGain
            }

            pub fn set_maxgain(&mut self) -> &mut Self {
                *self = Self::MaxGain;
                self
            }
        }
    }

    pub mod ratio {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct RATIO {
            raw: RawRegister<u32>,
        }

        impl RATIO {
            pub fn write_ratio64(&mut self) {
                self.write(RATIO_FIELD::Ratio64)
            }

            pub fn write_ratio80(&mut self) {
                self.write(RATIO_FIELD::Ratio80)
            }
        }

        impl RegisterRead for RATIO {
            type Value = RATIO_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                RATIO_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for RATIO {
            type Value = RATIO_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RATIO_FIELD u32 =>
                        // Ratio of 64
                        Ratio64 = 0,
        // Ratio of 80
                        Ratio80 = 1

                    );

        impl RATIO_FIELD {
            pub fn is_ratio64(&self) -> bool {
                *self == Self::Ratio64
            }

            pub fn set_ratio64(&mut self) -> &mut Self {
                *self = Self::Ratio64;
                self
            }

            pub fn is_ratio80(&self) -> bool {
                *self == Self::Ratio80
            }

            pub fn set_ratio80(&mut self) -> &mut Self {
                *self = Self::Ratio80;
                self
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin number configuration for PDM CLK signal
            pub clk: PinSelectRegister,
            /// Pin number configuration for PDM DIN signal
            pub din: PinSelectRegister,
        }
    }

    pub mod sample {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct SAMPLE {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// RAM address pointer to write samples to with EasyDMA
            pub ptr: ptr::PTR,
            /// Number of samples to allocate memory for in EasyDMA mode
            pub maxcnt: maxcnt::MAXCNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {
                pub fn write_with<F: Fn(&mut PTR_VALUE) -> &mut PTR_VALUE>(&mut self, f: F) {
                    let mut v = PTR_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for PTR {
                type Value = PTR_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    PTR_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for PTR {
                type Value = PTR_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct PTR_VALUE {
                raw: u32,
            }

            impl PTR_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn sampleptr(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0xffffffff) >> 0
                }

                pub fn set_sampleptr(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0xffffffff) | (value << 0);
                    self
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {
                pub fn write_with<F: Fn(&mut MAXCNT_VALUE) -> &mut MAXCNT_VALUE>(&mut self, f: F) {
                    let mut v = MAXCNT_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for MAXCNT {
                type Value = MAXCNT_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    MAXCNT_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = MAXCNT_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct MAXCNT_VALUE {
                raw: u32,
            }

            impl MAXCNT_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn buffsize(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x00007fff) >> 0
                }

                pub fn set_buffsize(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00007fff) | (value << 0);
                    self
                }
            }
        }
    }
}

pub mod acl {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct ACL {
        _hidden: (),
    }

    impl ACL {
        const BASE_ADDRESS: u32 = 0x4001e000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for ACL {
        type Target = ACL_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for ACL {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct ACL_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 2048],
        /// Unspecified
        pub acl: [acl::ACL; 8],
    }

    pub mod acl {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct ACL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Start address of region to protect. The
            /// start address must be word-aligned.
            pub addr: addr::ADDR,
            /// Description cluster: Size of region to protect counting from
            /// address ACL[n].ADDR. Writing a '0' has no effect.
            pub size: size::SIZE,
            /// Description cluster: Access permissions for region n as defined
            /// by start address ACL[n].ADDR and size ACL[n].SIZE
            pub perm: perm::PERM,
            _padding_12: [u8; 4],
        }

        pub mod addr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct ADDR {
                raw: RawRegister<u32>,
            }

            impl ADDR {}

            impl RegisterRead for ADDR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for ADDR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod size {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct SIZE {
                raw: RawRegister<u32>,
            }

            impl SIZE {}

            impl RegisterRead for SIZE {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for SIZE {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod perm {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PERM {
                raw: RawRegister<u32>,
            }

            impl PERM {
                pub fn write_with<F: Fn(&mut PERM_WRITE_VALUE) -> &mut PERM_WRITE_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = PERM_WRITE_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for PERM {
                type Value = PERM_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    PERM_READ_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for PERM {
                type Value = PERM_WRITE_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct PERM_READ_VALUE {
                raw: u32,
            }

            impl PERM_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn write(&self) -> WRITE_FIELD {
                    let raw = self.raw;
                    WRITE_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_write(&mut self, value: WRITE_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_write_with<F: Fn(&mut WRITE_FIELD) -> &mut WRITE_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.write();
                    f(&mut value);
                    self.set_write(value)
                }

                pub fn read(&self) -> READ_FIELD {
                    let raw = self.raw;
                    READ_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_read(&mut self, value: READ_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_read_with<F: Fn(&mut READ_FIELD) -> &mut READ_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.read();
                    f(&mut value);
                    self.set_read(value)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct PERM_WRITE_VALUE {
                raw: u32,
            }

            impl PERM_WRITE_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn write(&self) -> WRITE_FIELD {
                    let raw = self.raw;
                    WRITE_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_write(&mut self, value: WRITE_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_write_with<F: Fn(&mut WRITE_FIELD) -> &mut WRITE_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.write();
                    f(&mut value);
                    self.set_write(value)
                }

                pub fn read(&self) -> READ_FIELD {
                    let raw = self.raw;
                    READ_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_read(&mut self, value: READ_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_read_with<F: Fn(&mut READ_FIELD) -> &mut READ_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.read();
                    f(&mut value);
                    self.set_read(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] WRITE_FIELD u32 =>
                            // Allow write and erase instructions to region n.
                            Enable = 0,
            // Block write and erase instructions to region n.
                            Disable = 1

                        );

            impl WRITE_FIELD {
                pub fn is_enable(&self) -> bool {
                    *self == Self::Enable
                }

                pub fn set_enable(&mut self) -> &mut Self {
                    *self = Self::Enable;
                    self
                }

                pub fn is_disable(&self) -> bool {
                    *self == Self::Disable
                }

                pub fn set_disable(&mut self) -> &mut Self {
                    *self = Self::Disable;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] READ_FIELD u32 =>
                            // Allow read instructions to region n.
                            Enable = 0,
            // Block read instructions to region n.
                            Disable = 1

                        );

            impl READ_FIELD {
                pub fn is_enable(&self) -> bool {
                    *self == Self::Enable
                }

                pub fn set_enable(&mut self) -> &mut Self {
                    *self = Self::Enable;
                    self
                }

                pub fn is_disable(&self) -> bool {
                    *self == Self::Disable
                }

                pub fn set_disable(&mut self) -> &mut Self {
                    *self = Self::Disable;
                    self
                }
            }
        }
    }
}

pub mod nvmc {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct NVMC {
        _hidden: (),
    }

    impl NVMC {
        const BASE_ADDRESS: u32 = 0x4001e000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for NVMC {
        type Target = NVMC_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for NVMC {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct NVMC_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 1024],
        /// Ready flag
        pub ready: ready::READY,
        _padding_1028: [u8; 4],
        /// Ready flag
        pub readynext: readynext::READYNEXT,
        _padding_1036: [u8; 248],
        /// Configuration register
        pub config: config::CONFIG,
        /// Register for erasing a page in code area
        pub erasepage: erasepage::ERASEPAGE,
        /// Register for erasing all non-volatile user memory
        pub eraseall: eraseall::ERASEALL,
        /// Deprecated register - Register for erasing a page in code area,
        /// equivalent to ERASEPAGE
        pub erasepcr0: erasepcr0::ERASEPCR0,
        /// Register for erasing user information configuration registers
        pub eraseuicr: eraseuicr::ERASEUICR,
        /// Register for partial erase of a page in code area
        pub erasepagepartial: erasepagepartial::ERASEPAGEPARTIAL,
        /// Register for partial erase configuration
        pub erasepagepartialcfg: erasepagepartialcfg::ERASEPAGEPARTIALCFG,
        _padding_1312: [u8; 32],
        /// I-code cache configuration register
        pub icachecnf: icachecnf::ICACHECNF,
        _padding_1348: [u8; 4],
        /// I-code cache hit counter
        pub ihit: ihit::IHIT,
        /// I-code cache miss counter
        pub imiss: imiss::IMISS,
    }

    pub mod ready {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct READY {
            raw: RawRegister<u32>,
        }

        impl READY {}

        impl RegisterRead for READY {
            type Value = READY_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                READY_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_FIELD u32 =>
                        // NVMC is busy (on-going write or erase operation)
                        Busy = 0,
        // NVMC is ready
                        Ready = 1

                    );

        impl READY_FIELD {
            pub fn is_busy(&self) -> bool {
                *self == Self::Busy
            }

            pub fn set_busy(&mut self) -> &mut Self {
                *self = Self::Busy;
                self
            }

            pub fn is_ready(&self) -> bool {
                *self == Self::Ready
            }

            pub fn set_ready(&mut self) -> &mut Self {
                *self = Self::Ready;
                self
            }
        }
    }

    pub mod readynext {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct READYNEXT {
            raw: RawRegister<u32>,
        }

        impl READYNEXT {}

        impl RegisterRead for READYNEXT {
            type Value = READYNEXT_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                READYNEXT_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READYNEXT_FIELD u32 =>
                        // NVMC cannot accept any write operation
                        Busy = 0,
        // NVMC is ready
                        Ready = 1

                    );

        impl READYNEXT_FIELD {
            pub fn is_busy(&self) -> bool {
                *self == Self::Busy
            }

            pub fn set_busy(&mut self) -> &mut Self {
                *self = Self::Busy;
                self
            }

            pub fn is_ready(&self) -> bool {
                *self == Self::Ready
            }

            pub fn set_ready(&mut self) -> &mut Self {
                *self = Self::Ready;
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CONFIG {
            raw: RawRegister<u32>,
        }

        impl CONFIG {
            pub fn write_with<F: Fn(&mut CONFIG_VALUE) -> &mut CONFIG_VALUE>(&mut self, f: F) {
                let mut v = CONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CONFIG {
            type Value = CONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CONFIG_VALUE {
            raw: u32,
        }

        impl CONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn wen(&self) -> WEN_FIELD {
                let raw = self.raw;
                WEN_FIELD::from_value((raw & 0x00000003) >> 0)
            }

            pub fn set_wen(&mut self, value: WEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000003) | (value << 0);
                self
            }

            pub fn set_wen_with<F: Fn(&mut WEN_FIELD) -> &mut WEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.wen();
                f(&mut value);
                self.set_wen(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] WEN_FIELD u32 =>
                        // Read only access
                        Ren = 0,
        // Write enabled
                        Wen = 1,
        // Erase enabled
                        Een = 2

                    );

        impl WEN_FIELD {
            pub fn is_ren(&self) -> bool {
                *self == Self::Ren
            }

            pub fn set_ren(&mut self) -> &mut Self {
                *self = Self::Ren;
                self
            }

            pub fn is_wen(&self) -> bool {
                *self == Self::Wen
            }

            pub fn set_wen(&mut self) -> &mut Self {
                *self = Self::Wen;
                self
            }

            pub fn is_een(&self) -> bool {
                *self == Self::Een
            }

            pub fn set_een(&mut self) -> &mut Self {
                *self = Self::Een;
                self
            }
        }
    }

    pub mod erasepage {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEPAGE {
            raw: RawRegister<u32>,
        }

        impl ERASEPAGE {}

        impl RegisterWrite for ERASEPAGE {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod eraseall {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEALL {
            raw: RawRegister<u32>,
        }

        impl ERASEALL {
            pub fn write_nooperation(&mut self) {
                self.write(ERASEALL_FIELD::NoOperation)
            }

            pub fn write_erase(&mut self) {
                self.write(ERASEALL_FIELD::Erase)
            }
        }

        impl RegisterWrite for ERASEALL {
            type Value = ERASEALL_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ERASEALL_FIELD u32 =>
                        // No operation
                        NoOperation = 0,
        // Start chip erase
                        Erase = 1

                    );

        impl ERASEALL_FIELD {
            pub fn is_nooperation(&self) -> bool {
                *self == Self::NoOperation
            }

            pub fn set_nooperation(&mut self) -> &mut Self {
                *self = Self::NoOperation;
                self
            }

            pub fn is_erase(&self) -> bool {
                *self == Self::Erase
            }

            pub fn set_erase(&mut self) -> &mut Self {
                *self = Self::Erase;
                self
            }
        }
    }

    pub mod erasepcr0 {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEPCR0 {
            raw: RawRegister<u32>,
        }

        impl ERASEPCR0 {}

        impl RegisterWrite for ERASEPCR0 {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod eraseuicr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEUICR {
            raw: RawRegister<u32>,
        }

        impl ERASEUICR {
            pub fn write_nooperation(&mut self) {
                self.write(ERASEUICR_FIELD::NoOperation)
            }

            pub fn write_erase(&mut self) {
                self.write(ERASEUICR_FIELD::Erase)
            }
        }

        impl RegisterWrite for ERASEUICR {
            type Value = ERASEUICR_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ERASEUICR_FIELD u32 =>
                        // No operation
                        NoOperation = 0,
        // Start erase of UICR
                        Erase = 1

                    );

        impl ERASEUICR_FIELD {
            pub fn is_nooperation(&self) -> bool {
                *self == Self::NoOperation
            }

            pub fn set_nooperation(&mut self) -> &mut Self {
                *self = Self::NoOperation;
                self
            }

            pub fn is_erase(&self) -> bool {
                *self == Self::Erase
            }

            pub fn set_erase(&mut self) -> &mut Self {
                *self = Self::Erase;
                self
            }
        }
    }

    pub mod erasepagepartial {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEPAGEPARTIAL {
            raw: RawRegister<u32>,
        }

        impl ERASEPAGEPARTIAL {}

        impl RegisterWrite for ERASEPAGEPARTIAL {
            type Value = u32;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = (old_raw & !0xffffffff) | (value << 0);
                self.raw.write(raw);
            }
        }
    }

    pub mod erasepagepartialcfg {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ERASEPAGEPARTIALCFG {
            raw: RawRegister<u32>,
        }

        impl ERASEPAGEPARTIALCFG {
            pub fn write_with<
                F: Fn(&mut ERASEPAGEPARTIALCFG_VALUE) -> &mut ERASEPAGEPARTIALCFG_VALUE,
            >(
                &mut self,
                f: F,
            ) {
                let mut v = ERASEPAGEPARTIALCFG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ERASEPAGEPARTIALCFG {
            type Value = ERASEPAGEPARTIALCFG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ERASEPAGEPARTIALCFG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ERASEPAGEPARTIALCFG {
            type Value = ERASEPAGEPARTIALCFG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ERASEPAGEPARTIALCFG_VALUE {
            raw: u32,
        }

        impl ERASEPAGEPARTIALCFG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn duration(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000007f) >> 0
            }

            pub fn set_duration(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000007f) | (value << 0);
                self
            }
        }
    }

    pub mod icachecnf {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ICACHECNF {
            raw: RawRegister<u32>,
        }

        impl ICACHECNF {
            pub fn write_with<F: Fn(&mut ICACHECNF_VALUE) -> &mut ICACHECNF_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ICACHECNF_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ICACHECNF {
            type Value = ICACHECNF_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ICACHECNF_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ICACHECNF {
            type Value = ICACHECNF_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ICACHECNF_VALUE {
            raw: u32,
        }

        impl ICACHECNF_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn cacheen(&self) -> CACHEEN_FIELD {
                let raw = self.raw;
                CACHEEN_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_cacheen(&mut self, value: CACHEEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_cacheen_with<F: Fn(&mut CACHEEN_FIELD) -> &mut CACHEEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cacheen();
                f(&mut value);
                self.set_cacheen(value)
            }

            pub fn cacheprofen(&self) -> CACHEPROFEN_FIELD {
                let raw = self.raw;
                CACHEPROFEN_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_cacheprofen(&mut self, value: CACHEPROFEN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_cacheprofen_with<F: Fn(&mut CACHEPROFEN_FIELD) -> &mut CACHEPROFEN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.cacheprofen();
                f(&mut value);
                self.set_cacheprofen(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CACHEEN_FIELD u32 =>
                        // Disable cache. Invalidates all cache entries.
                        Disabled = 0,
        // Enable cache
                        Enabled = 1

                    );

        impl CACHEEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CACHEPROFEN_FIELD u32 =>
                        // Disable cache profiling
                        Disabled = 0,
        // Enable cache profiling
                        Enabled = 1

                    );

        impl CACHEPROFEN_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod ihit {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct IHIT {
            raw: RawRegister<u32>,
        }

        impl IHIT {
            pub fn write_with<F: Fn(&mut IHIT_VALUE) -> &mut IHIT_VALUE>(&mut self, f: F) {
                let mut v = IHIT_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for IHIT {
            type Value = IHIT_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                IHIT_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for IHIT {
            type Value = IHIT_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct IHIT_VALUE {
            raw: u32,
        }

        impl IHIT_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn hits(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xffffffff) >> 0
            }

            pub fn set_hits(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xffffffff) | (value << 0);
                self
            }
        }
    }

    pub mod imiss {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct IMISS {
            raw: RawRegister<u32>,
        }

        impl IMISS {
            pub fn write_with<F: Fn(&mut IMISS_VALUE) -> &mut IMISS_VALUE>(&mut self, f: F) {
                let mut v = IMISS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for IMISS {
            type Value = IMISS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                IMISS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for IMISS {
            type Value = IMISS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct IMISS_VALUE {
            raw: u32,
        }

        impl IMISS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn misses(&self) -> u32 {
                let raw = self.raw;
                (raw & 0xffffffff) >> 0
            }

            pub fn set_misses(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0xffffffff) | (value << 0);
                self
            }
        }
    }
}

pub mod ppi {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PPI {
        _hidden: (),
    }

    impl PPI {
        const BASE_ADDRESS: u32 = 0x4001f000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PPI {
        type Target = PPI_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PPI {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct PPI_REGISTERS {
        _hidden: (),
        /// Channel group tasks
        pub tasks_chg: [tasks_chg::TASKS_CHG; 6],
        _padding_48: [u8; 1232],
        /// Channel enable register
        pub chen: chen::CHEN,
        /// Channel enable set register
        pub chenset: chenset::CHENSET,
        /// Channel enable clear register
        pub chenclr: chenclr::CHENCLR,
        _padding_1292: [u8; 4],
        /// PPI Channel
        pub ch: [ch::CH; 20],
        _padding_1456: [u8; 592],
        /// Description collection: Channel group n
        pub chg: [chg::CHG; 6],
        _padding_2072: [u8; 248],
        /// Fork
        pub fork: [fork::FORK; 32],
    }

    pub mod tasks_chg {
        #[allow(unused_imports)]
        use super::*;

        /// Channel group tasks
        #[repr(C)]
        pub struct TASKS_CHG {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Enable channel group n
            pub en: TaskRegister,
            /// Description cluster: Disable channel group n
            pub dis: TaskRegister,
        }
    }

    pub mod chen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CHEN {
            raw: RawRegister<u32>,
        }

        impl CHEN {
            pub fn write_with<F: Fn(&mut CHEN_VALUE) -> &mut CHEN_VALUE>(&mut self, f: F) {
                let mut v = CHEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CHEN {
            type Value = CHEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CHEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CHEN {
            type Value = CHEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHEN_VALUE {
            raw: u32,
        }

        impl CHEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ch0(&self) -> CH0_FIELD {
                let raw = self.raw;
                CH0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ch0(&mut self, value: CH0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch0_with<F: Fn(&mut CH0_FIELD) -> &mut CH0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0();
                f(&mut value);
                self.set_ch0(value)
            }

            pub fn ch1(&self) -> CH1_FIELD {
                let raw = self.raw;
                CH1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ch1(&mut self, value: CH1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch1_with<F: Fn(&mut CH1_FIELD) -> &mut CH1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1();
                f(&mut value);
                self.set_ch1(value)
            }

            pub fn ch2(&self) -> CH2_FIELD {
                let raw = self.raw;
                CH2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ch2(&mut self, value: CH2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch2_with<F: Fn(&mut CH2_FIELD) -> &mut CH2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2();
                f(&mut value);
                self.set_ch2(value)
            }

            pub fn ch3(&self) -> CH3_FIELD {
                let raw = self.raw;
                CH3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ch3(&mut self, value: CH3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch3_with<F: Fn(&mut CH3_FIELD) -> &mut CH3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3();
                f(&mut value);
                self.set_ch3(value)
            }

            pub fn ch4(&self) -> CH4_FIELD {
                let raw = self.raw;
                CH4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ch4(&mut self, value: CH4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch4_with<F: Fn(&mut CH4_FIELD) -> &mut CH4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4();
                f(&mut value);
                self.set_ch4(value)
            }

            pub fn ch5(&self) -> CH5_FIELD {
                let raw = self.raw;
                CH5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_ch5(&mut self, value: CH5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch5_with<F: Fn(&mut CH5_FIELD) -> &mut CH5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5();
                f(&mut value);
                self.set_ch5(value)
            }

            pub fn ch6(&self) -> CH6_FIELD {
                let raw = self.raw;
                CH6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch6(&mut self, value: CH6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch6_with<F: Fn(&mut CH6_FIELD) -> &mut CH6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6();
                f(&mut value);
                self.set_ch6(value)
            }

            pub fn ch7(&self) -> CH7_FIELD {
                let raw = self.raw;
                CH7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch7(&mut self, value: CH7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch7_with<F: Fn(&mut CH7_FIELD) -> &mut CH7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7();
                f(&mut value);
                self.set_ch7(value)
            }

            pub fn ch8(&self) -> CH8_FIELD {
                let raw = self.raw;
                CH8_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch8(&mut self, value: CH8_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch8_with<F: Fn(&mut CH8_FIELD) -> &mut CH8_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch8();
                f(&mut value);
                self.set_ch8(value)
            }

            pub fn ch9(&self) -> CH9_FIELD {
                let raw = self.raw;
                CH9_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch9(&mut self, value: CH9_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch9_with<F: Fn(&mut CH9_FIELD) -> &mut CH9_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch9();
                f(&mut value);
                self.set_ch9(value)
            }

            pub fn ch10(&self) -> CH10_FIELD {
                let raw = self.raw;
                CH10_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch10(&mut self, value: CH10_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch10_with<F: Fn(&mut CH10_FIELD) -> &mut CH10_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch10();
                f(&mut value);
                self.set_ch10(value)
            }

            pub fn ch11(&self) -> CH11_FIELD {
                let raw = self.raw;
                CH11_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch11(&mut self, value: CH11_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch11_with<F: Fn(&mut CH11_FIELD) -> &mut CH11_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch11();
                f(&mut value);
                self.set_ch11(value)
            }

            pub fn ch12(&self) -> CH12_FIELD {
                let raw = self.raw;
                CH12_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch12(&mut self, value: CH12_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch12_with<F: Fn(&mut CH12_FIELD) -> &mut CH12_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch12();
                f(&mut value);
                self.set_ch12(value)
            }

            pub fn ch13(&self) -> CH13_FIELD {
                let raw = self.raw;
                CH13_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch13(&mut self, value: CH13_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch13_with<F: Fn(&mut CH13_FIELD) -> &mut CH13_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch13();
                f(&mut value);
                self.set_ch13(value)
            }

            pub fn ch14(&self) -> CH14_FIELD {
                let raw = self.raw;
                CH14_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch14(&mut self, value: CH14_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch14_with<F: Fn(&mut CH14_FIELD) -> &mut CH14_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch14();
                f(&mut value);
                self.set_ch14(value)
            }

            pub fn ch15(&self) -> CH15_FIELD {
                let raw = self.raw;
                CH15_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch15(&mut self, value: CH15_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch15_with<F: Fn(&mut CH15_FIELD) -> &mut CH15_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch15();
                f(&mut value);
                self.set_ch15(value)
            }

            pub fn ch16(&self) -> CH16_FIELD {
                let raw = self.raw;
                CH16_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch16(&mut self, value: CH16_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch16_with<F: Fn(&mut CH16_FIELD) -> &mut CH16_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch16();
                f(&mut value);
                self.set_ch16(value)
            }

            pub fn ch17(&self) -> CH17_FIELD {
                let raw = self.raw;
                CH17_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch17(&mut self, value: CH17_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch17_with<F: Fn(&mut CH17_FIELD) -> &mut CH17_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch17();
                f(&mut value);
                self.set_ch17(value)
            }

            pub fn ch18(&self) -> CH18_FIELD {
                let raw = self.raw;
                CH18_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch18(&mut self, value: CH18_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch18_with<F: Fn(&mut CH18_FIELD) -> &mut CH18_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch18();
                f(&mut value);
                self.set_ch18(value)
            }

            pub fn ch19(&self) -> CH19_FIELD {
                let raw = self.raw;
                CH19_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch19(&mut self, value: CH19_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch19_with<F: Fn(&mut CH19_FIELD) -> &mut CH19_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch19();
                f(&mut value);
                self.set_ch19(value)
            }

            pub fn ch20(&self) -> CH20_FIELD {
                let raw = self.raw;
                CH20_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch20(&mut self, value: CH20_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch20_with<F: Fn(&mut CH20_FIELD) -> &mut CH20_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch20();
                f(&mut value);
                self.set_ch20(value)
            }

            pub fn ch21(&self) -> CH21_FIELD {
                let raw = self.raw;
                CH21_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch21(&mut self, value: CH21_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch21_with<F: Fn(&mut CH21_FIELD) -> &mut CH21_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch21();
                f(&mut value);
                self.set_ch21(value)
            }

            pub fn ch22(&self) -> CH22_FIELD {
                let raw = self.raw;
                CH22_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_ch22(&mut self, value: CH22_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch22_with<F: Fn(&mut CH22_FIELD) -> &mut CH22_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch22();
                f(&mut value);
                self.set_ch22(value)
            }

            pub fn ch23(&self) -> CH23_FIELD {
                let raw = self.raw;
                CH23_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ch23(&mut self, value: CH23_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch23_with<F: Fn(&mut CH23_FIELD) -> &mut CH23_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch23();
                f(&mut value);
                self.set_ch23(value)
            }

            pub fn ch24(&self) -> CH24_FIELD {
                let raw = self.raw;
                CH24_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_ch24(&mut self, value: CH24_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch24_with<F: Fn(&mut CH24_FIELD) -> &mut CH24_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch24();
                f(&mut value);
                self.set_ch24(value)
            }

            pub fn ch25(&self) -> CH25_FIELD {
                let raw = self.raw;
                CH25_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_ch25(&mut self, value: CH25_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch25_with<F: Fn(&mut CH25_FIELD) -> &mut CH25_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch25();
                f(&mut value);
                self.set_ch25(value)
            }

            pub fn ch26(&self) -> CH26_FIELD {
                let raw = self.raw;
                CH26_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_ch26(&mut self, value: CH26_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch26_with<F: Fn(&mut CH26_FIELD) -> &mut CH26_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch26();
                f(&mut value);
                self.set_ch26(value)
            }

            pub fn ch27(&self) -> CH27_FIELD {
                let raw = self.raw;
                CH27_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_ch27(&mut self, value: CH27_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch27_with<F: Fn(&mut CH27_FIELD) -> &mut CH27_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch27();
                f(&mut value);
                self.set_ch27(value)
            }

            pub fn ch28(&self) -> CH28_FIELD {
                let raw = self.raw;
                CH28_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ch28(&mut self, value: CH28_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch28_with<F: Fn(&mut CH28_FIELD) -> &mut CH28_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch28();
                f(&mut value);
                self.set_ch28(value)
            }

            pub fn ch29(&self) -> CH29_FIELD {
                let raw = self.raw;
                CH29_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_ch29(&mut self, value: CH29_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch29_with<F: Fn(&mut CH29_FIELD) -> &mut CH29_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch29();
                f(&mut value);
                self.set_ch29(value)
            }

            pub fn ch30(&self) -> CH30_FIELD {
                let raw = self.raw;
                CH30_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_ch30(&mut self, value: CH30_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch30_with<F: Fn(&mut CH30_FIELD) -> &mut CH30_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch30();
                f(&mut value);
                self.set_ch30(value)
            }

            pub fn ch31(&self) -> CH31_FIELD {
                let raw = self.raw;
                CH31_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_ch31(&mut self, value: CH31_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_ch31_with<F: Fn(&mut CH31_FIELD) -> &mut CH31_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch31();
                f(&mut value);
                self.set_ch31(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH1_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH2_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH3_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH4_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH5_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH6_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH7_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH8_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH9_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH10_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH11_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH12_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH13_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH14_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH15_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH16_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH17_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH18_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH19_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH20_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH21_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH22_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH23_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH24_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH25_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH26_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH27_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH28_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH29_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH30_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_FIELD u32 =>
                        // Disable channel
                        Disabled = 0,
        // Enable channel
                        Enabled = 1

                    );

        impl CH31_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod chenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CHENSET {
            raw: RawRegister<u32>,
        }

        impl CHENSET {
            pub fn write_with<F: Fn(&mut CHENSET_WRITE_VALUE) -> &mut CHENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = CHENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CHENSET {
            type Value = CHENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CHENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CHENSET {
            type Value = CHENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHENSET_READ_VALUE {
            raw: u32,
        }

        impl CHENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ch0(&self) -> CH0_READ_FIELD {
                let raw = self.raw;
                CH0_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ch0(&mut self, value: CH0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch0_with<F: Fn(&mut CH0_READ_FIELD) -> &mut CH0_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0();
                f(&mut value);
                self.set_ch0(value)
            }

            pub fn ch1(&self) -> CH1_READ_FIELD {
                let raw = self.raw;
                CH1_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ch1(&mut self, value: CH1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch1_with<F: Fn(&mut CH1_READ_FIELD) -> &mut CH1_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1();
                f(&mut value);
                self.set_ch1(value)
            }

            pub fn ch2(&self) -> CH2_READ_FIELD {
                let raw = self.raw;
                CH2_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ch2(&mut self, value: CH2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch2_with<F: Fn(&mut CH2_READ_FIELD) -> &mut CH2_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2();
                f(&mut value);
                self.set_ch2(value)
            }

            pub fn ch3(&self) -> CH3_READ_FIELD {
                let raw = self.raw;
                CH3_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ch3(&mut self, value: CH3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch3_with<F: Fn(&mut CH3_READ_FIELD) -> &mut CH3_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3();
                f(&mut value);
                self.set_ch3(value)
            }

            pub fn ch4(&self) -> CH4_READ_FIELD {
                let raw = self.raw;
                CH4_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ch4(&mut self, value: CH4_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch4_with<F: Fn(&mut CH4_READ_FIELD) -> &mut CH4_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4();
                f(&mut value);
                self.set_ch4(value)
            }

            pub fn ch5(&self) -> CH5_READ_FIELD {
                let raw = self.raw;
                CH5_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_ch5(&mut self, value: CH5_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch5_with<F: Fn(&mut CH5_READ_FIELD) -> &mut CH5_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5();
                f(&mut value);
                self.set_ch5(value)
            }

            pub fn ch6(&self) -> CH6_READ_FIELD {
                let raw = self.raw;
                CH6_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch6(&mut self, value: CH6_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch6_with<F: Fn(&mut CH6_READ_FIELD) -> &mut CH6_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6();
                f(&mut value);
                self.set_ch6(value)
            }

            pub fn ch7(&self) -> CH7_READ_FIELD {
                let raw = self.raw;
                CH7_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch7(&mut self, value: CH7_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch7_with<F: Fn(&mut CH7_READ_FIELD) -> &mut CH7_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7();
                f(&mut value);
                self.set_ch7(value)
            }

            pub fn ch8(&self) -> CH8_READ_FIELD {
                let raw = self.raw;
                CH8_READ_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch8(&mut self, value: CH8_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch8_with<F: Fn(&mut CH8_READ_FIELD) -> &mut CH8_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch8();
                f(&mut value);
                self.set_ch8(value)
            }

            pub fn ch9(&self) -> CH9_READ_FIELD {
                let raw = self.raw;
                CH9_READ_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch9(&mut self, value: CH9_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch9_with<F: Fn(&mut CH9_READ_FIELD) -> &mut CH9_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch9();
                f(&mut value);
                self.set_ch9(value)
            }

            pub fn ch10(&self) -> CH10_READ_FIELD {
                let raw = self.raw;
                CH10_READ_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch10(&mut self, value: CH10_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch10_with<F: Fn(&mut CH10_READ_FIELD) -> &mut CH10_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch10();
                f(&mut value);
                self.set_ch10(value)
            }

            pub fn ch11(&self) -> CH11_READ_FIELD {
                let raw = self.raw;
                CH11_READ_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch11(&mut self, value: CH11_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch11_with<F: Fn(&mut CH11_READ_FIELD) -> &mut CH11_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch11();
                f(&mut value);
                self.set_ch11(value)
            }

            pub fn ch12(&self) -> CH12_READ_FIELD {
                let raw = self.raw;
                CH12_READ_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch12(&mut self, value: CH12_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch12_with<F: Fn(&mut CH12_READ_FIELD) -> &mut CH12_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch12();
                f(&mut value);
                self.set_ch12(value)
            }

            pub fn ch13(&self) -> CH13_READ_FIELD {
                let raw = self.raw;
                CH13_READ_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch13(&mut self, value: CH13_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch13_with<F: Fn(&mut CH13_READ_FIELD) -> &mut CH13_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch13();
                f(&mut value);
                self.set_ch13(value)
            }

            pub fn ch14(&self) -> CH14_READ_FIELD {
                let raw = self.raw;
                CH14_READ_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch14(&mut self, value: CH14_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch14_with<F: Fn(&mut CH14_READ_FIELD) -> &mut CH14_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch14();
                f(&mut value);
                self.set_ch14(value)
            }

            pub fn ch15(&self) -> CH15_READ_FIELD {
                let raw = self.raw;
                CH15_READ_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch15(&mut self, value: CH15_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch15_with<F: Fn(&mut CH15_READ_FIELD) -> &mut CH15_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch15();
                f(&mut value);
                self.set_ch15(value)
            }

            pub fn ch16(&self) -> CH16_READ_FIELD {
                let raw = self.raw;
                CH16_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch16(&mut self, value: CH16_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch16_with<F: Fn(&mut CH16_READ_FIELD) -> &mut CH16_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch16();
                f(&mut value);
                self.set_ch16(value)
            }

            pub fn ch17(&self) -> CH17_READ_FIELD {
                let raw = self.raw;
                CH17_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch17(&mut self, value: CH17_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch17_with<F: Fn(&mut CH17_READ_FIELD) -> &mut CH17_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch17();
                f(&mut value);
                self.set_ch17(value)
            }

            pub fn ch18(&self) -> CH18_READ_FIELD {
                let raw = self.raw;
                CH18_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch18(&mut self, value: CH18_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch18_with<F: Fn(&mut CH18_READ_FIELD) -> &mut CH18_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch18();
                f(&mut value);
                self.set_ch18(value)
            }

            pub fn ch19(&self) -> CH19_READ_FIELD {
                let raw = self.raw;
                CH19_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch19(&mut self, value: CH19_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch19_with<F: Fn(&mut CH19_READ_FIELD) -> &mut CH19_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch19();
                f(&mut value);
                self.set_ch19(value)
            }

            pub fn ch20(&self) -> CH20_READ_FIELD {
                let raw = self.raw;
                CH20_READ_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch20(&mut self, value: CH20_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch20_with<F: Fn(&mut CH20_READ_FIELD) -> &mut CH20_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch20();
                f(&mut value);
                self.set_ch20(value)
            }

            pub fn ch21(&self) -> CH21_READ_FIELD {
                let raw = self.raw;
                CH21_READ_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch21(&mut self, value: CH21_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch21_with<F: Fn(&mut CH21_READ_FIELD) -> &mut CH21_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch21();
                f(&mut value);
                self.set_ch21(value)
            }

            pub fn ch22(&self) -> CH22_READ_FIELD {
                let raw = self.raw;
                CH22_READ_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_ch22(&mut self, value: CH22_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch22_with<F: Fn(&mut CH22_READ_FIELD) -> &mut CH22_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch22();
                f(&mut value);
                self.set_ch22(value)
            }

            pub fn ch23(&self) -> CH23_READ_FIELD {
                let raw = self.raw;
                CH23_READ_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ch23(&mut self, value: CH23_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch23_with<F: Fn(&mut CH23_READ_FIELD) -> &mut CH23_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch23();
                f(&mut value);
                self.set_ch23(value)
            }

            pub fn ch24(&self) -> CH24_READ_FIELD {
                let raw = self.raw;
                CH24_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_ch24(&mut self, value: CH24_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch24_with<F: Fn(&mut CH24_READ_FIELD) -> &mut CH24_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch24();
                f(&mut value);
                self.set_ch24(value)
            }

            pub fn ch25(&self) -> CH25_READ_FIELD {
                let raw = self.raw;
                CH25_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_ch25(&mut self, value: CH25_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch25_with<F: Fn(&mut CH25_READ_FIELD) -> &mut CH25_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch25();
                f(&mut value);
                self.set_ch25(value)
            }

            pub fn ch26(&self) -> CH26_READ_FIELD {
                let raw = self.raw;
                CH26_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_ch26(&mut self, value: CH26_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch26_with<F: Fn(&mut CH26_READ_FIELD) -> &mut CH26_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch26();
                f(&mut value);
                self.set_ch26(value)
            }

            pub fn ch27(&self) -> CH27_READ_FIELD {
                let raw = self.raw;
                CH27_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_ch27(&mut self, value: CH27_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch27_with<F: Fn(&mut CH27_READ_FIELD) -> &mut CH27_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch27();
                f(&mut value);
                self.set_ch27(value)
            }

            pub fn ch28(&self) -> CH28_READ_FIELD {
                let raw = self.raw;
                CH28_READ_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ch28(&mut self, value: CH28_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch28_with<F: Fn(&mut CH28_READ_FIELD) -> &mut CH28_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch28();
                f(&mut value);
                self.set_ch28(value)
            }

            pub fn ch29(&self) -> CH29_READ_FIELD {
                let raw = self.raw;
                CH29_READ_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_ch29(&mut self, value: CH29_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch29_with<F: Fn(&mut CH29_READ_FIELD) -> &mut CH29_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch29();
                f(&mut value);
                self.set_ch29(value)
            }

            pub fn ch30(&self) -> CH30_READ_FIELD {
                let raw = self.raw;
                CH30_READ_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_ch30(&mut self, value: CH30_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch30_with<F: Fn(&mut CH30_READ_FIELD) -> &mut CH30_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch30();
                f(&mut value);
                self.set_ch30(value)
            }

            pub fn ch31(&self) -> CH31_READ_FIELD {
                let raw = self.raw;
                CH31_READ_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_ch31(&mut self, value: CH31_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_ch31_with<F: Fn(&mut CH31_READ_FIELD) -> &mut CH31_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch31();
                f(&mut value);
                self.set_ch31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHENSET_WRITE_VALUE {
            raw: u32,
        }

        impl CHENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ch0(&mut self) -> &mut Self {
                let value = CH0_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch1(&mut self) -> &mut Self {
                let value = CH1_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch2(&mut self) -> &mut Self {
                let value = CH2_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch3(&mut self) -> &mut Self {
                let value = CH3_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch4(&mut self) -> &mut Self {
                let value = CH4_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch5(&mut self) -> &mut Self {
                let value = CH5_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch6(&mut self) -> &mut Self {
                let value = CH6_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch7(&mut self) -> &mut Self {
                let value = CH7_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch8(&mut self) -> &mut Self {
                let value = CH8_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch9(&mut self) -> &mut Self {
                let value = CH9_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch10(&mut self) -> &mut Self {
                let value = CH10_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch11(&mut self) -> &mut Self {
                let value = CH11_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch12(&mut self) -> &mut Self {
                let value = CH12_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch13(&mut self) -> &mut Self {
                let value = CH13_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch14(&mut self) -> &mut Self {
                let value = CH14_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch15(&mut self) -> &mut Self {
                let value = CH15_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch16(&mut self) -> &mut Self {
                let value = CH16_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch17(&mut self) -> &mut Self {
                let value = CH17_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch18(&mut self) -> &mut Self {
                let value = CH18_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch19(&mut self) -> &mut Self {
                let value = CH19_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch20(&mut self) -> &mut Self {
                let value = CH20_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch21(&mut self) -> &mut Self {
                let value = CH21_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch22(&mut self) -> &mut Self {
                let value = CH22_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch23(&mut self) -> &mut Self {
                let value = CH23_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch24(&mut self) -> &mut Self {
                let value = CH24_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch25(&mut self) -> &mut Self {
                let value = CH25_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch26(&mut self) -> &mut Self {
                let value = CH26_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch27(&mut self) -> &mut Self {
                let value = CH27_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch28(&mut self) -> &mut Self {
                let value = CH28_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch29(&mut self) -> &mut Self {
                let value = CH29_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch30(&mut self) -> &mut Self {
                let value = CH30_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch31(&mut self) -> &mut Self {
                let value = CH31_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH0_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH0_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH1_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH1_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH2_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH2_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH3_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH3_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH4_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH4_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH5_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH5_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH6_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH6_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH7_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH7_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH8_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH8_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH9_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH9_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH10_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH10_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH11_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH11_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH12_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH12_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH13_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH13_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH14_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH14_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH15_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH15_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH16_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH16_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH17_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH17_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH18_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH18_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH19_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH19_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH20_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH20_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH21_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH21_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH22_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH22_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH23_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH23_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH24_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH24_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH25_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH25_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH26_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH26_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH27_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH27_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH28_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH28_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH29_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH29_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH30_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH30_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH31_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_WRITE_FIELD u32 =>
            // Write: Enable channel
            Set = 1

        );

        impl CH31_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod chenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CHENCLR {
            raw: RawRegister<u32>,
        }

        impl CHENCLR {
            pub fn write_with<F: Fn(&mut CHENCLR_WRITE_VALUE) -> &mut CHENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = CHENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CHENCLR {
            type Value = CHENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CHENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CHENCLR {
            type Value = CHENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHENCLR_READ_VALUE {
            raw: u32,
        }

        impl CHENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ch0(&self) -> CH0_READ_FIELD {
                let raw = self.raw;
                CH0_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ch0(&mut self, value: CH0_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch0_with<F: Fn(&mut CH0_READ_FIELD) -> &mut CH0_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0();
                f(&mut value);
                self.set_ch0(value)
            }

            pub fn ch1(&self) -> CH1_READ_FIELD {
                let raw = self.raw;
                CH1_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ch1(&mut self, value: CH1_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch1_with<F: Fn(&mut CH1_READ_FIELD) -> &mut CH1_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1();
                f(&mut value);
                self.set_ch1(value)
            }

            pub fn ch2(&self) -> CH2_READ_FIELD {
                let raw = self.raw;
                CH2_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ch2(&mut self, value: CH2_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch2_with<F: Fn(&mut CH2_READ_FIELD) -> &mut CH2_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2();
                f(&mut value);
                self.set_ch2(value)
            }

            pub fn ch3(&self) -> CH3_READ_FIELD {
                let raw = self.raw;
                CH3_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ch3(&mut self, value: CH3_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch3_with<F: Fn(&mut CH3_READ_FIELD) -> &mut CH3_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3();
                f(&mut value);
                self.set_ch3(value)
            }

            pub fn ch4(&self) -> CH4_READ_FIELD {
                let raw = self.raw;
                CH4_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ch4(&mut self, value: CH4_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch4_with<F: Fn(&mut CH4_READ_FIELD) -> &mut CH4_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4();
                f(&mut value);
                self.set_ch4(value)
            }

            pub fn ch5(&self) -> CH5_READ_FIELD {
                let raw = self.raw;
                CH5_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_ch5(&mut self, value: CH5_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch5_with<F: Fn(&mut CH5_READ_FIELD) -> &mut CH5_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5();
                f(&mut value);
                self.set_ch5(value)
            }

            pub fn ch6(&self) -> CH6_READ_FIELD {
                let raw = self.raw;
                CH6_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch6(&mut self, value: CH6_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch6_with<F: Fn(&mut CH6_READ_FIELD) -> &mut CH6_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6();
                f(&mut value);
                self.set_ch6(value)
            }

            pub fn ch7(&self) -> CH7_READ_FIELD {
                let raw = self.raw;
                CH7_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch7(&mut self, value: CH7_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch7_with<F: Fn(&mut CH7_READ_FIELD) -> &mut CH7_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7();
                f(&mut value);
                self.set_ch7(value)
            }

            pub fn ch8(&self) -> CH8_READ_FIELD {
                let raw = self.raw;
                CH8_READ_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch8(&mut self, value: CH8_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch8_with<F: Fn(&mut CH8_READ_FIELD) -> &mut CH8_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch8();
                f(&mut value);
                self.set_ch8(value)
            }

            pub fn ch9(&self) -> CH9_READ_FIELD {
                let raw = self.raw;
                CH9_READ_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch9(&mut self, value: CH9_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch9_with<F: Fn(&mut CH9_READ_FIELD) -> &mut CH9_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch9();
                f(&mut value);
                self.set_ch9(value)
            }

            pub fn ch10(&self) -> CH10_READ_FIELD {
                let raw = self.raw;
                CH10_READ_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch10(&mut self, value: CH10_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch10_with<F: Fn(&mut CH10_READ_FIELD) -> &mut CH10_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch10();
                f(&mut value);
                self.set_ch10(value)
            }

            pub fn ch11(&self) -> CH11_READ_FIELD {
                let raw = self.raw;
                CH11_READ_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch11(&mut self, value: CH11_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch11_with<F: Fn(&mut CH11_READ_FIELD) -> &mut CH11_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch11();
                f(&mut value);
                self.set_ch11(value)
            }

            pub fn ch12(&self) -> CH12_READ_FIELD {
                let raw = self.raw;
                CH12_READ_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch12(&mut self, value: CH12_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch12_with<F: Fn(&mut CH12_READ_FIELD) -> &mut CH12_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch12();
                f(&mut value);
                self.set_ch12(value)
            }

            pub fn ch13(&self) -> CH13_READ_FIELD {
                let raw = self.raw;
                CH13_READ_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch13(&mut self, value: CH13_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch13_with<F: Fn(&mut CH13_READ_FIELD) -> &mut CH13_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch13();
                f(&mut value);
                self.set_ch13(value)
            }

            pub fn ch14(&self) -> CH14_READ_FIELD {
                let raw = self.raw;
                CH14_READ_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch14(&mut self, value: CH14_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch14_with<F: Fn(&mut CH14_READ_FIELD) -> &mut CH14_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch14();
                f(&mut value);
                self.set_ch14(value)
            }

            pub fn ch15(&self) -> CH15_READ_FIELD {
                let raw = self.raw;
                CH15_READ_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch15(&mut self, value: CH15_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch15_with<F: Fn(&mut CH15_READ_FIELD) -> &mut CH15_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch15();
                f(&mut value);
                self.set_ch15(value)
            }

            pub fn ch16(&self) -> CH16_READ_FIELD {
                let raw = self.raw;
                CH16_READ_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch16(&mut self, value: CH16_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch16_with<F: Fn(&mut CH16_READ_FIELD) -> &mut CH16_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch16();
                f(&mut value);
                self.set_ch16(value)
            }

            pub fn ch17(&self) -> CH17_READ_FIELD {
                let raw = self.raw;
                CH17_READ_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch17(&mut self, value: CH17_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch17_with<F: Fn(&mut CH17_READ_FIELD) -> &mut CH17_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch17();
                f(&mut value);
                self.set_ch17(value)
            }

            pub fn ch18(&self) -> CH18_READ_FIELD {
                let raw = self.raw;
                CH18_READ_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch18(&mut self, value: CH18_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch18_with<F: Fn(&mut CH18_READ_FIELD) -> &mut CH18_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch18();
                f(&mut value);
                self.set_ch18(value)
            }

            pub fn ch19(&self) -> CH19_READ_FIELD {
                let raw = self.raw;
                CH19_READ_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch19(&mut self, value: CH19_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch19_with<F: Fn(&mut CH19_READ_FIELD) -> &mut CH19_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch19();
                f(&mut value);
                self.set_ch19(value)
            }

            pub fn ch20(&self) -> CH20_READ_FIELD {
                let raw = self.raw;
                CH20_READ_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch20(&mut self, value: CH20_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch20_with<F: Fn(&mut CH20_READ_FIELD) -> &mut CH20_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch20();
                f(&mut value);
                self.set_ch20(value)
            }

            pub fn ch21(&self) -> CH21_READ_FIELD {
                let raw = self.raw;
                CH21_READ_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch21(&mut self, value: CH21_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch21_with<F: Fn(&mut CH21_READ_FIELD) -> &mut CH21_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch21();
                f(&mut value);
                self.set_ch21(value)
            }

            pub fn ch22(&self) -> CH22_READ_FIELD {
                let raw = self.raw;
                CH22_READ_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_ch22(&mut self, value: CH22_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch22_with<F: Fn(&mut CH22_READ_FIELD) -> &mut CH22_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch22();
                f(&mut value);
                self.set_ch22(value)
            }

            pub fn ch23(&self) -> CH23_READ_FIELD {
                let raw = self.raw;
                CH23_READ_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ch23(&mut self, value: CH23_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch23_with<F: Fn(&mut CH23_READ_FIELD) -> &mut CH23_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch23();
                f(&mut value);
                self.set_ch23(value)
            }

            pub fn ch24(&self) -> CH24_READ_FIELD {
                let raw = self.raw;
                CH24_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_ch24(&mut self, value: CH24_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch24_with<F: Fn(&mut CH24_READ_FIELD) -> &mut CH24_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch24();
                f(&mut value);
                self.set_ch24(value)
            }

            pub fn ch25(&self) -> CH25_READ_FIELD {
                let raw = self.raw;
                CH25_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_ch25(&mut self, value: CH25_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch25_with<F: Fn(&mut CH25_READ_FIELD) -> &mut CH25_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch25();
                f(&mut value);
                self.set_ch25(value)
            }

            pub fn ch26(&self) -> CH26_READ_FIELD {
                let raw = self.raw;
                CH26_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_ch26(&mut self, value: CH26_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch26_with<F: Fn(&mut CH26_READ_FIELD) -> &mut CH26_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch26();
                f(&mut value);
                self.set_ch26(value)
            }

            pub fn ch27(&self) -> CH27_READ_FIELD {
                let raw = self.raw;
                CH27_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_ch27(&mut self, value: CH27_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch27_with<F: Fn(&mut CH27_READ_FIELD) -> &mut CH27_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch27();
                f(&mut value);
                self.set_ch27(value)
            }

            pub fn ch28(&self) -> CH28_READ_FIELD {
                let raw = self.raw;
                CH28_READ_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ch28(&mut self, value: CH28_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch28_with<F: Fn(&mut CH28_READ_FIELD) -> &mut CH28_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch28();
                f(&mut value);
                self.set_ch28(value)
            }

            pub fn ch29(&self) -> CH29_READ_FIELD {
                let raw = self.raw;
                CH29_READ_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_ch29(&mut self, value: CH29_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch29_with<F: Fn(&mut CH29_READ_FIELD) -> &mut CH29_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch29();
                f(&mut value);
                self.set_ch29(value)
            }

            pub fn ch30(&self) -> CH30_READ_FIELD {
                let raw = self.raw;
                CH30_READ_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_ch30(&mut self, value: CH30_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch30_with<F: Fn(&mut CH30_READ_FIELD) -> &mut CH30_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch30();
                f(&mut value);
                self.set_ch30(value)
            }

            pub fn ch31(&self) -> CH31_READ_FIELD {
                let raw = self.raw;
                CH31_READ_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_ch31(&mut self, value: CH31_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_ch31_with<F: Fn(&mut CH31_READ_FIELD) -> &mut CH31_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch31();
                f(&mut value);
                self.set_ch31(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl CHENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ch0(&mut self) -> &mut Self {
                let value = CH0_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch1(&mut self) -> &mut Self {
                let value = CH1_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch2(&mut self) -> &mut Self {
                let value = CH2_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch3(&mut self) -> &mut Self {
                let value = CH3_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch4(&mut self) -> &mut Self {
                let value = CH4_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch5(&mut self) -> &mut Self {
                let value = CH5_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch6(&mut self) -> &mut Self {
                let value = CH6_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch7(&mut self) -> &mut Self {
                let value = CH7_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch8(&mut self) -> &mut Self {
                let value = CH8_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch9(&mut self) -> &mut Self {
                let value = CH9_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch10(&mut self) -> &mut Self {
                let value = CH10_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch11(&mut self) -> &mut Self {
                let value = CH11_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch12(&mut self) -> &mut Self {
                let value = CH12_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch13(&mut self) -> &mut Self {
                let value = CH13_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch14(&mut self) -> &mut Self {
                let value = CH14_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch15(&mut self) -> &mut Self {
                let value = CH15_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch16(&mut self) -> &mut Self {
                let value = CH16_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch17(&mut self) -> &mut Self {
                let value = CH17_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch18(&mut self) -> &mut Self {
                let value = CH18_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch19(&mut self) -> &mut Self {
                let value = CH19_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch20(&mut self) -> &mut Self {
                let value = CH20_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch21(&mut self) -> &mut Self {
                let value = CH21_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch22(&mut self) -> &mut Self {
                let value = CH22_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch23(&mut self) -> &mut Self {
                let value = CH23_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch24(&mut self) -> &mut Self {
                let value = CH24_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch25(&mut self) -> &mut Self {
                let value = CH25_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch26(&mut self) -> &mut Self {
                let value = CH26_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch27(&mut self) -> &mut Self {
                let value = CH27_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch28(&mut self) -> &mut Self {
                let value = CH28_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch29(&mut self) -> &mut Self {
                let value = CH29_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch30(&mut self) -> &mut Self {
                let value = CH30_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch31(&mut self) -> &mut Self {
                let value = CH31_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH0_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH0_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH1_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH1_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH2_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH2_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH3_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH3_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH4_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH4_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH5_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH5_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH6_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH6_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH7_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH7_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH8_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH8_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH9_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH9_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH10_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH10_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH11_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH11_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH12_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH12_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH13_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH13_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH14_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH14_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH15_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH15_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH16_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH16_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH17_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH17_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH18_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH18_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH19_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH19_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH20_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH20_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH21_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH21_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH22_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH22_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH23_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH23_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH24_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH24_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH25_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH25_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH26_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH26_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH27_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH27_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH28_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH28_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH29_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH29_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH30_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH30_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_READ_FIELD u32 =>
                        // Read: channel disabled
                        Disabled = 0,
        // Read: channel enabled
                        Enabled = 1

                    );

        impl CH31_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_WRITE_FIELD u32 =>
            // Write: disable channel
            Clear = 1

        );

        impl CH31_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod ch {
        #[allow(unused_imports)]
        use super::*;

        /// PPI Channel
        #[repr(C)]
        pub struct CH {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Channel n event endpoint
            pub eep: eep::EEP,
            /// Description cluster: Channel n task endpoint
            pub tep: tep::TEP,
        }

        pub mod eep {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct EEP {
                raw: RawRegister<u32>,
            }

            impl EEP {}

            impl RegisterRead for EEP {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for EEP {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod tep {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TEP {
                raw: RawRegister<u32>,
            }

            impl TEP {}

            impl RegisterRead for TEP {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for TEP {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod chg {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct CHG {
            raw: RawRegister<u32>,
        }

        impl CHG {
            pub fn write_with<F: Fn(&mut CHG_VALUE) -> &mut CHG_VALUE>(&mut self, f: F) {
                let mut v = CHG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for CHG {
            type Value = CHG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                CHG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for CHG {
            type Value = CHG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct CHG_VALUE {
            raw: u32,
        }

        impl CHG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ch0(&self) -> CH0_FIELD {
                let raw = self.raw;
                CH0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ch0(&mut self, value: CH0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ch0_with<F: Fn(&mut CH0_FIELD) -> &mut CH0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch0();
                f(&mut value);
                self.set_ch0(value)
            }

            pub fn ch1(&self) -> CH1_FIELD {
                let raw = self.raw;
                CH1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ch1(&mut self, value: CH1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ch1_with<F: Fn(&mut CH1_FIELD) -> &mut CH1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch1();
                f(&mut value);
                self.set_ch1(value)
            }

            pub fn ch2(&self) -> CH2_FIELD {
                let raw = self.raw;
                CH2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ch2(&mut self, value: CH2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ch2_with<F: Fn(&mut CH2_FIELD) -> &mut CH2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch2();
                f(&mut value);
                self.set_ch2(value)
            }

            pub fn ch3(&self) -> CH3_FIELD {
                let raw = self.raw;
                CH3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_ch3(&mut self, value: CH3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_ch3_with<F: Fn(&mut CH3_FIELD) -> &mut CH3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch3();
                f(&mut value);
                self.set_ch3(value)
            }

            pub fn ch4(&self) -> CH4_FIELD {
                let raw = self.raw;
                CH4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_ch4(&mut self, value: CH4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_ch4_with<F: Fn(&mut CH4_FIELD) -> &mut CH4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch4();
                f(&mut value);
                self.set_ch4(value)
            }

            pub fn ch5(&self) -> CH5_FIELD {
                let raw = self.raw;
                CH5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_ch5(&mut self, value: CH5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_ch5_with<F: Fn(&mut CH5_FIELD) -> &mut CH5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch5();
                f(&mut value);
                self.set_ch5(value)
            }

            pub fn ch6(&self) -> CH6_FIELD {
                let raw = self.raw;
                CH6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_ch6(&mut self, value: CH6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_ch6_with<F: Fn(&mut CH6_FIELD) -> &mut CH6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch6();
                f(&mut value);
                self.set_ch6(value)
            }

            pub fn ch7(&self) -> CH7_FIELD {
                let raw = self.raw;
                CH7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_ch7(&mut self, value: CH7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_ch7_with<F: Fn(&mut CH7_FIELD) -> &mut CH7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch7();
                f(&mut value);
                self.set_ch7(value)
            }

            pub fn ch8(&self) -> CH8_FIELD {
                let raw = self.raw;
                CH8_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_ch8(&mut self, value: CH8_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_ch8_with<F: Fn(&mut CH8_FIELD) -> &mut CH8_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch8();
                f(&mut value);
                self.set_ch8(value)
            }

            pub fn ch9(&self) -> CH9_FIELD {
                let raw = self.raw;
                CH9_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_ch9(&mut self, value: CH9_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ch9_with<F: Fn(&mut CH9_FIELD) -> &mut CH9_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch9();
                f(&mut value);
                self.set_ch9(value)
            }

            pub fn ch10(&self) -> CH10_FIELD {
                let raw = self.raw;
                CH10_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ch10(&mut self, value: CH10_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ch10_with<F: Fn(&mut CH10_FIELD) -> &mut CH10_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch10();
                f(&mut value);
                self.set_ch10(value)
            }

            pub fn ch11(&self) -> CH11_FIELD {
                let raw = self.raw;
                CH11_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ch11(&mut self, value: CH11_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ch11_with<F: Fn(&mut CH11_FIELD) -> &mut CH11_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch11();
                f(&mut value);
                self.set_ch11(value)
            }

            pub fn ch12(&self) -> CH12_FIELD {
                let raw = self.raw;
                CH12_FIELD::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_ch12(&mut self, value: CH12_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_ch12_with<F: Fn(&mut CH12_FIELD) -> &mut CH12_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch12();
                f(&mut value);
                self.set_ch12(value)
            }

            pub fn ch13(&self) -> CH13_FIELD {
                let raw = self.raw;
                CH13_FIELD::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_ch13(&mut self, value: CH13_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_ch13_with<F: Fn(&mut CH13_FIELD) -> &mut CH13_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch13();
                f(&mut value);
                self.set_ch13(value)
            }

            pub fn ch14(&self) -> CH14_FIELD {
                let raw = self.raw;
                CH14_FIELD::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_ch14(&mut self, value: CH14_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_ch14_with<F: Fn(&mut CH14_FIELD) -> &mut CH14_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch14();
                f(&mut value);
                self.set_ch14(value)
            }

            pub fn ch15(&self) -> CH15_FIELD {
                let raw = self.raw;
                CH15_FIELD::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_ch15(&mut self, value: CH15_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_ch15_with<F: Fn(&mut CH15_FIELD) -> &mut CH15_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch15();
                f(&mut value);
                self.set_ch15(value)
            }

            pub fn ch16(&self) -> CH16_FIELD {
                let raw = self.raw;
                CH16_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_ch16(&mut self, value: CH16_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_ch16_with<F: Fn(&mut CH16_FIELD) -> &mut CH16_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch16();
                f(&mut value);
                self.set_ch16(value)
            }

            pub fn ch17(&self) -> CH17_FIELD {
                let raw = self.raw;
                CH17_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_ch17(&mut self, value: CH17_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_ch17_with<F: Fn(&mut CH17_FIELD) -> &mut CH17_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch17();
                f(&mut value);
                self.set_ch17(value)
            }

            pub fn ch18(&self) -> CH18_FIELD {
                let raw = self.raw;
                CH18_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_ch18(&mut self, value: CH18_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_ch18_with<F: Fn(&mut CH18_FIELD) -> &mut CH18_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch18();
                f(&mut value);
                self.set_ch18(value)
            }

            pub fn ch19(&self) -> CH19_FIELD {
                let raw = self.raw;
                CH19_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_ch19(&mut self, value: CH19_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_ch19_with<F: Fn(&mut CH19_FIELD) -> &mut CH19_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch19();
                f(&mut value);
                self.set_ch19(value)
            }

            pub fn ch20(&self) -> CH20_FIELD {
                let raw = self.raw;
                CH20_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_ch20(&mut self, value: CH20_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_ch20_with<F: Fn(&mut CH20_FIELD) -> &mut CH20_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch20();
                f(&mut value);
                self.set_ch20(value)
            }

            pub fn ch21(&self) -> CH21_FIELD {
                let raw = self.raw;
                CH21_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_ch21(&mut self, value: CH21_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_ch21_with<F: Fn(&mut CH21_FIELD) -> &mut CH21_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch21();
                f(&mut value);
                self.set_ch21(value)
            }

            pub fn ch22(&self) -> CH22_FIELD {
                let raw = self.raw;
                CH22_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_ch22(&mut self, value: CH22_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ch22_with<F: Fn(&mut CH22_FIELD) -> &mut CH22_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch22();
                f(&mut value);
                self.set_ch22(value)
            }

            pub fn ch23(&self) -> CH23_FIELD {
                let raw = self.raw;
                CH23_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ch23(&mut self, value: CH23_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ch23_with<F: Fn(&mut CH23_FIELD) -> &mut CH23_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch23();
                f(&mut value);
                self.set_ch23(value)
            }

            pub fn ch24(&self) -> CH24_FIELD {
                let raw = self.raw;
                CH24_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_ch24(&mut self, value: CH24_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_ch24_with<F: Fn(&mut CH24_FIELD) -> &mut CH24_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch24();
                f(&mut value);
                self.set_ch24(value)
            }

            pub fn ch25(&self) -> CH25_FIELD {
                let raw = self.raw;
                CH25_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_ch25(&mut self, value: CH25_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_ch25_with<F: Fn(&mut CH25_FIELD) -> &mut CH25_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch25();
                f(&mut value);
                self.set_ch25(value)
            }

            pub fn ch26(&self) -> CH26_FIELD {
                let raw = self.raw;
                CH26_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_ch26(&mut self, value: CH26_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_ch26_with<F: Fn(&mut CH26_FIELD) -> &mut CH26_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch26();
                f(&mut value);
                self.set_ch26(value)
            }

            pub fn ch27(&self) -> CH27_FIELD {
                let raw = self.raw;
                CH27_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_ch27(&mut self, value: CH27_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_ch27_with<F: Fn(&mut CH27_FIELD) -> &mut CH27_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch27();
                f(&mut value);
                self.set_ch27(value)
            }

            pub fn ch28(&self) -> CH28_FIELD {
                let raw = self.raw;
                CH28_FIELD::from_value((raw & 0x10000000) >> 28)
            }

            pub fn set_ch28(&mut self, value: CH28_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x10000000) | (value << 28);
                self
            }

            pub fn set_ch28_with<F: Fn(&mut CH28_FIELD) -> &mut CH28_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch28();
                f(&mut value);
                self.set_ch28(value)
            }

            pub fn ch29(&self) -> CH29_FIELD {
                let raw = self.raw;
                CH29_FIELD::from_value((raw & 0x20000000) >> 29)
            }

            pub fn set_ch29(&mut self, value: CH29_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x20000000) | (value << 29);
                self
            }

            pub fn set_ch29_with<F: Fn(&mut CH29_FIELD) -> &mut CH29_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch29();
                f(&mut value);
                self.set_ch29(value)
            }

            pub fn ch30(&self) -> CH30_FIELD {
                let raw = self.raw;
                CH30_FIELD::from_value((raw & 0x40000000) >> 30)
            }

            pub fn set_ch30(&mut self, value: CH30_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x40000000) | (value << 30);
                self
            }

            pub fn set_ch30_with<F: Fn(&mut CH30_FIELD) -> &mut CH30_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch30();
                f(&mut value);
                self.set_ch30(value)
            }

            pub fn ch31(&self) -> CH31_FIELD {
                let raw = self.raw;
                CH31_FIELD::from_value((raw & 0x80000000) >> 31)
            }

            pub fn set_ch31(&mut self, value: CH31_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x80000000) | (value << 31);
                self
            }

            pub fn set_ch31_with<F: Fn(&mut CH31_FIELD) -> &mut CH31_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ch31();
                f(&mut value);
                self.set_ch31(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH0_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH0_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH1_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH1_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH2_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH2_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH3_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH3_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH4_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH4_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH5_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH5_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH6_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH6_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH7_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH7_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH8_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH8_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH9_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH9_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH10_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH10_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH11_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH11_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH12_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH12_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH13_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH13_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH14_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH14_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH15_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH15_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH16_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH16_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH17_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH17_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH18_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH18_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH19_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH19_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH20_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH20_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH21_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH21_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH22_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH22_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH23_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH23_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH24_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH24_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH25_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH25_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH26_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH26_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH27_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH27_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH28_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH28_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH29_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH29_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH30_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH30_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CH31_FIELD u32 =>
                        // Exclude
                        Excluded = 0,
        // Include
                        Included = 1

                    );

        impl CH31_FIELD {
            pub fn is_excluded(&self) -> bool {
                *self == Self::Excluded
            }

            pub fn set_excluded(&mut self) -> &mut Self {
                *self = Self::Excluded;
                self
            }

            pub fn is_included(&self) -> bool {
                *self == Self::Included
            }

            pub fn set_included(&mut self) -> &mut Self {
                *self = Self::Included;
                self
            }
        }
    }

    pub mod fork {
        #[allow(unused_imports)]
        use super::*;

        /// Fork
        #[repr(C)]
        pub struct FORK {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Channel n task endpoint
            pub tep: tep::TEP,
        }

        pub mod tep {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TEP {
                raw: RawRegister<u32>,
            }

            impl TEP {}

            impl RegisterRead for TEP {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for TEP {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }
}

pub mod mwu {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct MWU {
        _hidden: (),
    }

    impl MWU {
        const BASE_ADDRESS: u32 = 0x40020000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for MWU {
        type Target = MWU_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for MWU {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct MWU_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 256],
        /// Peripheral events.
        pub events_region: [events_region::EVENTS_REGION; 4],
        _padding_288: [u8; 64],
        /// Peripheral events.
        pub events_pregion: [events_pregion::EVENTS_PREGION; 2],
        _padding_368: [u8; 400],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 20],
        /// Enable or disable interrupt
        pub nmien: nmien::NMIEN,
        /// Enable interrupt
        pub nmienset: nmienset::NMIENSET,
        /// Disable interrupt
        pub nmienclr: nmienclr::NMIENCLR,
        _padding_812: [u8; 212],
        /// Unspecified
        pub perregion: [perregion::PERREGION; 2],
        _padding_1040: [u8; 256],
        /// Enable/disable regions watch
        pub regionen: regionen::REGIONEN,
        /// Enable regions watch
        pub regionenset: regionenset::REGIONENSET,
        /// Disable regions watch
        pub regionenclr: regionenclr::REGIONENCLR,
        _padding_1308: [u8; 228],
        /// Unspecified
        pub region: [region::REGION; 4],
        _padding_1600: [u8; 128],
        /// Unspecified
        pub pregion: [pregion::PREGION; 2],
    }

    pub mod events_region {
        #[allow(unused_imports)]
        use super::*;

        /// Peripheral events.
        #[repr(C)]
        pub struct EVENTS_REGION {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Write access to region n detected
            pub wa: EventRegister,
            /// Description cluster: Read access to region n detected
            pub ra: EventRegister,
        }
    }

    pub mod events_pregion {
        #[allow(unused_imports)]
        use super::*;

        /// Peripheral events.
        #[repr(C)]
        pub struct EVENTS_PREGION {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Write access to peripheral region n
            /// detected
            pub wa: EventRegister,
            /// Description cluster: Read access to peripheral region n detected
            pub ra: EventRegister,
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_region0wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region1wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region2wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region3wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pregion0wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion1wa(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1ra(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_region0wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region1wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region2wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region3wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pregion0wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion1wa(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1ra(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }
    }

    pub mod nmien {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NMIEN {
            raw: RawRegister<u32>,
        }

        impl NMIEN {
            pub fn write_with<F: Fn(&mut NMIEN_VALUE) -> &mut NMIEN_VALUE>(&mut self, f: F) {
                let mut v = NMIEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NMIEN {
            type Value = NMIEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NMIEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NMIEN {
            type Value = NMIEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NMIEN_VALUE {
            raw: u32,
        }

        impl NMIEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> REGION0WA_FIELD {
                let raw = self.raw;
                REGION0WA_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: REGION0WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<F: Fn(&mut REGION0WA_FIELD) -> &mut REGION0WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> REGION0RA_FIELD {
                let raw = self.raw;
                REGION0RA_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: REGION0RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<F: Fn(&mut REGION0RA_FIELD) -> &mut REGION0RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> REGION1WA_FIELD {
                let raw = self.raw;
                REGION1WA_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: REGION1WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<F: Fn(&mut REGION1WA_FIELD) -> &mut REGION1WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> REGION1RA_FIELD {
                let raw = self.raw;
                REGION1RA_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: REGION1RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<F: Fn(&mut REGION1RA_FIELD) -> &mut REGION1RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> REGION2WA_FIELD {
                let raw = self.raw;
                REGION2WA_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: REGION2WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<F: Fn(&mut REGION2WA_FIELD) -> &mut REGION2WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> REGION2RA_FIELD {
                let raw = self.raw;
                REGION2RA_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: REGION2RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<F: Fn(&mut REGION2RA_FIELD) -> &mut REGION2RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> REGION3WA_FIELD {
                let raw = self.raw;
                REGION3WA_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: REGION3WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<F: Fn(&mut REGION3WA_FIELD) -> &mut REGION3WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> REGION3RA_FIELD {
                let raw = self.raw;
                REGION3RA_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: REGION3RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<F: Fn(&mut REGION3RA_FIELD) -> &mut REGION3RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> PREGION0WA_FIELD {
                let raw = self.raw;
                PREGION0WA_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: PREGION0WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<F: Fn(&mut PREGION0WA_FIELD) -> &mut PREGION0WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> PREGION0RA_FIELD {
                let raw = self.raw;
                PREGION0RA_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: PREGION0RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<F: Fn(&mut PREGION0RA_FIELD) -> &mut PREGION0RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> PREGION1WA_FIELD {
                let raw = self.raw;
                PREGION1WA_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: PREGION1WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<F: Fn(&mut PREGION1WA_FIELD) -> &mut PREGION1WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> PREGION1RA_FIELD {
                let raw = self.raw;
                PREGION1RA_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: PREGION1RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<F: Fn(&mut PREGION1RA_FIELD) -> &mut PREGION1RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION0WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION0RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION1WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION1RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION2WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION2RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION3WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl REGION3RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl PREGION0WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl PREGION0RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1WA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl PREGION1WA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1RA_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl PREGION1RA_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod nmienset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NMIENSET {
            raw: RawRegister<u32>,
        }

        impl NMIENSET {
            pub fn write_with<F: Fn(&mut NMIENSET_WRITE_VALUE) -> &mut NMIENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = NMIENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NMIENSET {
            type Value = NMIENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NMIENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NMIENSET {
            type Value = NMIENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NMIENSET_READ_VALUE {
            raw: u32,
        }

        impl NMIENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> REGION0WA_READ_FIELD {
                let raw = self.raw;
                REGION0WA_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: REGION0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<
                F: Fn(&mut REGION0WA_READ_FIELD) -> &mut REGION0WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> REGION0RA_READ_FIELD {
                let raw = self.raw;
                REGION0RA_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: REGION0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<
                F: Fn(&mut REGION0RA_READ_FIELD) -> &mut REGION0RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> REGION1WA_READ_FIELD {
                let raw = self.raw;
                REGION1WA_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: REGION1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<
                F: Fn(&mut REGION1WA_READ_FIELD) -> &mut REGION1WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> REGION1RA_READ_FIELD {
                let raw = self.raw;
                REGION1RA_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: REGION1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<
                F: Fn(&mut REGION1RA_READ_FIELD) -> &mut REGION1RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> REGION2WA_READ_FIELD {
                let raw = self.raw;
                REGION2WA_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: REGION2WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<
                F: Fn(&mut REGION2WA_READ_FIELD) -> &mut REGION2WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> REGION2RA_READ_FIELD {
                let raw = self.raw;
                REGION2RA_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: REGION2RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<
                F: Fn(&mut REGION2RA_READ_FIELD) -> &mut REGION2RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> REGION3WA_READ_FIELD {
                let raw = self.raw;
                REGION3WA_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: REGION3WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<
                F: Fn(&mut REGION3WA_READ_FIELD) -> &mut REGION3WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> REGION3RA_READ_FIELD {
                let raw = self.raw;
                REGION3RA_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: REGION3RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<
                F: Fn(&mut REGION3RA_READ_FIELD) -> &mut REGION3RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> PREGION0WA_READ_FIELD {
                let raw = self.raw;
                PREGION0WA_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: PREGION0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<
                F: Fn(&mut PREGION0WA_READ_FIELD) -> &mut PREGION0WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> PREGION0RA_READ_FIELD {
                let raw = self.raw;
                PREGION0RA_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: PREGION0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<
                F: Fn(&mut PREGION0RA_READ_FIELD) -> &mut PREGION0RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> PREGION1WA_READ_FIELD {
                let raw = self.raw;
                PREGION1WA_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: PREGION1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<
                F: Fn(&mut PREGION1WA_READ_FIELD) -> &mut PREGION1WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> PREGION1RA_READ_FIELD {
                let raw = self.raw;
                PREGION1RA_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: PREGION1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<
                F: Fn(&mut PREGION1RA_READ_FIELD) -> &mut PREGION1RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NMIENSET_WRITE_VALUE {
            raw: u32,
        }

        impl NMIENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_region0wa(&mut self) -> &mut Self {
                let value = REGION0WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0ra(&mut self) -> &mut Self {
                let value = REGION0RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region1wa(&mut self) -> &mut Self {
                let value = REGION1WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1ra(&mut self) -> &mut Self {
                let value = REGION1RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region2wa(&mut self) -> &mut Self {
                let value = REGION2WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2ra(&mut self) -> &mut Self {
                let value = REGION2RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region3wa(&mut self) -> &mut Self {
                let value = REGION3WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3ra(&mut self) -> &mut Self {
                let value = REGION3RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pregion0wa(&mut self) -> &mut Self {
                let value = PREGION0WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0ra(&mut self) -> &mut Self {
                let value = PREGION0RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion1wa(&mut self) -> &mut Self {
                let value = PREGION1WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1ra(&mut self) -> &mut Self {
                let value = PREGION1RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION0WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION0RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION1WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION1RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION2WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION2WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION2RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION2RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION3WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION3WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION3RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl REGION3RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl PREGION0WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl PREGION0RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1WA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl PREGION1WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1RA_WRITE_FIELD u32 =>
            // Enable
            Set = 1

        );

        impl PREGION1RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod nmienclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct NMIENCLR {
            raw: RawRegister<u32>,
        }

        impl NMIENCLR {
            pub fn write_with<F: Fn(&mut NMIENCLR_WRITE_VALUE) -> &mut NMIENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = NMIENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for NMIENCLR {
            type Value = NMIENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                NMIENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for NMIENCLR {
            type Value = NMIENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NMIENCLR_READ_VALUE {
            raw: u32,
        }

        impl NMIENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn region0wa(&self) -> REGION0WA_READ_FIELD {
                let raw = self.raw;
                REGION0WA_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_region0wa(&mut self, value: REGION0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0wa_with<
                F: Fn(&mut REGION0WA_READ_FIELD) -> &mut REGION0WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0wa();
                f(&mut value);
                self.set_region0wa(value)
            }

            pub fn region0ra(&self) -> REGION0RA_READ_FIELD {
                let raw = self.raw;
                REGION0RA_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_region0ra(&mut self, value: REGION0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region0ra_with<
                F: Fn(&mut REGION0RA_READ_FIELD) -> &mut REGION0RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region0ra();
                f(&mut value);
                self.set_region0ra(value)
            }

            pub fn region1wa(&self) -> REGION1WA_READ_FIELD {
                let raw = self.raw;
                REGION1WA_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_region1wa(&mut self, value: REGION1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1wa_with<
                F: Fn(&mut REGION1WA_READ_FIELD) -> &mut REGION1WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1wa();
                f(&mut value);
                self.set_region1wa(value)
            }

            pub fn region1ra(&self) -> REGION1RA_READ_FIELD {
                let raw = self.raw;
                REGION1RA_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_region1ra(&mut self, value: REGION1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region1ra_with<
                F: Fn(&mut REGION1RA_READ_FIELD) -> &mut REGION1RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region1ra();
                f(&mut value);
                self.set_region1ra(value)
            }

            pub fn region2wa(&self) -> REGION2WA_READ_FIELD {
                let raw = self.raw;
                REGION2WA_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_region2wa(&mut self, value: REGION2WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2wa_with<
                F: Fn(&mut REGION2WA_READ_FIELD) -> &mut REGION2WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2wa();
                f(&mut value);
                self.set_region2wa(value)
            }

            pub fn region2ra(&self) -> REGION2RA_READ_FIELD {
                let raw = self.raw;
                REGION2RA_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_region2ra(&mut self, value: REGION2RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region2ra_with<
                F: Fn(&mut REGION2RA_READ_FIELD) -> &mut REGION2RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region2ra();
                f(&mut value);
                self.set_region2ra(value)
            }

            pub fn region3wa(&self) -> REGION3WA_READ_FIELD {
                let raw = self.raw;
                REGION3WA_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_region3wa(&mut self, value: REGION3WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3wa_with<
                F: Fn(&mut REGION3WA_READ_FIELD) -> &mut REGION3WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3wa();
                f(&mut value);
                self.set_region3wa(value)
            }

            pub fn region3ra(&self) -> REGION3RA_READ_FIELD {
                let raw = self.raw;
                REGION3RA_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_region3ra(&mut self, value: REGION3RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_region3ra_with<
                F: Fn(&mut REGION3RA_READ_FIELD) -> &mut REGION3RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.region3ra();
                f(&mut value);
                self.set_region3ra(value)
            }

            pub fn pregion0wa(&self) -> PREGION0WA_READ_FIELD {
                let raw = self.raw;
                PREGION0WA_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_pregion0wa(&mut self, value: PREGION0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0wa_with<
                F: Fn(&mut PREGION0WA_READ_FIELD) -> &mut PREGION0WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0wa();
                f(&mut value);
                self.set_pregion0wa(value)
            }

            pub fn pregion0ra(&self) -> PREGION0RA_READ_FIELD {
                let raw = self.raw;
                PREGION0RA_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_pregion0ra(&mut self, value: PREGION0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion0ra_with<
                F: Fn(&mut PREGION0RA_READ_FIELD) -> &mut PREGION0RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion0ra();
                f(&mut value);
                self.set_pregion0ra(value)
            }

            pub fn pregion1wa(&self) -> PREGION1WA_READ_FIELD {
                let raw = self.raw;
                PREGION1WA_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_pregion1wa(&mut self, value: PREGION1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1wa_with<
                F: Fn(&mut PREGION1WA_READ_FIELD) -> &mut PREGION1WA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1wa();
                f(&mut value);
                self.set_pregion1wa(value)
            }

            pub fn pregion1ra(&self) -> PREGION1RA_READ_FIELD {
                let raw = self.raw;
                PREGION1RA_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_pregion1ra(&mut self, value: PREGION1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_pregion1ra_with<
                F: Fn(&mut PREGION1RA_READ_FIELD) -> &mut PREGION1RA_READ_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.pregion1ra();
                f(&mut value);
                self.set_pregion1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct NMIENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl NMIENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_region0wa(&mut self) -> &mut Self {
                let value = REGION0WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_region0ra(&mut self) -> &mut Self {
                let value = REGION0RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_region1wa(&mut self) -> &mut Self {
                let value = REGION1WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_region1ra(&mut self) -> &mut Self {
                let value = REGION1RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_region2wa(&mut self) -> &mut Self {
                let value = REGION2WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_region2ra(&mut self) -> &mut Self {
                let value = REGION2RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_region3wa(&mut self) -> &mut Self {
                let value = REGION3WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_region3ra(&mut self) -> &mut Self {
                let value = REGION3RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_pregion0wa(&mut self) -> &mut Self {
                let value = PREGION0WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_pregion0ra(&mut self) -> &mut Self {
                let value = PREGION0RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_pregion1wa(&mut self) -> &mut Self {
                let value = PREGION1WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_pregion1ra(&mut self) -> &mut Self {
                let value = PREGION1RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION0WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION0RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION0RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION1WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION1RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION1RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION2WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION2WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION2RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION2RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION2RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION3WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION3WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl REGION3RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] REGION3RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl REGION3RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl PREGION0WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION0RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl PREGION0RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1WA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1WA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl PREGION1WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1RA_READ_FIELD u32 =>
                        // Read: Disabled
                        Disabled = 0,
        // Read: Enabled
                        Enabled = 1

                    );

        impl PREGION1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PREGION1RA_WRITE_FIELD u32 =>
            // Disable
            Clear = 1

        );

        impl PREGION1RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod perregion {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PERREGION {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Source of event/interrupt in region n,
            /// write access detected while corresponding subregion was enabled
            /// for watching
            pub substatwa: substatwa::SUBSTATWA,
            /// Description cluster: Source of event/interrupt in region n, read
            /// access detected while corresponding subregion was enabled for
            /// watching
            pub substatra: substatra::SUBSTATRA,
        }

        pub mod substatwa {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct SUBSTATWA {
                raw: RawRegister<u32>,
            }

            impl SUBSTATWA {
                pub fn write_with<F: Fn(&mut SUBSTATWA_VALUE) -> &mut SUBSTATWA_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = SUBSTATWA_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for SUBSTATWA {
                type Value = SUBSTATWA_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    SUBSTATWA_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for SUBSTATWA {
                type Value = SUBSTATWA_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct SUBSTATWA_VALUE {
                raw: u32,
            }

            impl SUBSTATWA_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn sr0(&self) -> SR0_FIELD {
                    let raw = self.raw;
                    SR0_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_sr0(&mut self, value: SR0_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_sr0_with<F: Fn(&mut SR0_FIELD) -> &mut SR0_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr0();
                    f(&mut value);
                    self.set_sr0(value)
                }

                pub fn sr1(&self) -> SR1_FIELD {
                    let raw = self.raw;
                    SR1_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_sr1(&mut self, value: SR1_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_sr1_with<F: Fn(&mut SR1_FIELD) -> &mut SR1_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr1();
                    f(&mut value);
                    self.set_sr1(value)
                }

                pub fn sr2(&self) -> SR2_FIELD {
                    let raw = self.raw;
                    SR2_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_sr2(&mut self, value: SR2_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_sr2_with<F: Fn(&mut SR2_FIELD) -> &mut SR2_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr2();
                    f(&mut value);
                    self.set_sr2(value)
                }

                pub fn sr3(&self) -> SR3_FIELD {
                    let raw = self.raw;
                    SR3_FIELD::from_value((raw & 0x00000008) >> 3)
                }

                pub fn set_sr3(&mut self, value: SR3_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_sr3_with<F: Fn(&mut SR3_FIELD) -> &mut SR3_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr3();
                    f(&mut value);
                    self.set_sr3(value)
                }

                pub fn sr4(&self) -> SR4_FIELD {
                    let raw = self.raw;
                    SR4_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_sr4(&mut self, value: SR4_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_sr4_with<F: Fn(&mut SR4_FIELD) -> &mut SR4_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr4();
                    f(&mut value);
                    self.set_sr4(value)
                }

                pub fn sr5(&self) -> SR5_FIELD {
                    let raw = self.raw;
                    SR5_FIELD::from_value((raw & 0x00000020) >> 5)
                }

                pub fn set_sr5(&mut self, value: SR5_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_sr5_with<F: Fn(&mut SR5_FIELD) -> &mut SR5_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr5();
                    f(&mut value);
                    self.set_sr5(value)
                }

                pub fn sr6(&self) -> SR6_FIELD {
                    let raw = self.raw;
                    SR6_FIELD::from_value((raw & 0x00000040) >> 6)
                }

                pub fn set_sr6(&mut self, value: SR6_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_sr6_with<F: Fn(&mut SR6_FIELD) -> &mut SR6_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr6();
                    f(&mut value);
                    self.set_sr6(value)
                }

                pub fn sr7(&self) -> SR7_FIELD {
                    let raw = self.raw;
                    SR7_FIELD::from_value((raw & 0x00000080) >> 7)
                }

                pub fn set_sr7(&mut self, value: SR7_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_sr7_with<F: Fn(&mut SR7_FIELD) -> &mut SR7_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr7();
                    f(&mut value);
                    self.set_sr7(value)
                }

                pub fn sr8(&self) -> SR8_FIELD {
                    let raw = self.raw;
                    SR8_FIELD::from_value((raw & 0x00000100) >> 8)
                }

                pub fn set_sr8(&mut self, value: SR8_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_sr8_with<F: Fn(&mut SR8_FIELD) -> &mut SR8_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr8();
                    f(&mut value);
                    self.set_sr8(value)
                }

                pub fn sr9(&self) -> SR9_FIELD {
                    let raw = self.raw;
                    SR9_FIELD::from_value((raw & 0x00000200) >> 9)
                }

                pub fn set_sr9(&mut self, value: SR9_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_sr9_with<F: Fn(&mut SR9_FIELD) -> &mut SR9_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr9();
                    f(&mut value);
                    self.set_sr9(value)
                }

                pub fn sr10(&self) -> SR10_FIELD {
                    let raw = self.raw;
                    SR10_FIELD::from_value((raw & 0x00000400) >> 10)
                }

                pub fn set_sr10(&mut self, value: SR10_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_sr10_with<F: Fn(&mut SR10_FIELD) -> &mut SR10_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr10();
                    f(&mut value);
                    self.set_sr10(value)
                }

                pub fn sr11(&self) -> SR11_FIELD {
                    let raw = self.raw;
                    SR11_FIELD::from_value((raw & 0x00000800) >> 11)
                }

                pub fn set_sr11(&mut self, value: SR11_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_sr11_with<F: Fn(&mut SR11_FIELD) -> &mut SR11_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr11();
                    f(&mut value);
                    self.set_sr11(value)
                }

                pub fn sr12(&self) -> SR12_FIELD {
                    let raw = self.raw;
                    SR12_FIELD::from_value((raw & 0x00001000) >> 12)
                }

                pub fn set_sr12(&mut self, value: SR12_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_sr12_with<F: Fn(&mut SR12_FIELD) -> &mut SR12_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr12();
                    f(&mut value);
                    self.set_sr12(value)
                }

                pub fn sr13(&self) -> SR13_FIELD {
                    let raw = self.raw;
                    SR13_FIELD::from_value((raw & 0x00002000) >> 13)
                }

                pub fn set_sr13(&mut self, value: SR13_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_sr13_with<F: Fn(&mut SR13_FIELD) -> &mut SR13_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr13();
                    f(&mut value);
                    self.set_sr13(value)
                }

                pub fn sr14(&self) -> SR14_FIELD {
                    let raw = self.raw;
                    SR14_FIELD::from_value((raw & 0x00004000) >> 14)
                }

                pub fn set_sr14(&mut self, value: SR14_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_sr14_with<F: Fn(&mut SR14_FIELD) -> &mut SR14_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr14();
                    f(&mut value);
                    self.set_sr14(value)
                }

                pub fn sr15(&self) -> SR15_FIELD {
                    let raw = self.raw;
                    SR15_FIELD::from_value((raw & 0x00008000) >> 15)
                }

                pub fn set_sr15(&mut self, value: SR15_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_sr15_with<F: Fn(&mut SR15_FIELD) -> &mut SR15_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr15();
                    f(&mut value);
                    self.set_sr15(value)
                }

                pub fn sr16(&self) -> SR16_FIELD {
                    let raw = self.raw;
                    SR16_FIELD::from_value((raw & 0x00010000) >> 16)
                }

                pub fn set_sr16(&mut self, value: SR16_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_sr16_with<F: Fn(&mut SR16_FIELD) -> &mut SR16_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr16();
                    f(&mut value);
                    self.set_sr16(value)
                }

                pub fn sr17(&self) -> SR17_FIELD {
                    let raw = self.raw;
                    SR17_FIELD::from_value((raw & 0x00020000) >> 17)
                }

                pub fn set_sr17(&mut self, value: SR17_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_sr17_with<F: Fn(&mut SR17_FIELD) -> &mut SR17_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr17();
                    f(&mut value);
                    self.set_sr17(value)
                }

                pub fn sr18(&self) -> SR18_FIELD {
                    let raw = self.raw;
                    SR18_FIELD::from_value((raw & 0x00040000) >> 18)
                }

                pub fn set_sr18(&mut self, value: SR18_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_sr18_with<F: Fn(&mut SR18_FIELD) -> &mut SR18_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr18();
                    f(&mut value);
                    self.set_sr18(value)
                }

                pub fn sr19(&self) -> SR19_FIELD {
                    let raw = self.raw;
                    SR19_FIELD::from_value((raw & 0x00080000) >> 19)
                }

                pub fn set_sr19(&mut self, value: SR19_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_sr19_with<F: Fn(&mut SR19_FIELD) -> &mut SR19_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr19();
                    f(&mut value);
                    self.set_sr19(value)
                }

                pub fn sr20(&self) -> SR20_FIELD {
                    let raw = self.raw;
                    SR20_FIELD::from_value((raw & 0x00100000) >> 20)
                }

                pub fn set_sr20(&mut self, value: SR20_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_sr20_with<F: Fn(&mut SR20_FIELD) -> &mut SR20_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr20();
                    f(&mut value);
                    self.set_sr20(value)
                }

                pub fn sr21(&self) -> SR21_FIELD {
                    let raw = self.raw;
                    SR21_FIELD::from_value((raw & 0x00200000) >> 21)
                }

                pub fn set_sr21(&mut self, value: SR21_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_sr21_with<F: Fn(&mut SR21_FIELD) -> &mut SR21_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr21();
                    f(&mut value);
                    self.set_sr21(value)
                }

                pub fn sr22(&self) -> SR22_FIELD {
                    let raw = self.raw;
                    SR22_FIELD::from_value((raw & 0x00400000) >> 22)
                }

                pub fn set_sr22(&mut self, value: SR22_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_sr22_with<F: Fn(&mut SR22_FIELD) -> &mut SR22_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr22();
                    f(&mut value);
                    self.set_sr22(value)
                }

                pub fn sr23(&self) -> SR23_FIELD {
                    let raw = self.raw;
                    SR23_FIELD::from_value((raw & 0x00800000) >> 23)
                }

                pub fn set_sr23(&mut self, value: SR23_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_sr23_with<F: Fn(&mut SR23_FIELD) -> &mut SR23_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr23();
                    f(&mut value);
                    self.set_sr23(value)
                }

                pub fn sr24(&self) -> SR24_FIELD {
                    let raw = self.raw;
                    SR24_FIELD::from_value((raw & 0x01000000) >> 24)
                }

                pub fn set_sr24(&mut self, value: SR24_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_sr24_with<F: Fn(&mut SR24_FIELD) -> &mut SR24_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr24();
                    f(&mut value);
                    self.set_sr24(value)
                }

                pub fn sr25(&self) -> SR25_FIELD {
                    let raw = self.raw;
                    SR25_FIELD::from_value((raw & 0x02000000) >> 25)
                }

                pub fn set_sr25(&mut self, value: SR25_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_sr25_with<F: Fn(&mut SR25_FIELD) -> &mut SR25_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr25();
                    f(&mut value);
                    self.set_sr25(value)
                }

                pub fn sr26(&self) -> SR26_FIELD {
                    let raw = self.raw;
                    SR26_FIELD::from_value((raw & 0x04000000) >> 26)
                }

                pub fn set_sr26(&mut self, value: SR26_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_sr26_with<F: Fn(&mut SR26_FIELD) -> &mut SR26_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr26();
                    f(&mut value);
                    self.set_sr26(value)
                }

                pub fn sr27(&self) -> SR27_FIELD {
                    let raw = self.raw;
                    SR27_FIELD::from_value((raw & 0x08000000) >> 27)
                }

                pub fn set_sr27(&mut self, value: SR27_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_sr27_with<F: Fn(&mut SR27_FIELD) -> &mut SR27_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr27();
                    f(&mut value);
                    self.set_sr27(value)
                }

                pub fn sr28(&self) -> SR28_FIELD {
                    let raw = self.raw;
                    SR28_FIELD::from_value((raw & 0x10000000) >> 28)
                }

                pub fn set_sr28(&mut self, value: SR28_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_sr28_with<F: Fn(&mut SR28_FIELD) -> &mut SR28_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr28();
                    f(&mut value);
                    self.set_sr28(value)
                }

                pub fn sr29(&self) -> SR29_FIELD {
                    let raw = self.raw;
                    SR29_FIELD::from_value((raw & 0x20000000) >> 29)
                }

                pub fn set_sr29(&mut self, value: SR29_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_sr29_with<F: Fn(&mut SR29_FIELD) -> &mut SR29_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr29();
                    f(&mut value);
                    self.set_sr29(value)
                }

                pub fn sr30(&self) -> SR30_FIELD {
                    let raw = self.raw;
                    SR30_FIELD::from_value((raw & 0x40000000) >> 30)
                }

                pub fn set_sr30(&mut self, value: SR30_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_sr30_with<F: Fn(&mut SR30_FIELD) -> &mut SR30_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr30();
                    f(&mut value);
                    self.set_sr30(value)
                }

                pub fn sr31(&self) -> SR31_FIELD {
                    let raw = self.raw;
                    SR31_FIELD::from_value((raw & 0x80000000) >> 31)
                }

                pub fn set_sr31(&mut self, value: SR31_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }

                pub fn set_sr31_with<F: Fn(&mut SR31_FIELD) -> &mut SR31_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr31();
                    f(&mut value);
                    self.set_sr31(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR0_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR0_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR1_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR1_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR2_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR2_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR3_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR3_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR4_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR4_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR5_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR5_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR6_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR6_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR7_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR7_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR8_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR8_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR9_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR9_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR10_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR10_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR11_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR11_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR12_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR12_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR13_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR13_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR14_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR14_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR15_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR15_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR16_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR16_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR17_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR17_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR18_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR18_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR19_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR19_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR20_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR20_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR21_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR21_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR22_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR22_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR23_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR23_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR24_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR24_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR25_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR25_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR26_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR26_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR27_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR27_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR28_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR28_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR29_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR29_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR30_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR30_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR31_FIELD u32 =>
                            // No write access occurred in this subregion
                            NoAccess = 0,
            // Write access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR31_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }
        }

        pub mod substatra {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct SUBSTATRA {
                raw: RawRegister<u32>,
            }

            impl SUBSTATRA {
                pub fn write_with<F: Fn(&mut SUBSTATRA_VALUE) -> &mut SUBSTATRA_VALUE>(
                    &mut self,
                    f: F,
                ) {
                    let mut v = SUBSTATRA_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for SUBSTATRA {
                type Value = SUBSTATRA_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    SUBSTATRA_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for SUBSTATRA {
                type Value = SUBSTATRA_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct SUBSTATRA_VALUE {
                raw: u32,
            }

            impl SUBSTATRA_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn sr0(&self) -> SR0_FIELD {
                    let raw = self.raw;
                    SR0_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_sr0(&mut self, value: SR0_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_sr0_with<F: Fn(&mut SR0_FIELD) -> &mut SR0_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr0();
                    f(&mut value);
                    self.set_sr0(value)
                }

                pub fn sr1(&self) -> SR1_FIELD {
                    let raw = self.raw;
                    SR1_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_sr1(&mut self, value: SR1_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_sr1_with<F: Fn(&mut SR1_FIELD) -> &mut SR1_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr1();
                    f(&mut value);
                    self.set_sr1(value)
                }

                pub fn sr2(&self) -> SR2_FIELD {
                    let raw = self.raw;
                    SR2_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_sr2(&mut self, value: SR2_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_sr2_with<F: Fn(&mut SR2_FIELD) -> &mut SR2_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr2();
                    f(&mut value);
                    self.set_sr2(value)
                }

                pub fn sr3(&self) -> SR3_FIELD {
                    let raw = self.raw;
                    SR3_FIELD::from_value((raw & 0x00000008) >> 3)
                }

                pub fn set_sr3(&mut self, value: SR3_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_sr3_with<F: Fn(&mut SR3_FIELD) -> &mut SR3_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr3();
                    f(&mut value);
                    self.set_sr3(value)
                }

                pub fn sr4(&self) -> SR4_FIELD {
                    let raw = self.raw;
                    SR4_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_sr4(&mut self, value: SR4_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_sr4_with<F: Fn(&mut SR4_FIELD) -> &mut SR4_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr4();
                    f(&mut value);
                    self.set_sr4(value)
                }

                pub fn sr5(&self) -> SR5_FIELD {
                    let raw = self.raw;
                    SR5_FIELD::from_value((raw & 0x00000020) >> 5)
                }

                pub fn set_sr5(&mut self, value: SR5_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_sr5_with<F: Fn(&mut SR5_FIELD) -> &mut SR5_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr5();
                    f(&mut value);
                    self.set_sr5(value)
                }

                pub fn sr6(&self) -> SR6_FIELD {
                    let raw = self.raw;
                    SR6_FIELD::from_value((raw & 0x00000040) >> 6)
                }

                pub fn set_sr6(&mut self, value: SR6_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_sr6_with<F: Fn(&mut SR6_FIELD) -> &mut SR6_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr6();
                    f(&mut value);
                    self.set_sr6(value)
                }

                pub fn sr7(&self) -> SR7_FIELD {
                    let raw = self.raw;
                    SR7_FIELD::from_value((raw & 0x00000080) >> 7)
                }

                pub fn set_sr7(&mut self, value: SR7_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_sr7_with<F: Fn(&mut SR7_FIELD) -> &mut SR7_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr7();
                    f(&mut value);
                    self.set_sr7(value)
                }

                pub fn sr8(&self) -> SR8_FIELD {
                    let raw = self.raw;
                    SR8_FIELD::from_value((raw & 0x00000100) >> 8)
                }

                pub fn set_sr8(&mut self, value: SR8_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_sr8_with<F: Fn(&mut SR8_FIELD) -> &mut SR8_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr8();
                    f(&mut value);
                    self.set_sr8(value)
                }

                pub fn sr9(&self) -> SR9_FIELD {
                    let raw = self.raw;
                    SR9_FIELD::from_value((raw & 0x00000200) >> 9)
                }

                pub fn set_sr9(&mut self, value: SR9_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_sr9_with<F: Fn(&mut SR9_FIELD) -> &mut SR9_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr9();
                    f(&mut value);
                    self.set_sr9(value)
                }

                pub fn sr10(&self) -> SR10_FIELD {
                    let raw = self.raw;
                    SR10_FIELD::from_value((raw & 0x00000400) >> 10)
                }

                pub fn set_sr10(&mut self, value: SR10_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_sr10_with<F: Fn(&mut SR10_FIELD) -> &mut SR10_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr10();
                    f(&mut value);
                    self.set_sr10(value)
                }

                pub fn sr11(&self) -> SR11_FIELD {
                    let raw = self.raw;
                    SR11_FIELD::from_value((raw & 0x00000800) >> 11)
                }

                pub fn set_sr11(&mut self, value: SR11_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_sr11_with<F: Fn(&mut SR11_FIELD) -> &mut SR11_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr11();
                    f(&mut value);
                    self.set_sr11(value)
                }

                pub fn sr12(&self) -> SR12_FIELD {
                    let raw = self.raw;
                    SR12_FIELD::from_value((raw & 0x00001000) >> 12)
                }

                pub fn set_sr12(&mut self, value: SR12_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_sr12_with<F: Fn(&mut SR12_FIELD) -> &mut SR12_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr12();
                    f(&mut value);
                    self.set_sr12(value)
                }

                pub fn sr13(&self) -> SR13_FIELD {
                    let raw = self.raw;
                    SR13_FIELD::from_value((raw & 0x00002000) >> 13)
                }

                pub fn set_sr13(&mut self, value: SR13_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_sr13_with<F: Fn(&mut SR13_FIELD) -> &mut SR13_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr13();
                    f(&mut value);
                    self.set_sr13(value)
                }

                pub fn sr14(&self) -> SR14_FIELD {
                    let raw = self.raw;
                    SR14_FIELD::from_value((raw & 0x00004000) >> 14)
                }

                pub fn set_sr14(&mut self, value: SR14_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_sr14_with<F: Fn(&mut SR14_FIELD) -> &mut SR14_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr14();
                    f(&mut value);
                    self.set_sr14(value)
                }

                pub fn sr15(&self) -> SR15_FIELD {
                    let raw = self.raw;
                    SR15_FIELD::from_value((raw & 0x00008000) >> 15)
                }

                pub fn set_sr15(&mut self, value: SR15_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_sr15_with<F: Fn(&mut SR15_FIELD) -> &mut SR15_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr15();
                    f(&mut value);
                    self.set_sr15(value)
                }

                pub fn sr16(&self) -> SR16_FIELD {
                    let raw = self.raw;
                    SR16_FIELD::from_value((raw & 0x00010000) >> 16)
                }

                pub fn set_sr16(&mut self, value: SR16_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_sr16_with<F: Fn(&mut SR16_FIELD) -> &mut SR16_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr16();
                    f(&mut value);
                    self.set_sr16(value)
                }

                pub fn sr17(&self) -> SR17_FIELD {
                    let raw = self.raw;
                    SR17_FIELD::from_value((raw & 0x00020000) >> 17)
                }

                pub fn set_sr17(&mut self, value: SR17_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_sr17_with<F: Fn(&mut SR17_FIELD) -> &mut SR17_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr17();
                    f(&mut value);
                    self.set_sr17(value)
                }

                pub fn sr18(&self) -> SR18_FIELD {
                    let raw = self.raw;
                    SR18_FIELD::from_value((raw & 0x00040000) >> 18)
                }

                pub fn set_sr18(&mut self, value: SR18_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_sr18_with<F: Fn(&mut SR18_FIELD) -> &mut SR18_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr18();
                    f(&mut value);
                    self.set_sr18(value)
                }

                pub fn sr19(&self) -> SR19_FIELD {
                    let raw = self.raw;
                    SR19_FIELD::from_value((raw & 0x00080000) >> 19)
                }

                pub fn set_sr19(&mut self, value: SR19_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_sr19_with<F: Fn(&mut SR19_FIELD) -> &mut SR19_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr19();
                    f(&mut value);
                    self.set_sr19(value)
                }

                pub fn sr20(&self) -> SR20_FIELD {
                    let raw = self.raw;
                    SR20_FIELD::from_value((raw & 0x00100000) >> 20)
                }

                pub fn set_sr20(&mut self, value: SR20_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_sr20_with<F: Fn(&mut SR20_FIELD) -> &mut SR20_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr20();
                    f(&mut value);
                    self.set_sr20(value)
                }

                pub fn sr21(&self) -> SR21_FIELD {
                    let raw = self.raw;
                    SR21_FIELD::from_value((raw & 0x00200000) >> 21)
                }

                pub fn set_sr21(&mut self, value: SR21_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_sr21_with<F: Fn(&mut SR21_FIELD) -> &mut SR21_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr21();
                    f(&mut value);
                    self.set_sr21(value)
                }

                pub fn sr22(&self) -> SR22_FIELD {
                    let raw = self.raw;
                    SR22_FIELD::from_value((raw & 0x00400000) >> 22)
                }

                pub fn set_sr22(&mut self, value: SR22_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_sr22_with<F: Fn(&mut SR22_FIELD) -> &mut SR22_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr22();
                    f(&mut value);
                    self.set_sr22(value)
                }

                pub fn sr23(&self) -> SR23_FIELD {
                    let raw = self.raw;
                    SR23_FIELD::from_value((raw & 0x00800000) >> 23)
                }

                pub fn set_sr23(&mut self, value: SR23_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_sr23_with<F: Fn(&mut SR23_FIELD) -> &mut SR23_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr23();
                    f(&mut value);
                    self.set_sr23(value)
                }

                pub fn sr24(&self) -> SR24_FIELD {
                    let raw = self.raw;
                    SR24_FIELD::from_value((raw & 0x01000000) >> 24)
                }

                pub fn set_sr24(&mut self, value: SR24_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_sr24_with<F: Fn(&mut SR24_FIELD) -> &mut SR24_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr24();
                    f(&mut value);
                    self.set_sr24(value)
                }

                pub fn sr25(&self) -> SR25_FIELD {
                    let raw = self.raw;
                    SR25_FIELD::from_value((raw & 0x02000000) >> 25)
                }

                pub fn set_sr25(&mut self, value: SR25_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_sr25_with<F: Fn(&mut SR25_FIELD) -> &mut SR25_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr25();
                    f(&mut value);
                    self.set_sr25(value)
                }

                pub fn sr26(&self) -> SR26_FIELD {
                    let raw = self.raw;
                    SR26_FIELD::from_value((raw & 0x04000000) >> 26)
                }

                pub fn set_sr26(&mut self, value: SR26_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_sr26_with<F: Fn(&mut SR26_FIELD) -> &mut SR26_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr26();
                    f(&mut value);
                    self.set_sr26(value)
                }

                pub fn sr27(&self) -> SR27_FIELD {
                    let raw = self.raw;
                    SR27_FIELD::from_value((raw & 0x08000000) >> 27)
                }

                pub fn set_sr27(&mut self, value: SR27_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_sr27_with<F: Fn(&mut SR27_FIELD) -> &mut SR27_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr27();
                    f(&mut value);
                    self.set_sr27(value)
                }

                pub fn sr28(&self) -> SR28_FIELD {
                    let raw = self.raw;
                    SR28_FIELD::from_value((raw & 0x10000000) >> 28)
                }

                pub fn set_sr28(&mut self, value: SR28_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_sr28_with<F: Fn(&mut SR28_FIELD) -> &mut SR28_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr28();
                    f(&mut value);
                    self.set_sr28(value)
                }

                pub fn sr29(&self) -> SR29_FIELD {
                    let raw = self.raw;
                    SR29_FIELD::from_value((raw & 0x20000000) >> 29)
                }

                pub fn set_sr29(&mut self, value: SR29_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_sr29_with<F: Fn(&mut SR29_FIELD) -> &mut SR29_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr29();
                    f(&mut value);
                    self.set_sr29(value)
                }

                pub fn sr30(&self) -> SR30_FIELD {
                    let raw = self.raw;
                    SR30_FIELD::from_value((raw & 0x40000000) >> 30)
                }

                pub fn set_sr30(&mut self, value: SR30_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_sr30_with<F: Fn(&mut SR30_FIELD) -> &mut SR30_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr30();
                    f(&mut value);
                    self.set_sr30(value)
                }

                pub fn sr31(&self) -> SR31_FIELD {
                    let raw = self.raw;
                    SR31_FIELD::from_value((raw & 0x80000000) >> 31)
                }

                pub fn set_sr31(&mut self, value: SR31_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }

                pub fn set_sr31_with<F: Fn(&mut SR31_FIELD) -> &mut SR31_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr31();
                    f(&mut value);
                    self.set_sr31(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR0_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR0_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR1_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR1_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR2_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR2_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR3_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR3_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR4_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR4_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR5_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR5_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR6_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR6_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR7_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR7_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR8_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR8_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR9_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR9_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR10_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR10_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR11_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR11_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR12_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR12_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR13_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR13_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR14_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR14_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR15_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR15_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR16_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR16_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR17_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR17_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR18_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR18_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR19_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR19_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR20_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR20_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR21_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR21_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR22_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR22_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR23_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR23_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR24_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR24_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR25_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR25_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR26_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR26_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR27_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR27_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR28_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR28_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR29_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR29_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR30_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR30_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR31_FIELD u32 =>
                            // No read access occurred in this subregion
                            NoAccess = 0,
            // Read access(es) occurred in this subregion
                            Access = 1

                        );

            impl SR31_FIELD {
                pub fn is_noaccess(&self) -> bool {
                    *self == Self::NoAccess
                }

                pub fn set_noaccess(&mut self) -> &mut Self {
                    *self = Self::NoAccess;
                    self
                }

                pub fn is_access(&self) -> bool {
                    *self == Self::Access
                }

                pub fn set_access(&mut self) -> &mut Self {
                    *self = Self::Access;
                    self
                }
            }
        }
    }

    pub mod regionen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REGIONEN {
            raw: RawRegister<u32>,
        }

        impl REGIONEN {
            pub fn write_with<F: Fn(&mut REGIONEN_VALUE) -> &mut REGIONEN_VALUE>(&mut self, f: F) {
                let mut v = REGIONEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for REGIONEN {
            type Value = REGIONEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                REGIONEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for REGIONEN {
            type Value = REGIONEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGIONEN_VALUE {
            raw: u32,
        }

        impl REGIONEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rgn0wa(&self) -> RGN0WA_FIELD {
                let raw = self.raw;
                RGN0WA_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_rgn0wa(&mut self, value: RGN0WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rgn0wa_with<F: Fn(&mut RGN0WA_FIELD) -> &mut RGN0WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0wa();
                f(&mut value);
                self.set_rgn0wa(value)
            }

            pub fn rgn0ra(&self) -> RGN0RA_FIELD {
                let raw = self.raw;
                RGN0RA_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rgn0ra(&mut self, value: RGN0RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rgn0ra_with<F: Fn(&mut RGN0RA_FIELD) -> &mut RGN0RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0ra();
                f(&mut value);
                self.set_rgn0ra(value)
            }

            pub fn rgn1wa(&self) -> RGN1WA_FIELD {
                let raw = self.raw;
                RGN1WA_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rgn1wa(&mut self, value: RGN1WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rgn1wa_with<F: Fn(&mut RGN1WA_FIELD) -> &mut RGN1WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1wa();
                f(&mut value);
                self.set_rgn1wa(value)
            }

            pub fn rgn1ra(&self) -> RGN1RA_FIELD {
                let raw = self.raw;
                RGN1RA_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_rgn1ra(&mut self, value: RGN1RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rgn1ra_with<F: Fn(&mut RGN1RA_FIELD) -> &mut RGN1RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1ra();
                f(&mut value);
                self.set_rgn1ra(value)
            }

            pub fn rgn2wa(&self) -> RGN2WA_FIELD {
                let raw = self.raw;
                RGN2WA_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_rgn2wa(&mut self, value: RGN2WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rgn2wa_with<F: Fn(&mut RGN2WA_FIELD) -> &mut RGN2WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2wa();
                f(&mut value);
                self.set_rgn2wa(value)
            }

            pub fn rgn2ra(&self) -> RGN2RA_FIELD {
                let raw = self.raw;
                RGN2RA_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rgn2ra(&mut self, value: RGN2RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rgn2ra_with<F: Fn(&mut RGN2RA_FIELD) -> &mut RGN2RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2ra();
                f(&mut value);
                self.set_rgn2ra(value)
            }

            pub fn rgn3wa(&self) -> RGN3WA_FIELD {
                let raw = self.raw;
                RGN3WA_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rgn3wa(&mut self, value: RGN3WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rgn3wa_with<F: Fn(&mut RGN3WA_FIELD) -> &mut RGN3WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3wa();
                f(&mut value);
                self.set_rgn3wa(value)
            }

            pub fn rgn3ra(&self) -> RGN3RA_FIELD {
                let raw = self.raw;
                RGN3RA_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rgn3ra(&mut self, value: RGN3RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rgn3ra_with<F: Fn(&mut RGN3RA_FIELD) -> &mut RGN3RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3ra();
                f(&mut value);
                self.set_rgn3ra(value)
            }

            pub fn prgn0wa(&self) -> PRGN0WA_FIELD {
                let raw = self.raw;
                PRGN0WA_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_prgn0wa(&mut self, value: PRGN0WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_prgn0wa_with<F: Fn(&mut PRGN0WA_FIELD) -> &mut PRGN0WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0wa();
                f(&mut value);
                self.set_prgn0wa(value)
            }

            pub fn prgn0ra(&self) -> PRGN0RA_FIELD {
                let raw = self.raw;
                PRGN0RA_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_prgn0ra(&mut self, value: PRGN0RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_prgn0ra_with<F: Fn(&mut PRGN0RA_FIELD) -> &mut PRGN0RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0ra();
                f(&mut value);
                self.set_prgn0ra(value)
            }

            pub fn prgn1wa(&self) -> PRGN1WA_FIELD {
                let raw = self.raw;
                PRGN1WA_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_prgn1wa(&mut self, value: PRGN1WA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_prgn1wa_with<F: Fn(&mut PRGN1WA_FIELD) -> &mut PRGN1WA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1wa();
                f(&mut value);
                self.set_prgn1wa(value)
            }

            pub fn prgn1ra(&self) -> PRGN1RA_FIELD {
                let raw = self.raw;
                PRGN1RA_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_prgn1ra(&mut self, value: PRGN1RA_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_prgn1ra_with<F: Fn(&mut PRGN1RA_FIELD) -> &mut PRGN1RA_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1ra();
                f(&mut value);
                self.set_prgn1ra(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0WA_FIELD u32 =>
                        // Disable write access watch in this region
                        Disable = 0,
        // Enable write access watch in this region
                        Enable = 1

                    );

        impl RGN0WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0RA_FIELD u32 =>
                        // Disable read access watch in this region
                        Disable = 0,
        // Enable read access watch in this region
                        Enable = 1

                    );

        impl RGN0RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1WA_FIELD u32 =>
                        // Disable write access watch in this region
                        Disable = 0,
        // Enable write access watch in this region
                        Enable = 1

                    );

        impl RGN1WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1RA_FIELD u32 =>
                        // Disable read access watch in this region
                        Disable = 0,
        // Enable read access watch in this region
                        Enable = 1

                    );

        impl RGN1RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2WA_FIELD u32 =>
                        // Disable write access watch in this region
                        Disable = 0,
        // Enable write access watch in this region
                        Enable = 1

                    );

        impl RGN2WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2RA_FIELD u32 =>
                        // Disable read access watch in this region
                        Disable = 0,
        // Enable read access watch in this region
                        Enable = 1

                    );

        impl RGN2RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3WA_FIELD u32 =>
                        // Disable write access watch in this region
                        Disable = 0,
        // Enable write access watch in this region
                        Enable = 1

                    );

        impl RGN3WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3RA_FIELD u32 =>
                        // Disable read access watch in this region
                        Disable = 0,
        // Enable read access watch in this region
                        Enable = 1

                    );

        impl RGN3RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0WA_FIELD u32 =>
                        // Disable write access watch in this PREGION
                        Disable = 0,
        // Enable write access watch in this PREGION
                        Enable = 1

                    );

        impl PRGN0WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0RA_FIELD u32 =>
                        // Disable read access watch in this PREGION
                        Disable = 0,
        // Enable read access watch in this PREGION
                        Enable = 1

                    );

        impl PRGN0RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1WA_FIELD u32 =>
                        // Disable write access watch in this PREGION
                        Disable = 0,
        // Enable write access watch in this PREGION
                        Enable = 1

                    );

        impl PRGN1WA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1RA_FIELD u32 =>
                        // Disable read access watch in this PREGION
                        Disable = 0,
        // Enable read access watch in this PREGION
                        Enable = 1

                    );

        impl PRGN1RA_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }
    }

    pub mod regionenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REGIONENSET {
            raw: RawRegister<u32>,
        }

        impl REGIONENSET {
            pub fn write_with<
                F: Fn(&mut REGIONENSET_WRITE_VALUE) -> &mut REGIONENSET_WRITE_VALUE,
            >(
                &mut self,
                f: F,
            ) {
                let mut v = REGIONENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for REGIONENSET {
            type Value = REGIONENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                REGIONENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for REGIONENSET {
            type Value = REGIONENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGIONENSET_READ_VALUE {
            raw: u32,
        }

        impl REGIONENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rgn0wa(&self) -> RGN0WA_READ_FIELD {
                let raw = self.raw;
                RGN0WA_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_rgn0wa(&mut self, value: RGN0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rgn0wa_with<F: Fn(&mut RGN0WA_READ_FIELD) -> &mut RGN0WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0wa();
                f(&mut value);
                self.set_rgn0wa(value)
            }

            pub fn rgn0ra(&self) -> RGN0RA_READ_FIELD {
                let raw = self.raw;
                RGN0RA_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rgn0ra(&mut self, value: RGN0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rgn0ra_with<F: Fn(&mut RGN0RA_READ_FIELD) -> &mut RGN0RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0ra();
                f(&mut value);
                self.set_rgn0ra(value)
            }

            pub fn rgn1wa(&self) -> RGN1WA_READ_FIELD {
                let raw = self.raw;
                RGN1WA_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rgn1wa(&mut self, value: RGN1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rgn1wa_with<F: Fn(&mut RGN1WA_READ_FIELD) -> &mut RGN1WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1wa();
                f(&mut value);
                self.set_rgn1wa(value)
            }

            pub fn rgn1ra(&self) -> RGN1RA_READ_FIELD {
                let raw = self.raw;
                RGN1RA_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_rgn1ra(&mut self, value: RGN1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rgn1ra_with<F: Fn(&mut RGN1RA_READ_FIELD) -> &mut RGN1RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1ra();
                f(&mut value);
                self.set_rgn1ra(value)
            }

            pub fn rgn2wa(&self) -> RGN2WA_READ_FIELD {
                let raw = self.raw;
                RGN2WA_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_rgn2wa(&mut self, value: RGN2WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rgn2wa_with<F: Fn(&mut RGN2WA_READ_FIELD) -> &mut RGN2WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2wa();
                f(&mut value);
                self.set_rgn2wa(value)
            }

            pub fn rgn2ra(&self) -> RGN2RA_READ_FIELD {
                let raw = self.raw;
                RGN2RA_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rgn2ra(&mut self, value: RGN2RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rgn2ra_with<F: Fn(&mut RGN2RA_READ_FIELD) -> &mut RGN2RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2ra();
                f(&mut value);
                self.set_rgn2ra(value)
            }

            pub fn rgn3wa(&self) -> RGN3WA_READ_FIELD {
                let raw = self.raw;
                RGN3WA_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rgn3wa(&mut self, value: RGN3WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rgn3wa_with<F: Fn(&mut RGN3WA_READ_FIELD) -> &mut RGN3WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3wa();
                f(&mut value);
                self.set_rgn3wa(value)
            }

            pub fn rgn3ra(&self) -> RGN3RA_READ_FIELD {
                let raw = self.raw;
                RGN3RA_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rgn3ra(&mut self, value: RGN3RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rgn3ra_with<F: Fn(&mut RGN3RA_READ_FIELD) -> &mut RGN3RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3ra();
                f(&mut value);
                self.set_rgn3ra(value)
            }

            pub fn prgn0wa(&self) -> PRGN0WA_READ_FIELD {
                let raw = self.raw;
                PRGN0WA_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_prgn0wa(&mut self, value: PRGN0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_prgn0wa_with<F: Fn(&mut PRGN0WA_READ_FIELD) -> &mut PRGN0WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0wa();
                f(&mut value);
                self.set_prgn0wa(value)
            }

            pub fn prgn0ra(&self) -> PRGN0RA_READ_FIELD {
                let raw = self.raw;
                PRGN0RA_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_prgn0ra(&mut self, value: PRGN0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_prgn0ra_with<F: Fn(&mut PRGN0RA_READ_FIELD) -> &mut PRGN0RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0ra();
                f(&mut value);
                self.set_prgn0ra(value)
            }

            pub fn prgn1wa(&self) -> PRGN1WA_READ_FIELD {
                let raw = self.raw;
                PRGN1WA_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_prgn1wa(&mut self, value: PRGN1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_prgn1wa_with<F: Fn(&mut PRGN1WA_READ_FIELD) -> &mut PRGN1WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1wa();
                f(&mut value);
                self.set_prgn1wa(value)
            }

            pub fn prgn1ra(&self) -> PRGN1RA_READ_FIELD {
                let raw = self.raw;
                PRGN1RA_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_prgn1ra(&mut self, value: PRGN1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_prgn1ra_with<F: Fn(&mut PRGN1RA_READ_FIELD) -> &mut PRGN1RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1ra();
                f(&mut value);
                self.set_prgn1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGIONENSET_WRITE_VALUE {
            raw: u32,
        }

        impl REGIONENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_rgn0wa(&mut self) -> &mut Self {
                let value = RGN0WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rgn0ra(&mut self) -> &mut Self {
                let value = RGN0RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rgn1wa(&mut self) -> &mut Self {
                let value = RGN1WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rgn1ra(&mut self) -> &mut Self {
                let value = RGN1RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rgn2wa(&mut self) -> &mut Self {
                let value = RGN2WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rgn2ra(&mut self) -> &mut Self {
                let value = RGN2RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rgn3wa(&mut self) -> &mut Self {
                let value = RGN3WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rgn3ra(&mut self) -> &mut Self {
                let value = RGN3RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_prgn0wa(&mut self) -> &mut Self {
                let value = PRGN0WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_prgn0ra(&mut self) -> &mut Self {
                let value = PRGN0RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_prgn1wa(&mut self) -> &mut Self {
                let value = PRGN1WA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_prgn1ra(&mut self) -> &mut Self {
                let value = PRGN1RA_WRITE_FIELD::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0WA_WRITE_FIELD u32 =>
            // Enable write access watch in this region
            Set = 1

        );

        impl RGN0WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0RA_WRITE_FIELD u32 =>
            // Enable read access watch in this region
            Set = 1

        );

        impl RGN0RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1WA_WRITE_FIELD u32 =>
            // Enable write access watch in this region
            Set = 1

        );

        impl RGN1WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1RA_WRITE_FIELD u32 =>
            // Enable read access watch in this region
            Set = 1

        );

        impl RGN1RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN2WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2WA_WRITE_FIELD u32 =>
            // Enable write access watch in this region
            Set = 1

        );

        impl RGN2WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN2RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2RA_WRITE_FIELD u32 =>
            // Enable read access watch in this region
            Set = 1

        );

        impl RGN2RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN3WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3WA_WRITE_FIELD u32 =>
            // Enable write access watch in this region
            Set = 1

        );

        impl RGN3WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN3RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3RA_WRITE_FIELD u32 =>
            // Enable read access watch in this region
            Set = 1

        );

        impl RGN3RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0WA_READ_FIELD u32 =>
                        // Write access watch in this PREGION is disabled
                        Disabled = 0,
        // Write access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0WA_WRITE_FIELD u32 =>
            // Enable write access watch in this PREGION
            Set = 1

        );

        impl PRGN0WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0RA_READ_FIELD u32 =>
                        // Read access watch in this PREGION is disabled
                        Disabled = 0,
        // Read access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0RA_WRITE_FIELD u32 =>
            // Enable read access watch in this PREGION
            Set = 1

        );

        impl PRGN0RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1WA_READ_FIELD u32 =>
                        // Write access watch in this PREGION is disabled
                        Disabled = 0,
        // Write access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1WA_WRITE_FIELD u32 =>
            // Enable write access watch in this PREGION
            Set = 1

        );

        impl PRGN1WA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1RA_READ_FIELD u32 =>
                        // Read access watch in this PREGION is disabled
                        Disabled = 0,
        // Read access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1RA_WRITE_FIELD u32 =>
            // Enable read access watch in this PREGION
            Set = 1

        );

        impl PRGN1RA_WRITE_FIELD {
            pub fn is_set(&self) -> bool {
                *self == Self::Set
            }

            pub fn set_set(&mut self) -> &mut Self {
                *self = Self::Set;
                self
            }
        }
    }

    pub mod regionenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct REGIONENCLR {
            raw: RawRegister<u32>,
        }

        impl REGIONENCLR {
            pub fn write_with<
                F: Fn(&mut REGIONENCLR_WRITE_VALUE) -> &mut REGIONENCLR_WRITE_VALUE,
            >(
                &mut self,
                f: F,
            ) {
                let mut v = REGIONENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for REGIONENCLR {
            type Value = REGIONENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                REGIONENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for REGIONENCLR {
            type Value = REGIONENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGIONENCLR_READ_VALUE {
            raw: u32,
        }

        impl REGIONENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rgn0wa(&self) -> RGN0WA_READ_FIELD {
                let raw = self.raw;
                RGN0WA_READ_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_rgn0wa(&mut self, value: RGN0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rgn0wa_with<F: Fn(&mut RGN0WA_READ_FIELD) -> &mut RGN0WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0wa();
                f(&mut value);
                self.set_rgn0wa(value)
            }

            pub fn rgn0ra(&self) -> RGN0RA_READ_FIELD {
                let raw = self.raw;
                RGN0RA_READ_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rgn0ra(&mut self, value: RGN0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rgn0ra_with<F: Fn(&mut RGN0RA_READ_FIELD) -> &mut RGN0RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn0ra();
                f(&mut value);
                self.set_rgn0ra(value)
            }

            pub fn rgn1wa(&self) -> RGN1WA_READ_FIELD {
                let raw = self.raw;
                RGN1WA_READ_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_rgn1wa(&mut self, value: RGN1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rgn1wa_with<F: Fn(&mut RGN1WA_READ_FIELD) -> &mut RGN1WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1wa();
                f(&mut value);
                self.set_rgn1wa(value)
            }

            pub fn rgn1ra(&self) -> RGN1RA_READ_FIELD {
                let raw = self.raw;
                RGN1RA_READ_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_rgn1ra(&mut self, value: RGN1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rgn1ra_with<F: Fn(&mut RGN1RA_READ_FIELD) -> &mut RGN1RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn1ra();
                f(&mut value);
                self.set_rgn1ra(value)
            }

            pub fn rgn2wa(&self) -> RGN2WA_READ_FIELD {
                let raw = self.raw;
                RGN2WA_READ_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_rgn2wa(&mut self, value: RGN2WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rgn2wa_with<F: Fn(&mut RGN2WA_READ_FIELD) -> &mut RGN2WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2wa();
                f(&mut value);
                self.set_rgn2wa(value)
            }

            pub fn rgn2ra(&self) -> RGN2RA_READ_FIELD {
                let raw = self.raw;
                RGN2RA_READ_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_rgn2ra(&mut self, value: RGN2RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rgn2ra_with<F: Fn(&mut RGN2RA_READ_FIELD) -> &mut RGN2RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn2ra();
                f(&mut value);
                self.set_rgn2ra(value)
            }

            pub fn rgn3wa(&self) -> RGN3WA_READ_FIELD {
                let raw = self.raw;
                RGN3WA_READ_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_rgn3wa(&mut self, value: RGN3WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rgn3wa_with<F: Fn(&mut RGN3WA_READ_FIELD) -> &mut RGN3WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3wa();
                f(&mut value);
                self.set_rgn3wa(value)
            }

            pub fn rgn3ra(&self) -> RGN3RA_READ_FIELD {
                let raw = self.raw;
                RGN3RA_READ_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_rgn3ra(&mut self, value: RGN3RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_rgn3ra_with<F: Fn(&mut RGN3RA_READ_FIELD) -> &mut RGN3RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rgn3ra();
                f(&mut value);
                self.set_rgn3ra(value)
            }

            pub fn prgn0wa(&self) -> PRGN0WA_READ_FIELD {
                let raw = self.raw;
                PRGN0WA_READ_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_prgn0wa(&mut self, value: PRGN0WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_prgn0wa_with<F: Fn(&mut PRGN0WA_READ_FIELD) -> &mut PRGN0WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0wa();
                f(&mut value);
                self.set_prgn0wa(value)
            }

            pub fn prgn0ra(&self) -> PRGN0RA_READ_FIELD {
                let raw = self.raw;
                PRGN0RA_READ_FIELD::from_value((raw & 0x02000000) >> 25)
            }

            pub fn set_prgn0ra(&mut self, value: PRGN0RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_prgn0ra_with<F: Fn(&mut PRGN0RA_READ_FIELD) -> &mut PRGN0RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn0ra();
                f(&mut value);
                self.set_prgn0ra(value)
            }

            pub fn prgn1wa(&self) -> PRGN1WA_READ_FIELD {
                let raw = self.raw;
                PRGN1WA_READ_FIELD::from_value((raw & 0x04000000) >> 26)
            }

            pub fn set_prgn1wa(&mut self, value: PRGN1WA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_prgn1wa_with<F: Fn(&mut PRGN1WA_READ_FIELD) -> &mut PRGN1WA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1wa();
                f(&mut value);
                self.set_prgn1wa(value)
            }

            pub fn prgn1ra(&self) -> PRGN1RA_READ_FIELD {
                let raw = self.raw;
                PRGN1RA_READ_FIELD::from_value((raw & 0x08000000) >> 27)
            }

            pub fn set_prgn1ra(&mut self, value: PRGN1RA_READ_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }

            pub fn set_prgn1ra_with<F: Fn(&mut PRGN1RA_READ_FIELD) -> &mut PRGN1RA_READ_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.prgn1ra();
                f(&mut value);
                self.set_prgn1ra(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct REGIONENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl REGIONENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_rgn0wa(&mut self) -> &mut Self {
                let value = RGN0WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_rgn0ra(&mut self) -> &mut Self {
                let value = RGN0RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rgn1wa(&mut self) -> &mut Self {
                let value = RGN1WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_rgn1ra(&mut self) -> &mut Self {
                let value = RGN1RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_rgn2wa(&mut self) -> &mut Self {
                let value = RGN2WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_rgn2ra(&mut self) -> &mut Self {
                let value = RGN2RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_rgn3wa(&mut self) -> &mut Self {
                let value = RGN3WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_rgn3ra(&mut self) -> &mut Self {
                let value = RGN3RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_prgn0wa(&mut self) -> &mut Self {
                let value = PRGN0WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_prgn0ra(&mut self) -> &mut Self {
                let value = PRGN0RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x02000000) | (value << 25);
                self
            }

            pub fn set_prgn1wa(&mut self) -> &mut Self {
                let value = PRGN1WA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x04000000) | (value << 26);
                self
            }

            pub fn set_prgn1ra(&mut self) -> &mut Self {
                let value = PRGN1RA_WRITE_FIELD::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x08000000) | (value << 27);
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0WA_WRITE_FIELD u32 =>
            // Disable write access watch in this region
            Clear = 1

        );

        impl RGN0WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN0RA_WRITE_FIELD u32 =>
            // Disable read access watch in this region
            Clear = 1

        );

        impl RGN0RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1WA_WRITE_FIELD u32 =>
            // Disable write access watch in this region
            Clear = 1

        );

        impl RGN1WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN1RA_WRITE_FIELD u32 =>
            // Disable read access watch in this region
            Clear = 1

        );

        impl RGN1RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN2WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2WA_WRITE_FIELD u32 =>
            // Disable write access watch in this region
            Clear = 1

        );

        impl RGN2WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN2RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN2RA_WRITE_FIELD u32 =>
            // Disable read access watch in this region
            Clear = 1

        );

        impl RGN2RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3WA_READ_FIELD u32 =>
                        // Write access watch in this region is disabled
                        Disabled = 0,
        // Write access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN3WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3WA_WRITE_FIELD u32 =>
            // Disable write access watch in this region
            Clear = 1

        );

        impl RGN3WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3RA_READ_FIELD u32 =>
                        // Read access watch in this region is disabled
                        Disabled = 0,
        // Read access watch in this region is enabled
                        Enabled = 1

                    );

        impl RGN3RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RGN3RA_WRITE_FIELD u32 =>
            // Disable read access watch in this region
            Clear = 1

        );

        impl RGN3RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0WA_READ_FIELD u32 =>
                        // Write access watch in this PREGION is disabled
                        Disabled = 0,
        // Write access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN0WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0WA_WRITE_FIELD u32 =>
            // Disable write access watch in this PREGION
            Clear = 1

        );

        impl PRGN0WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0RA_READ_FIELD u32 =>
                        // Read access watch in this PREGION is disabled
                        Disabled = 0,
        // Read access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN0RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN0RA_WRITE_FIELD u32 =>
            // Disable read access watch in this PREGION
            Clear = 1

        );

        impl PRGN0RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1WA_READ_FIELD u32 =>
                        // Write access watch in this PREGION is disabled
                        Disabled = 0,
        // Write access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN1WA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1WA_WRITE_FIELD u32 =>
            // Disable write access watch in this PREGION
            Clear = 1

        );

        impl PRGN1WA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1RA_READ_FIELD u32 =>
                        // Read access watch in this PREGION is disabled
                        Disabled = 0,
        // Read access watch in this PREGION is enabled
                        Enabled = 1

                    );

        impl PRGN1RA_READ_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] PRGN1RA_WRITE_FIELD u32 =>
            // Disable read access watch in this PREGION
            Clear = 1

        );

        impl PRGN1RA_WRITE_FIELD {
            pub fn is_clear(&self) -> bool {
                *self == Self::Clear
            }

            pub fn set_clear(&mut self) -> &mut Self {
                *self = Self::Clear;
                self
            }
        }
    }

    pub mod region {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct REGION {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Start address for region n
            pub start: start::START,
            /// Description cluster: End address of region n
            pub end: end::END,
            _padding_8: [u8; 8],
        }

        pub mod start {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct START {
                raw: RawRegister<u32>,
            }

            impl START {}

            impl RegisterRead for START {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for START {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod end {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct END {
                raw: RawRegister<u32>,
            }

            impl END {}

            impl RegisterRead for END {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for END {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod pregion {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PREGION {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Reserved for future use
            pub start: start::START,
            /// Description cluster: Reserved for future use
            pub end: end::END,
            /// Description cluster: Subregions of region n
            pub subs: subs::SUBS,
            _padding_12: [u8; 4],
        }

        pub mod start {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct START {
                raw: RawRegister<u32>,
            }

            impl START {}

            impl RegisterRead for START {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }
        }

        pub mod end {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct END {
                raw: RawRegister<u32>,
            }

            impl END {}

            impl RegisterRead for END {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }
        }

        pub mod subs {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct SUBS {
                raw: RawRegister<u32>,
            }

            impl SUBS {
                pub fn write_with<F: Fn(&mut SUBS_VALUE) -> &mut SUBS_VALUE>(&mut self, f: F) {
                    let mut v = SUBS_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for SUBS {
                type Value = SUBS_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    SUBS_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for SUBS {
                type Value = SUBS_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct SUBS_VALUE {
                raw: u32,
            }

            impl SUBS_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn sr0(&self) -> SR0_FIELD {
                    let raw = self.raw;
                    SR0_FIELD::from_value((raw & 0x00000001) >> 0)
                }

                pub fn set_sr0(&mut self, value: SR0_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000001) | (value << 0);
                    self
                }

                pub fn set_sr0_with<F: Fn(&mut SR0_FIELD) -> &mut SR0_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr0();
                    f(&mut value);
                    self.set_sr0(value)
                }

                pub fn sr1(&self) -> SR1_FIELD {
                    let raw = self.raw;
                    SR1_FIELD::from_value((raw & 0x00000002) >> 1)
                }

                pub fn set_sr1(&mut self, value: SR1_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000002) | (value << 1);
                    self
                }

                pub fn set_sr1_with<F: Fn(&mut SR1_FIELD) -> &mut SR1_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr1();
                    f(&mut value);
                    self.set_sr1(value)
                }

                pub fn sr2(&self) -> SR2_FIELD {
                    let raw = self.raw;
                    SR2_FIELD::from_value((raw & 0x00000004) >> 2)
                }

                pub fn set_sr2(&mut self, value: SR2_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000004) | (value << 2);
                    self
                }

                pub fn set_sr2_with<F: Fn(&mut SR2_FIELD) -> &mut SR2_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr2();
                    f(&mut value);
                    self.set_sr2(value)
                }

                pub fn sr3(&self) -> SR3_FIELD {
                    let raw = self.raw;
                    SR3_FIELD::from_value((raw & 0x00000008) >> 3)
                }

                pub fn set_sr3(&mut self, value: SR3_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000008) | (value << 3);
                    self
                }

                pub fn set_sr3_with<F: Fn(&mut SR3_FIELD) -> &mut SR3_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr3();
                    f(&mut value);
                    self.set_sr3(value)
                }

                pub fn sr4(&self) -> SR4_FIELD {
                    let raw = self.raw;
                    SR4_FIELD::from_value((raw & 0x00000010) >> 4)
                }

                pub fn set_sr4(&mut self, value: SR4_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000010) | (value << 4);
                    self
                }

                pub fn set_sr4_with<F: Fn(&mut SR4_FIELD) -> &mut SR4_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr4();
                    f(&mut value);
                    self.set_sr4(value)
                }

                pub fn sr5(&self) -> SR5_FIELD {
                    let raw = self.raw;
                    SR5_FIELD::from_value((raw & 0x00000020) >> 5)
                }

                pub fn set_sr5(&mut self, value: SR5_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000020) | (value << 5);
                    self
                }

                pub fn set_sr5_with<F: Fn(&mut SR5_FIELD) -> &mut SR5_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr5();
                    f(&mut value);
                    self.set_sr5(value)
                }

                pub fn sr6(&self) -> SR6_FIELD {
                    let raw = self.raw;
                    SR6_FIELD::from_value((raw & 0x00000040) >> 6)
                }

                pub fn set_sr6(&mut self, value: SR6_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000040) | (value << 6);
                    self
                }

                pub fn set_sr6_with<F: Fn(&mut SR6_FIELD) -> &mut SR6_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr6();
                    f(&mut value);
                    self.set_sr6(value)
                }

                pub fn sr7(&self) -> SR7_FIELD {
                    let raw = self.raw;
                    SR7_FIELD::from_value((raw & 0x00000080) >> 7)
                }

                pub fn set_sr7(&mut self, value: SR7_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000080) | (value << 7);
                    self
                }

                pub fn set_sr7_with<F: Fn(&mut SR7_FIELD) -> &mut SR7_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr7();
                    f(&mut value);
                    self.set_sr7(value)
                }

                pub fn sr8(&self) -> SR8_FIELD {
                    let raw = self.raw;
                    SR8_FIELD::from_value((raw & 0x00000100) >> 8)
                }

                pub fn set_sr8(&mut self, value: SR8_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000100) | (value << 8);
                    self
                }

                pub fn set_sr8_with<F: Fn(&mut SR8_FIELD) -> &mut SR8_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr8();
                    f(&mut value);
                    self.set_sr8(value)
                }

                pub fn sr9(&self) -> SR9_FIELD {
                    let raw = self.raw;
                    SR9_FIELD::from_value((raw & 0x00000200) >> 9)
                }

                pub fn set_sr9(&mut self, value: SR9_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000200) | (value << 9);
                    self
                }

                pub fn set_sr9_with<F: Fn(&mut SR9_FIELD) -> &mut SR9_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr9();
                    f(&mut value);
                    self.set_sr9(value)
                }

                pub fn sr10(&self) -> SR10_FIELD {
                    let raw = self.raw;
                    SR10_FIELD::from_value((raw & 0x00000400) >> 10)
                }

                pub fn set_sr10(&mut self, value: SR10_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000400) | (value << 10);
                    self
                }

                pub fn set_sr10_with<F: Fn(&mut SR10_FIELD) -> &mut SR10_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr10();
                    f(&mut value);
                    self.set_sr10(value)
                }

                pub fn sr11(&self) -> SR11_FIELD {
                    let raw = self.raw;
                    SR11_FIELD::from_value((raw & 0x00000800) >> 11)
                }

                pub fn set_sr11(&mut self, value: SR11_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00000800) | (value << 11);
                    self
                }

                pub fn set_sr11_with<F: Fn(&mut SR11_FIELD) -> &mut SR11_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr11();
                    f(&mut value);
                    self.set_sr11(value)
                }

                pub fn sr12(&self) -> SR12_FIELD {
                    let raw = self.raw;
                    SR12_FIELD::from_value((raw & 0x00001000) >> 12)
                }

                pub fn set_sr12(&mut self, value: SR12_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00001000) | (value << 12);
                    self
                }

                pub fn set_sr12_with<F: Fn(&mut SR12_FIELD) -> &mut SR12_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr12();
                    f(&mut value);
                    self.set_sr12(value)
                }

                pub fn sr13(&self) -> SR13_FIELD {
                    let raw = self.raw;
                    SR13_FIELD::from_value((raw & 0x00002000) >> 13)
                }

                pub fn set_sr13(&mut self, value: SR13_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00002000) | (value << 13);
                    self
                }

                pub fn set_sr13_with<F: Fn(&mut SR13_FIELD) -> &mut SR13_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr13();
                    f(&mut value);
                    self.set_sr13(value)
                }

                pub fn sr14(&self) -> SR14_FIELD {
                    let raw = self.raw;
                    SR14_FIELD::from_value((raw & 0x00004000) >> 14)
                }

                pub fn set_sr14(&mut self, value: SR14_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00004000) | (value << 14);
                    self
                }

                pub fn set_sr14_with<F: Fn(&mut SR14_FIELD) -> &mut SR14_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr14();
                    f(&mut value);
                    self.set_sr14(value)
                }

                pub fn sr15(&self) -> SR15_FIELD {
                    let raw = self.raw;
                    SR15_FIELD::from_value((raw & 0x00008000) >> 15)
                }

                pub fn set_sr15(&mut self, value: SR15_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00008000) | (value << 15);
                    self
                }

                pub fn set_sr15_with<F: Fn(&mut SR15_FIELD) -> &mut SR15_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr15();
                    f(&mut value);
                    self.set_sr15(value)
                }

                pub fn sr16(&self) -> SR16_FIELD {
                    let raw = self.raw;
                    SR16_FIELD::from_value((raw & 0x00010000) >> 16)
                }

                pub fn set_sr16(&mut self, value: SR16_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_sr16_with<F: Fn(&mut SR16_FIELD) -> &mut SR16_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr16();
                    f(&mut value);
                    self.set_sr16(value)
                }

                pub fn sr17(&self) -> SR17_FIELD {
                    let raw = self.raw;
                    SR17_FIELD::from_value((raw & 0x00020000) >> 17)
                }

                pub fn set_sr17(&mut self, value: SR17_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00020000) | (value << 17);
                    self
                }

                pub fn set_sr17_with<F: Fn(&mut SR17_FIELD) -> &mut SR17_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr17();
                    f(&mut value);
                    self.set_sr17(value)
                }

                pub fn sr18(&self) -> SR18_FIELD {
                    let raw = self.raw;
                    SR18_FIELD::from_value((raw & 0x00040000) >> 18)
                }

                pub fn set_sr18(&mut self, value: SR18_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00040000) | (value << 18);
                    self
                }

                pub fn set_sr18_with<F: Fn(&mut SR18_FIELD) -> &mut SR18_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr18();
                    f(&mut value);
                    self.set_sr18(value)
                }

                pub fn sr19(&self) -> SR19_FIELD {
                    let raw = self.raw;
                    SR19_FIELD::from_value((raw & 0x00080000) >> 19)
                }

                pub fn set_sr19(&mut self, value: SR19_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00080000) | (value << 19);
                    self
                }

                pub fn set_sr19_with<F: Fn(&mut SR19_FIELD) -> &mut SR19_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr19();
                    f(&mut value);
                    self.set_sr19(value)
                }

                pub fn sr20(&self) -> SR20_FIELD {
                    let raw = self.raw;
                    SR20_FIELD::from_value((raw & 0x00100000) >> 20)
                }

                pub fn set_sr20(&mut self, value: SR20_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00100000) | (value << 20);
                    self
                }

                pub fn set_sr20_with<F: Fn(&mut SR20_FIELD) -> &mut SR20_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr20();
                    f(&mut value);
                    self.set_sr20(value)
                }

                pub fn sr21(&self) -> SR21_FIELD {
                    let raw = self.raw;
                    SR21_FIELD::from_value((raw & 0x00200000) >> 21)
                }

                pub fn set_sr21(&mut self, value: SR21_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00200000) | (value << 21);
                    self
                }

                pub fn set_sr21_with<F: Fn(&mut SR21_FIELD) -> &mut SR21_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr21();
                    f(&mut value);
                    self.set_sr21(value)
                }

                pub fn sr22(&self) -> SR22_FIELD {
                    let raw = self.raw;
                    SR22_FIELD::from_value((raw & 0x00400000) >> 22)
                }

                pub fn set_sr22(&mut self, value: SR22_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00400000) | (value << 22);
                    self
                }

                pub fn set_sr22_with<F: Fn(&mut SR22_FIELD) -> &mut SR22_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr22();
                    f(&mut value);
                    self.set_sr22(value)
                }

                pub fn sr23(&self) -> SR23_FIELD {
                    let raw = self.raw;
                    SR23_FIELD::from_value((raw & 0x00800000) >> 23)
                }

                pub fn set_sr23(&mut self, value: SR23_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00800000) | (value << 23);
                    self
                }

                pub fn set_sr23_with<F: Fn(&mut SR23_FIELD) -> &mut SR23_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr23();
                    f(&mut value);
                    self.set_sr23(value)
                }

                pub fn sr24(&self) -> SR24_FIELD {
                    let raw = self.raw;
                    SR24_FIELD::from_value((raw & 0x01000000) >> 24)
                }

                pub fn set_sr24(&mut self, value: SR24_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x01000000) | (value << 24);
                    self
                }

                pub fn set_sr24_with<F: Fn(&mut SR24_FIELD) -> &mut SR24_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr24();
                    f(&mut value);
                    self.set_sr24(value)
                }

                pub fn sr25(&self) -> SR25_FIELD {
                    let raw = self.raw;
                    SR25_FIELD::from_value((raw & 0x02000000) >> 25)
                }

                pub fn set_sr25(&mut self, value: SR25_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x02000000) | (value << 25);
                    self
                }

                pub fn set_sr25_with<F: Fn(&mut SR25_FIELD) -> &mut SR25_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr25();
                    f(&mut value);
                    self.set_sr25(value)
                }

                pub fn sr26(&self) -> SR26_FIELD {
                    let raw = self.raw;
                    SR26_FIELD::from_value((raw & 0x04000000) >> 26)
                }

                pub fn set_sr26(&mut self, value: SR26_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x04000000) | (value << 26);
                    self
                }

                pub fn set_sr26_with<F: Fn(&mut SR26_FIELD) -> &mut SR26_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr26();
                    f(&mut value);
                    self.set_sr26(value)
                }

                pub fn sr27(&self) -> SR27_FIELD {
                    let raw = self.raw;
                    SR27_FIELD::from_value((raw & 0x08000000) >> 27)
                }

                pub fn set_sr27(&mut self, value: SR27_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x08000000) | (value << 27);
                    self
                }

                pub fn set_sr27_with<F: Fn(&mut SR27_FIELD) -> &mut SR27_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr27();
                    f(&mut value);
                    self.set_sr27(value)
                }

                pub fn sr28(&self) -> SR28_FIELD {
                    let raw = self.raw;
                    SR28_FIELD::from_value((raw & 0x10000000) >> 28)
                }

                pub fn set_sr28(&mut self, value: SR28_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x10000000) | (value << 28);
                    self
                }

                pub fn set_sr28_with<F: Fn(&mut SR28_FIELD) -> &mut SR28_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr28();
                    f(&mut value);
                    self.set_sr28(value)
                }

                pub fn sr29(&self) -> SR29_FIELD {
                    let raw = self.raw;
                    SR29_FIELD::from_value((raw & 0x20000000) >> 29)
                }

                pub fn set_sr29(&mut self, value: SR29_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x20000000) | (value << 29);
                    self
                }

                pub fn set_sr29_with<F: Fn(&mut SR29_FIELD) -> &mut SR29_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr29();
                    f(&mut value);
                    self.set_sr29(value)
                }

                pub fn sr30(&self) -> SR30_FIELD {
                    let raw = self.raw;
                    SR30_FIELD::from_value((raw & 0x40000000) >> 30)
                }

                pub fn set_sr30(&mut self, value: SR30_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x40000000) | (value << 30);
                    self
                }

                pub fn set_sr30_with<F: Fn(&mut SR30_FIELD) -> &mut SR30_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr30();
                    f(&mut value);
                    self.set_sr30(value)
                }

                pub fn sr31(&self) -> SR31_FIELD {
                    let raw = self.raw;
                    SR31_FIELD::from_value((raw & 0x80000000) >> 31)
                }

                pub fn set_sr31(&mut self, value: SR31_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x80000000) | (value << 31);
                    self
                }

                pub fn set_sr31_with<F: Fn(&mut SR31_FIELD) -> &mut SR31_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.sr31();
                    f(&mut value);
                    self.set_sr31(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR0_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR0_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR1_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR1_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR2_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR2_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR3_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR3_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR4_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR4_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR5_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR5_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR6_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR6_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR7_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR7_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR8_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR8_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR9_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR9_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR10_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR10_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR11_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR11_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR12_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR12_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR13_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR13_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR14_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR14_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR15_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR15_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR16_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR16_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR17_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR17_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR18_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR18_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR19_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR19_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR20_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR20_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR21_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR21_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR22_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR22_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR23_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR23_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR24_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR24_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR25_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR25_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR26_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR26_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR27_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR27_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR28_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR28_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR29_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR29_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR30_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR30_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SR31_FIELD u32 =>
                            // Exclude
                            Exclude = 0,
            // Include
                            Include = 1

                        );

            impl SR31_FIELD {
                pub fn is_exclude(&self) -> bool {
                    *self == Self::Exclude
                }

                pub fn set_exclude(&mut self) -> &mut Self {
                    *self = Self::Exclude;
                    self
                }

                pub fn is_include(&self) -> bool {
                    *self == Self::Include
                }

                pub fn set_include(&mut self) -> &mut Self {
                    *self = Self::Include;
                    self
                }
            }
        }
    }
}

pub mod pwm1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PWM1 {
        _hidden: (),
    }

    impl PWM1 {
        const BASE_ADDRESS: u32 = 0x40021000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PWM1 {
        type Target = pwm0::PWM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PWM1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod pwm2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PWM2 {
        _hidden: (),
    }

    impl PWM2 {
        const BASE_ADDRESS: u32 = 0x40022000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PWM2 {
        type Target = pwm0::PWM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PWM2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spi2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPI2 {
        _hidden: (),
    }

    impl SPI2 {
        const BASE_ADDRESS: u32 = 0x40023000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPI2 {
        type Target = spi0::SPI0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPI2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spim2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIM2 {
        _hidden: (),
    }

    impl SPIM2 {
        const BASE_ADDRESS: u32 = 0x40023000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIM2 {
        type Target = spim0::SPIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIM2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spis2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIS2 {
        _hidden: (),
    }

    impl SPIS2 {
        const BASE_ADDRESS: u32 = 0x40023000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIS2 {
        type Target = spis0::SPIS0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIS2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod rtc2 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct RTC2 {
        _hidden: (),
    }

    impl RTC2 {
        const BASE_ADDRESS: u32 = 0x40024000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for RTC2 {
        type Target = rtc0::RTC0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for RTC2 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod i2s {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct I2S {
        _hidden: (),
    }

    impl I2S {
        const BASE_ADDRESS: u32 = 0x40025000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for I2S {
        type Target = I2S_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for I2S {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct I2S_REGISTERS {
        _hidden: (),
        /// Starts continuous I2S transfer. Also starts MCK generator when this
        /// is enabled.
        pub tasks_start: TaskRegister,
        /// Stops I2S transfer. Also stops MCK generator. Triggering this task
        /// will cause the STOPPED event to be generated.
        pub tasks_stop: TaskRegister,
        _padding_8: [u8; 252],
        /// The RXD.PTR register has been copied to internal double-buffers.
        /// When the I2S module is started and RX is enabled, this event will be
        /// generated for every RXTXD.MAXCNT words that are received on the SDIN
        /// pin.
        pub events_rxptrupd: EventRegister,
        /// I2S transfer stopped.
        pub events_stopped: EventRegister,
        _padding_268: [u8; 8],
        /// The TDX.PTR register has been copied to internal double-buffers.
        /// When the I2S module is started and TX is enabled, this event will be
        /// generated for every RXTXD.MAXCNT words that are sent on the SDOUT
        /// pin.
        pub events_txptrupd: EventRegister,
        _padding_280: [u8; 488],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 500],
        /// Enable I2S module.
        pub enable: enable::ENABLE,
        pub config: config::CONFIG,
        _padding_1324: [u8; 12],
        pub rxd: rxd::RXD,
        _padding_1340: [u8; 4],
        pub txd: txd::TXD,
        _padding_1348: [u8; 12],
        pub rxtxd: rxtxd::RXTXD,
        _padding_1364: [u8; 12],
        pub psel: psel::PSEL,
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rxptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rxptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxptrupd();
                f(&mut value);
                self.set_rxptrupd(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn txptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_txptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_txptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txptrupd();
                f(&mut value);
                self.set_txptrupd(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rxptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rxptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxptrupd();
                f(&mut value);
                self.set_rxptrupd(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn txptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_txptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_txptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txptrupd();
                f(&mut value);
                self.set_txptrupd(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_rxptrupd(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txptrupd(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn rxptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_rxptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_rxptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.rxptrupd();
                f(&mut value);
                self.set_rxptrupd(value)
            }

            pub fn stopped(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_stopped(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_stopped_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stopped();
                f(&mut value);
                self.set_stopped(value)
            }

            pub fn txptrupd(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_txptrupd(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_txptrupd_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.txptrupd();
                f(&mut value);
                self.set_txptrupd(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_rxptrupd(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_stopped(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_txptrupd(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // Disable
                        Disabled = 0,
        // Enable
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod config {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct CONFIG {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// I2S mode.
            pub mode: mode::MODE,
            /// Reception (RX) enable.
            pub rxen: rxen::RXEN,
            /// Transmission (TX) enable.
            pub txen: txen::TXEN,
            /// Master clock generator enable.
            pub mcken: mcken::MCKEN,
            /// Master clock generator frequency.
            pub mckfreq: mckfreq::MCKFREQ,
            /// MCK / LRCK ratio.
            pub ratio: ratio::RATIO,
            /// Sample width.
            pub swidth: swidth::SWIDTH,
            /// Alignment of sample within a frame.
            pub align: align::ALIGN,
            /// Frame format.
            pub format: format::FORMAT,
            /// Enable channels.
            pub channels: channels::CHANNELS,
        }

        pub mod mode {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MODE {
                raw: RawRegister<u32>,
            }

            impl MODE {
                pub fn write_master(&mut self) {
                    self.write(MODE_FIELD::Master)
                }

                pub fn write_slave(&mut self) {
                    self.write(MODE_FIELD::Slave)
                }
            }

            impl RegisterRead for MODE {
                type Value = MODE_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    MODE_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for MODE {
                type Value = MODE_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] MODE_FIELD u32 =>
                            // Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx.
                            Master = 0,
            // Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx
                            Slave = 1

                        );

            impl MODE_FIELD {
                pub fn is_master(&self) -> bool {
                    *self == Self::Master
                }

                pub fn set_master(&mut self) -> &mut Self {
                    *self = Self::Master;
                    self
                }

                pub fn is_slave(&self) -> bool {
                    *self == Self::Slave
                }

                pub fn set_slave(&mut self) -> &mut Self {
                    *self = Self::Slave;
                    self
                }
            }
        }

        pub mod rxen {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct RXEN {
                raw: RawRegister<u32>,
            }

            impl RXEN {
                pub fn write_disabled(&mut self) {
                    self.write(RXEN_FIELD::Disabled)
                }

                pub fn write_enabled(&mut self) {
                    self.write(RXEN_FIELD::Enabled)
                }
            }

            impl RegisterRead for RXEN {
                type Value = RXEN_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    RXEN_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for RXEN {
                type Value = RXEN_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] RXEN_FIELD u32 =>
                            // Reception disabled and now data will be written to the RXD.PTR address.
                            Disabled = 0,
            // Reception enabled.
                            Enabled = 1

                        );

            impl RXEN_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_enabled(&self) -> bool {
                    *self == Self::Enabled
                }

                pub fn set_enabled(&mut self) -> &mut Self {
                    *self = Self::Enabled;
                    self
                }
            }
        }

        pub mod txen {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct TXEN {
                raw: RawRegister<u32>,
            }

            impl TXEN {
                pub fn write_disabled(&mut self) {
                    self.write(TXEN_FIELD::Disabled)
                }

                pub fn write_enabled(&mut self) {
                    self.write(TXEN_FIELD::Enabled)
                }
            }

            impl RegisterRead for TXEN {
                type Value = TXEN_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    TXEN_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for TXEN {
                type Value = TXEN_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] TXEN_FIELD u32 =>
                            // Transmission disabled and now data will be read from the RXD.TXD address.
                            Disabled = 0,
            // Transmission enabled.
                            Enabled = 1

                        );

            impl TXEN_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_enabled(&self) -> bool {
                    *self == Self::Enabled
                }

                pub fn set_enabled(&mut self) -> &mut Self {
                    *self = Self::Enabled;
                    self
                }
            }
        }

        pub mod mcken {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MCKEN {
                raw: RawRegister<u32>,
            }

            impl MCKEN {
                pub fn write_disabled(&mut self) {
                    self.write(MCKEN_FIELD::Disabled)
                }

                pub fn write_enabled(&mut self) {
                    self.write(MCKEN_FIELD::Enabled)
                }
            }

            impl RegisterRead for MCKEN {
                type Value = MCKEN_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    MCKEN_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for MCKEN {
                type Value = MCKEN_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] MCKEN_FIELD u32 =>
                            // Master clock generator disabled and PSEL.MCK not connected(available as GPIO).
                            Disabled = 0,
            // Master clock generator running and MCK output on PSEL.MCK.
                            Enabled = 1

                        );

            impl MCKEN_FIELD {
                pub fn is_disabled(&self) -> bool {
                    *self == Self::Disabled
                }

                pub fn set_disabled(&mut self) -> &mut Self {
                    *self = Self::Disabled;
                    self
                }

                pub fn is_enabled(&self) -> bool {
                    *self == Self::Enabled
                }

                pub fn set_enabled(&mut self) -> &mut Self {
                    *self = Self::Enabled;
                    self
                }
            }
        }

        pub mod mckfreq {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MCKFREQ {
                raw: RawRegister<u32>,
            }

            impl MCKFREQ {
                pub fn write_32mdiv8(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV8)
                }

                pub fn write_32mdiv10(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV10)
                }

                pub fn write_32mdiv11(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV11)
                }

                pub fn write_32mdiv15(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV15)
                }

                pub fn write_32mdiv16(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV16)
                }

                pub fn write_32mdiv21(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV21)
                }

                pub fn write_32mdiv23(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV23)
                }

                pub fn write_32mdiv30(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV30)
                }

                pub fn write_32mdiv31(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV31)
                }

                pub fn write_32mdiv32(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV32)
                }

                pub fn write_32mdiv42(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV42)
                }

                pub fn write_32mdiv63(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV63)
                }

                pub fn write_32mdiv125(&mut self) {
                    self.write(MCKFREQ_FIELD::_32MDIV125)
                }
            }

            impl RegisterRead for MCKFREQ {
                type Value = MCKFREQ_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    MCKFREQ_FIELD::from_value((raw & 0xffffffff) >> 0)
                }
            }

            impl RegisterWrite for MCKFREQ {
                type Value = MCKFREQ_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] MCKFREQ_FIELD u32 =>
                            // 32 MHz / 8 = 4.0 MHz
                            _32MDIV8 = 536870912,
            // 32 MHz / 10 = 3.2 MHz
                            _32MDIV10 = 402653184,
            // 32 MHz / 11 = 2.9090909 MHz
                            _32MDIV11 = 369098752,
            // 32 MHz / 15 = 2.1333333 MHz
                            _32MDIV15 = 285212672,
            // 32 MHz / 16 = 2.0 MHz
                            _32MDIV16 = 268435456,
            // 32 MHz / 21 = 1.5238095
                            _32MDIV21 = 201326592,
            // 32 MHz / 23 = 1.3913043 MHz
                            _32MDIV23 = 184549376,
            // 32 MHz / 30 = 1.0666667 MHz
                            _32MDIV30 = 142606336,
            // 32 MHz / 31 = 1.0322581 MHz
                            _32MDIV31 = 138412032,
            // 32 MHz / 32 = 1.0 MHz
                            _32MDIV32 = 134217728,
            // 32 MHz / 42 = 0.7619048 MHz
                            _32MDIV42 = 100663296,
            // 32 MHz / 63 = 0.5079365 MHz
                            _32MDIV63 = 68157440,
            // 32 MHz / 125 = 0.256 MHz
                            _32MDIV125 = 34340864

                        );

            impl MCKFREQ_FIELD {
                pub fn is_32mdiv8(&self) -> bool {
                    *self == Self::_32MDIV8
                }

                pub fn set_32mdiv8(&mut self) -> &mut Self {
                    *self = Self::_32MDIV8;
                    self
                }

                pub fn is_32mdiv10(&self) -> bool {
                    *self == Self::_32MDIV10
                }

                pub fn set_32mdiv10(&mut self) -> &mut Self {
                    *self = Self::_32MDIV10;
                    self
                }

                pub fn is_32mdiv11(&self) -> bool {
                    *self == Self::_32MDIV11
                }

                pub fn set_32mdiv11(&mut self) -> &mut Self {
                    *self = Self::_32MDIV11;
                    self
                }

                pub fn is_32mdiv15(&self) -> bool {
                    *self == Self::_32MDIV15
                }

                pub fn set_32mdiv15(&mut self) -> &mut Self {
                    *self = Self::_32MDIV15;
                    self
                }

                pub fn is_32mdiv16(&self) -> bool {
                    *self == Self::_32MDIV16
                }

                pub fn set_32mdiv16(&mut self) -> &mut Self {
                    *self = Self::_32MDIV16;
                    self
                }

                pub fn is_32mdiv21(&self) -> bool {
                    *self == Self::_32MDIV21
                }

                pub fn set_32mdiv21(&mut self) -> &mut Self {
                    *self = Self::_32MDIV21;
                    self
                }

                pub fn is_32mdiv23(&self) -> bool {
                    *self == Self::_32MDIV23
                }

                pub fn set_32mdiv23(&mut self) -> &mut Self {
                    *self = Self::_32MDIV23;
                    self
                }

                pub fn is_32mdiv30(&self) -> bool {
                    *self == Self::_32MDIV30
                }

                pub fn set_32mdiv30(&mut self) -> &mut Self {
                    *self = Self::_32MDIV30;
                    self
                }

                pub fn is_32mdiv31(&self) -> bool {
                    *self == Self::_32MDIV31
                }

                pub fn set_32mdiv31(&mut self) -> &mut Self {
                    *self = Self::_32MDIV31;
                    self
                }

                pub fn is_32mdiv32(&self) -> bool {
                    *self == Self::_32MDIV32
                }

                pub fn set_32mdiv32(&mut self) -> &mut Self {
                    *self = Self::_32MDIV32;
                    self
                }

                pub fn is_32mdiv42(&self) -> bool {
                    *self == Self::_32MDIV42
                }

                pub fn set_32mdiv42(&mut self) -> &mut Self {
                    *self = Self::_32MDIV42;
                    self
                }

                pub fn is_32mdiv63(&self) -> bool {
                    *self == Self::_32MDIV63
                }

                pub fn set_32mdiv63(&mut self) -> &mut Self {
                    *self = Self::_32MDIV63;
                    self
                }

                pub fn is_32mdiv125(&self) -> bool {
                    *self == Self::_32MDIV125
                }

                pub fn set_32mdiv125(&mut self) -> &mut Self {
                    *self = Self::_32MDIV125;
                    self
                }
            }
        }

        pub mod ratio {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct RATIO {
                raw: RawRegister<u32>,
            }

            impl RATIO {
                pub fn write_32x(&mut self) {
                    self.write(RATIO_FIELD::_32X)
                }

                pub fn write_48x(&mut self) {
                    self.write(RATIO_FIELD::_48X)
                }

                pub fn write_64x(&mut self) {
                    self.write(RATIO_FIELD::_64X)
                }

                pub fn write_96x(&mut self) {
                    self.write(RATIO_FIELD::_96X)
                }

                pub fn write_128x(&mut self) {
                    self.write(RATIO_FIELD::_128X)
                }

                pub fn write_192x(&mut self) {
                    self.write(RATIO_FIELD::_192X)
                }

                pub fn write_256x(&mut self) {
                    self.write(RATIO_FIELD::_256X)
                }

                pub fn write_384x(&mut self) {
                    self.write(RATIO_FIELD::_384X)
                }

                pub fn write_512x(&mut self) {
                    self.write(RATIO_FIELD::_512X)
                }
            }

            impl RegisterRead for RATIO {
                type Value = RATIO_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    RATIO_FIELD::from_value((raw & 0x0000000f) >> 0)
                }
            }

            impl RegisterWrite for RATIO {
                type Value = RATIO_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] RATIO_FIELD u32 =>
                            // LRCK = MCK / 32
                            _32X = 0,
            // LRCK = MCK / 48
                            _48X = 1,
            // LRCK = MCK / 64
                            _64X = 2,
            // LRCK = MCK / 96
                            _96X = 3,
            // LRCK = MCK / 128
                            _128X = 4,
            // LRCK = MCK / 192
                            _192X = 5,
            // LRCK = MCK / 256
                            _256X = 6,
            // LRCK = MCK / 384
                            _384X = 7,
            // LRCK = MCK / 512
                            _512X = 8

                        );

            impl RATIO_FIELD {
                pub fn is_32x(&self) -> bool {
                    *self == Self::_32X
                }

                pub fn set_32x(&mut self) -> &mut Self {
                    *self = Self::_32X;
                    self
                }

                pub fn is_48x(&self) -> bool {
                    *self == Self::_48X
                }

                pub fn set_48x(&mut self) -> &mut Self {
                    *self = Self::_48X;
                    self
                }

                pub fn is_64x(&self) -> bool {
                    *self == Self::_64X
                }

                pub fn set_64x(&mut self) -> &mut Self {
                    *self = Self::_64X;
                    self
                }

                pub fn is_96x(&self) -> bool {
                    *self == Self::_96X
                }

                pub fn set_96x(&mut self) -> &mut Self {
                    *self = Self::_96X;
                    self
                }

                pub fn is_128x(&self) -> bool {
                    *self == Self::_128X
                }

                pub fn set_128x(&mut self) -> &mut Self {
                    *self = Self::_128X;
                    self
                }

                pub fn is_192x(&self) -> bool {
                    *self == Self::_192X
                }

                pub fn set_192x(&mut self) -> &mut Self {
                    *self = Self::_192X;
                    self
                }

                pub fn is_256x(&self) -> bool {
                    *self == Self::_256X
                }

                pub fn set_256x(&mut self) -> &mut Self {
                    *self = Self::_256X;
                    self
                }

                pub fn is_384x(&self) -> bool {
                    *self == Self::_384X
                }

                pub fn set_384x(&mut self) -> &mut Self {
                    *self = Self::_384X;
                    self
                }

                pub fn is_512x(&self) -> bool {
                    *self == Self::_512X
                }

                pub fn set_512x(&mut self) -> &mut Self {
                    *self = Self::_512X;
                    self
                }
            }
        }

        pub mod swidth {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct SWIDTH {
                raw: RawRegister<u32>,
            }

            impl SWIDTH {
                pub fn write_8bit(&mut self) {
                    self.write(SWIDTH_FIELD::_8Bit)
                }

                pub fn write_16bit(&mut self) {
                    self.write(SWIDTH_FIELD::_16Bit)
                }

                pub fn write_24bit(&mut self) {
                    self.write(SWIDTH_FIELD::_24Bit)
                }
            }

            impl RegisterRead for SWIDTH {
                type Value = SWIDTH_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    SWIDTH_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for SWIDTH {
                type Value = SWIDTH_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] SWIDTH_FIELD u32 =>
                            // 8 bit.
                            _8Bit = 0,
            // 16 bit.
                            _16Bit = 1,
            // 24 bit.
                            _24Bit = 2

                        );

            impl SWIDTH_FIELD {
                pub fn is_8bit(&self) -> bool {
                    *self == Self::_8Bit
                }

                pub fn set_8bit(&mut self) -> &mut Self {
                    *self = Self::_8Bit;
                    self
                }

                pub fn is_16bit(&self) -> bool {
                    *self == Self::_16Bit
                }

                pub fn set_16bit(&mut self) -> &mut Self {
                    *self = Self::_16Bit;
                    self
                }

                pub fn is_24bit(&self) -> bool {
                    *self == Self::_24Bit
                }

                pub fn set_24bit(&mut self) -> &mut Self {
                    *self = Self::_24Bit;
                    self
                }
            }
        }

        pub mod align {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct ALIGN {
                raw: RawRegister<u32>,
            }

            impl ALIGN {
                pub fn write_left(&mut self) {
                    self.write(ALIGN_FIELD::Left)
                }

                pub fn write_right(&mut self) {
                    self.write(ALIGN_FIELD::Right)
                }
            }

            impl RegisterRead for ALIGN {
                type Value = ALIGN_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    ALIGN_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for ALIGN {
                type Value = ALIGN_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] ALIGN_FIELD u32 =>
                            // Left-aligned.
                            Left = 0,
            // Right-aligned.
                            Right = 1

                        );

            impl ALIGN_FIELD {
                pub fn is_left(&self) -> bool {
                    *self == Self::Left
                }

                pub fn set_left(&mut self) -> &mut Self {
                    *self = Self::Left;
                    self
                }

                pub fn is_right(&self) -> bool {
                    *self == Self::Right
                }

                pub fn set_right(&mut self) -> &mut Self {
                    *self = Self::Right;
                    self
                }
            }
        }

        pub mod format {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct FORMAT {
                raw: RawRegister<u32>,
            }

            impl FORMAT {
                pub fn write_i2s(&mut self) {
                    self.write(FORMAT_FIELD::I2S)
                }

                pub fn write_aligned(&mut self) {
                    self.write(FORMAT_FIELD::Aligned)
                }
            }

            impl RegisterRead for FORMAT {
                type Value = FORMAT_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    FORMAT_FIELD::from_value((raw & 0x00000001) >> 0)
                }
            }

            impl RegisterWrite for FORMAT {
                type Value = FORMAT_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] FORMAT_FIELD u32 =>
                            // Original I2S format.
                            I2S = 0,
            // Alternate (left- or right-aligned) format.
                            Aligned = 1

                        );

            impl FORMAT_FIELD {
                pub fn is_i2s(&self) -> bool {
                    *self == Self::I2S
                }

                pub fn set_i2s(&mut self) -> &mut Self {
                    *self = Self::I2S;
                    self
                }

                pub fn is_aligned(&self) -> bool {
                    *self == Self::Aligned
                }

                pub fn set_aligned(&mut self) -> &mut Self {
                    *self = Self::Aligned;
                    self
                }
            }
        }

        pub mod channels {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct CHANNELS {
                raw: RawRegister<u32>,
            }

            impl CHANNELS {
                pub fn write_stereo(&mut self) {
                    self.write(CHANNELS_FIELD::Stereo)
                }

                pub fn write_left(&mut self) {
                    self.write(CHANNELS_FIELD::Left)
                }

                pub fn write_right(&mut self) {
                    self.write(CHANNELS_FIELD::Right)
                }
            }

            impl RegisterRead for CHANNELS {
                type Value = CHANNELS_FIELD;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    CHANNELS_FIELD::from_value((raw & 0x00000003) >> 0)
                }
            }

            impl RegisterWrite for CHANNELS {
                type Value = CHANNELS_FIELD;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = value.to_value();
                    self.raw.write(raw);
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] CHANNELS_FIELD u32 =>
                            // Stereo.
                            Stereo = 0,
            // Left only.
                            Left = 1,
            // Right only.
                            Right = 2

                        );

            impl CHANNELS_FIELD {
                pub fn is_stereo(&self) -> bool {
                    *self == Self::Stereo
                }

                pub fn set_stereo(&mut self) -> &mut Self {
                    *self = Self::Stereo;
                    self
                }

                pub fn is_left(&self) -> bool {
                    *self == Self::Left
                }

                pub fn set_left(&mut self) -> &mut Self {
                    *self = Self::Left;
                    self
                }

                pub fn is_right(&self) -> bool {
                    *self == Self::Right
                }

                pub fn set_right(&mut self) -> &mut Self {
                    *self = Self::Right;
                    self
                }
            }
        }
    }

    pub mod rxd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct RXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Receive buffer RAM start address.
            pub ptr: ptr::PTR,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod txd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct TXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Transmit buffer RAM start address.
            pub ptr: ptr::PTR,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod rxtxd {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct RXTXD {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Size of RXD and TXD buffers.
            pub maxcnt: maxcnt::MAXCNT,
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x00003fff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x00003fff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }
    }

    pub mod psel {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct PSEL {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Pin select for MCK signal.
            pub mck: PinSelectRegister,
            /// Pin select for SCK signal.
            pub sck: PinSelectRegister,
            /// Pin select for LRCK signal.
            pub lrck: PinSelectRegister,
            /// Pin select for SDIN signal.
            pub sdin: PinSelectRegister,
            /// Pin select for SDOUT signal.
            pub sdout: PinSelectRegister,
        }
    }
}

pub mod fpu {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct FPU {
        _hidden: (),
    }

    impl FPU {
        const BASE_ADDRESS: u32 = 0x40026000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for FPU {
        type Target = FPU_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for FPU {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct FPU_REGISTERS {
        _hidden: (),
        /// Unused.
        pub unused: unused::UNUSED,
    }

    pub mod unused {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct UNUSED {
            raw: RawRegister<u32>,
        }

        impl UNUSED {}

        impl RegisterRead for UNUSED {
            type Value = UNUSED_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                UNUSED_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct UNUSED_READ_VALUE {
            raw: u32,
        }

        impl UNUSED_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }
        }
    }
}

pub mod usbd {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct USBD {
        _hidden: (),
    }

    impl USBD {
        const BASE_ADDRESS: u32 = 0x40027000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for USBD {
        type Target = USBD_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for USBD {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    #[repr(C)]
    pub struct USBD_REGISTERS {
        _hidden: (),
        _padding_0: [u8; 4],
        /// Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT
        /// registers values, and enables endpoint IN n to respond to traffic
        /// from host
        pub tasks_startepin: [TaskRegister; 8],
        /// Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and
        /// enables sending data on ISO endpoint
        pub tasks_startisoin: TaskRegister,
        /// Description collection: Captures the EPOUT[n].PTR and
        /// EPOUT[n].MAXCNT registers values, and enables endpoint n to respond
        /// to traffic from host
        pub tasks_startepout: [TaskRegister; 8],
        /// Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and
        /// enables receiving of data on ISO endpoint
        pub tasks_startisoout: TaskRegister,
        /// Allows OUT data stage on control endpoint 0
        pub tasks_ep0rcvout: TaskRegister,
        /// Allows status stage on control endpoint 0
        pub tasks_ep0status: TaskRegister,
        /// Stalls data and status stage on control endpoint 0
        pub tasks_ep0stall: TaskRegister,
        /// Forces D+ and D- lines into the state defined in the DPDMVALUE
        /// register
        pub tasks_dpdmdrive: TaskRegister,
        /// Stops forcing D+ and D- lines into any state (USB engine takes
        /// control)
        pub tasks_dpdmnodrive: TaskRegister,
        _padding_96: [u8; 160],
        /// Signals that a USB reset condition has been detected on USB lines
        pub events_usbreset: EventRegister,
        /// Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR
        /// and EPOUT[n].MAXCNT registers have been captured on all endpoints
        /// reported in the EPSTATUS register
        pub events_started: EventRegister,
        /// Description collection: The whole EPIN[n] buffer has been consumed.
        /// The buffer can be accessed safely by software.
        pub events_endepin: [EventRegister; 8],
        /// An acknowledged data transfer has taken place on the control
        /// endpoint
        pub events_ep0datadone: EventRegister,
        /// The whole ISOIN buffer has been consumed. The buffer can be accessed
        /// safely by software.
        pub events_endisoin: EventRegister,
        /// Description collection: The whole EPOUT[n] buffer has been consumed.
        /// The buffer can be accessed safely by software.
        pub events_endepout: [EventRegister; 8],
        /// The whole ISOOUT buffer has been consumed. The buffer can be
        /// accessed safely by software.
        pub events_endisoout: EventRegister,
        /// Signals that a SOF (start of frame) condition has been detected on
        /// USB lines
        pub events_sof: EventRegister,
        /// An event or an error not covered by specific events has occurred.
        /// Check EVENTCAUSE register to find the cause.
        pub events_usbevent: EventRegister,
        /// A valid SETUP token has been received (and acknowledged) on the
        /// control endpoint
        pub events_ep0setup: EventRegister,
        /// A data transfer has occurred on a data endpoint, indicated by the
        /// EPDATASTATUS register
        pub events_epdata: EventRegister,
        _padding_356: [u8; 156],
        /// Shortcuts between local events and tasks
        pub shorts: shorts::SHORTS,
        _padding_516: [u8; 252],
        /// Enable or disable interrupt
        pub inten: inten::INTEN,
        /// Enable interrupt
        pub intenset: intenset::INTENSET,
        /// Disable interrupt
        pub intenclr: intenclr::INTENCLR,
        _padding_780: [u8; 244],
        /// Details on what caused the USBEVENT event
        pub eventcause: eventcause::EVENTCAUSE,
        _padding_1028: [u8; 28],
        pub halted: halted::HALTED,
        _padding_1124: [u8; 4],
        /// Provides information on which endpoint's EasyDMA registers have been
        /// captured
        pub epstatus: epstatus::EPSTATUS,
        /// Provides information on which endpoint(s) an acknowledged data
        /// transfer has occurred (EPDATA event)
        pub epdatastatus: epdatastatus::EPDATASTATUS,
        /// Device USB address
        pub usbaddr: usbaddr::USBADDR,
        _padding_1140: [u8; 12],
        /// SETUP data, byte 0, bmRequestType
        pub bmrequesttype: bmrequesttype::BMREQUESTTYPE,
        /// SETUP data, byte 1, bRequest
        pub brequest: brequest::BREQUEST,
        /// SETUP data, byte 2, LSB of wValue
        pub wvaluel: wvaluel::WVALUEL,
        /// SETUP data, byte 3, MSB of wValue
        pub wvalueh: wvalueh::WVALUEH,
        /// SETUP data, byte 4, LSB of wIndex
        pub windexl: windexl::WINDEXL,
        /// SETUP data, byte 5, MSB of wIndex
        pub windexh: windexh::WINDEXH,
        /// SETUP data, byte 6, LSB of wLength
        pub wlengthl: wlengthl::WLENGTHL,
        /// SETUP data, byte 7, MSB of wLength
        pub wlengthh: wlengthh::WLENGTHH,
        pub size: size::SIZE,
        _padding_1220: [u8; 60],
        /// Enable USB
        pub enable: enable::ENABLE,
        /// Control of the USB pull-up
        pub usbpullup: usbpullup::USBPULLUP,
        /// State D+ and D- lines will be forced into by the DPDMDRIVE task. The
        /// DPDMNODRIVE task reverts the control of the lines to MAC IP (no
        /// forcing).
        pub dpdmvalue: dpdmvalue::DPDMVALUE,
        /// Data toggle control and status
        pub dtoggle: dtoggle::DTOGGLE,
        /// Endpoint IN enable
        pub epinen: epinen::EPINEN,
        /// Endpoint OUT enable
        pub epouten: epouten::EPOUTEN,
        /// STALL endpoints
        pub epstall: epstall::EPSTALL,
        /// Controls the split of ISO buffers
        pub isosplit: isosplit::ISOSPLIT,
        /// Returns the current value of the start of frame counter
        pub framecntr: framecntr::FRAMECNTR,
        _padding_1316: [u8; 8],
        /// Controls USBD peripheral low power mode during USB suspend
        pub lowpower: lowpower::LOWPOWER,
        /// Controls the response of the ISO IN endpoint to an IN token when no
        /// data is ready to be sent
        pub isoinconfig: isoinconfig::ISOINCONFIG,
        _padding_1332: [u8; 204],
        /// Unspecified
        pub epin: [epin::EPIN; 8],
        pub isoin: isoin::ISOIN,
        _padding_1708: [u8; 84],
        /// Unspecified
        pub epout: [epout::EPOUT; 8],
        pub isoout: isoout::ISOOUT,
    }

    pub mod shorts {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct SHORTS {
            raw: RawRegister<u32>,
        }

        impl SHORTS {
            pub fn write_with<F: Fn(&mut SHORTS_VALUE) -> &mut SHORTS_VALUE>(&mut self, f: F) {
                let mut v = SHORTS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                SHORTS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for SHORTS {
            type Value = SHORTS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct SHORTS_VALUE {
            raw: u32,
        }

        impl SHORTS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ep0datadone_startepin0(&self) -> EP0DATADONE_STARTEPIN0_FIELD {
                let raw = self.raw;
                EP0DATADONE_STARTEPIN0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_ep0datadone_startepin0(
                &mut self,
                value: EP0DATADONE_STARTEPIN0_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_ep0datadone_startepin0_with<
                F: Fn(&mut EP0DATADONE_STARTEPIN0_FIELD) -> &mut EP0DATADONE_STARTEPIN0_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone_startepin0();
                f(&mut value);
                self.set_ep0datadone_startepin0(value)
            }

            pub fn ep0datadone_startepout0(&self) -> EP0DATADONE_STARTEPOUT0_FIELD {
                let raw = self.raw;
                EP0DATADONE_STARTEPOUT0_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_ep0datadone_startepout0(
                &mut self,
                value: EP0DATADONE_STARTEPOUT0_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_ep0datadone_startepout0_with<
                F: Fn(&mut EP0DATADONE_STARTEPOUT0_FIELD) -> &mut EP0DATADONE_STARTEPOUT0_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone_startepout0();
                f(&mut value);
                self.set_ep0datadone_startepout0(value)
            }

            pub fn ep0datadone_ep0status(&self) -> EP0DATADONE_EP0STATUS_FIELD {
                let raw = self.raw;
                EP0DATADONE_EP0STATUS_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_ep0datadone_ep0status(
                &mut self,
                value: EP0DATADONE_EP0STATUS_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_ep0datadone_ep0status_with<
                F: Fn(&mut EP0DATADONE_EP0STATUS_FIELD) -> &mut EP0DATADONE_EP0STATUS_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone_ep0status();
                f(&mut value);
                self.set_ep0datadone_ep0status(value)
            }

            pub fn endepout0_ep0status(&self) -> ENDEPOUT0_EP0STATUS_FIELD {
                let raw = self.raw;
                ENDEPOUT0_EP0STATUS_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_endepout0_ep0status(
                &mut self,
                value: ENDEPOUT0_EP0STATUS_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepout0_ep0status_with<
                F: Fn(&mut ENDEPOUT0_EP0STATUS_FIELD) -> &mut ENDEPOUT0_EP0STATUS_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout0_ep0status();
                f(&mut value);
                self.set_endepout0_ep0status(value)
            }

            pub fn endepout0_ep0rcvout(&self) -> ENDEPOUT0_EP0RCVOUT_FIELD {
                let raw = self.raw;
                ENDEPOUT0_EP0RCVOUT_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endepout0_ep0rcvout(
                &mut self,
                value: ENDEPOUT0_EP0RCVOUT_FIELD,
            ) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepout0_ep0rcvout_with<
                F: Fn(&mut ENDEPOUT0_EP0RCVOUT_FIELD) -> &mut ENDEPOUT0_EP0RCVOUT_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout0_ep0rcvout();
                f(&mut value);
                self.set_endepout0_ep0rcvout(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EP0DATADONE_STARTEPIN0_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl EP0DATADONE_STARTEPIN0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EP0DATADONE_STARTEPOUT0_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl EP0DATADONE_STARTEPOUT0_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EP0DATADONE_EP0STATUS_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl EP0DATADONE_EP0STATUS_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDEPOUT0_EP0STATUS_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ENDEPOUT0_EP0STATUS_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENDEPOUT0_EP0RCVOUT_FIELD u32 =>
                        // Disable shortcut
                        Disabled = 0,
        // Enable shortcut
                        Enabled = 1

                    );

        impl ENDEPOUT0_EP0RCVOUT_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod inten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTEN {
            raw: RawRegister<u32>,
        }

        impl INTEN {
            pub fn write_with<F: Fn(&mut INTEN_VALUE) -> &mut INTEN_VALUE>(&mut self, f: F) {
                let mut v = INTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTEN {
            type Value = INTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTEN_VALUE {
            raw: u32,
        }

        impl INTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn usbreset(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_usbreset(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_usbreset_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbreset();
                f(&mut value);
                self.set_usbreset(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn endepin0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_endepin0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endepin0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin0();
                f(&mut value);
                self.set_endepin0(value)
            }

            pub fn endepin1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_endepin1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepin1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin1();
                f(&mut value);
                self.set_endepin1(value)
            }

            pub fn endepin2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endepin2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepin2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin2();
                f(&mut value);
                self.set_endepin2(value)
            }

            pub fn endepin3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_endepin3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endepin3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin3();
                f(&mut value);
                self.set_endepin3(value)
            }

            pub fn endepin4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_endepin4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endepin4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin4();
                f(&mut value);
                self.set_endepin4(value)
            }

            pub fn endepin5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_endepin5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endepin5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin5();
                f(&mut value);
                self.set_endepin5(value)
            }

            pub fn endepin6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endepin6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endepin6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin6();
                f(&mut value);
                self.set_endepin6(value)
            }

            pub fn endepin7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_endepin7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_endepin7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin7();
                f(&mut value);
                self.set_endepin7(value)
            }

            pub fn ep0datadone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ep0datadone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ep0datadone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone();
                f(&mut value);
                self.set_ep0datadone(value)
            }

            pub fn endisoin(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endisoin(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endisoin_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoin();
                f(&mut value);
                self.set_endisoin(value)
            }

            pub fn endepout0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endepout0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endepout0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout0();
                f(&mut value);
                self.set_endepout0(value)
            }

            pub fn endepout1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_endepout1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_endepout1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout1();
                f(&mut value);
                self.set_endepout1(value)
            }

            pub fn endepout2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_endepout2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_endepout2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout2();
                f(&mut value);
                self.set_endepout2(value)
            }

            pub fn endepout3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_endepout3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_endepout3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout3();
                f(&mut value);
                self.set_endepout3(value)
            }

            pub fn endepout4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_endepout4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_endepout4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout4();
                f(&mut value);
                self.set_endepout4(value)
            }

            pub fn endepout5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_endepout5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_endepout5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout5();
                f(&mut value);
                self.set_endepout5(value)
            }

            pub fn endepout6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_endepout6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_endepout6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout6();
                f(&mut value);
                self.set_endepout6(value)
            }

            pub fn endepout7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_endepout7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_endepout7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout7();
                f(&mut value);
                self.set_endepout7(value)
            }

            pub fn endisoout(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_endisoout(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_endisoout_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoout();
                f(&mut value);
                self.set_endisoout(value)
            }

            pub fn sof(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_sof(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_sof_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sof();
                f(&mut value);
                self.set_sof(value)
            }

            pub fn usbevent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_usbevent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_usbevent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbevent();
                f(&mut value);
                self.set_usbevent(value)
            }

            pub fn ep0setup(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ep0setup(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ep0setup_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0setup();
                f(&mut value);
                self.set_ep0setup(value)
            }

            pub fn epdata(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_epdata(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_epdata_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epdata();
                f(&mut value);
                self.set_epdata(value)
            }
        }
    }

    pub mod intenset {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENSET {
            raw: RawRegister<u32>,
        }

        impl INTENSET {
            pub fn write_with<F: Fn(&mut INTENSET_WRITE_VALUE) -> &mut INTENSET_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENSET_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENSET {
            type Value = INTENSET_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENSET_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENSET {
            type Value = INTENSET_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_READ_VALUE {
            raw: u32,
        }

        impl INTENSET_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn usbreset(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_usbreset(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_usbreset_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbreset();
                f(&mut value);
                self.set_usbreset(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn endepin0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_endepin0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endepin0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin0();
                f(&mut value);
                self.set_endepin0(value)
            }

            pub fn endepin1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_endepin1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepin1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin1();
                f(&mut value);
                self.set_endepin1(value)
            }

            pub fn endepin2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endepin2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepin2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin2();
                f(&mut value);
                self.set_endepin2(value)
            }

            pub fn endepin3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_endepin3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endepin3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin3();
                f(&mut value);
                self.set_endepin3(value)
            }

            pub fn endepin4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_endepin4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endepin4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin4();
                f(&mut value);
                self.set_endepin4(value)
            }

            pub fn endepin5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_endepin5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endepin5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin5();
                f(&mut value);
                self.set_endepin5(value)
            }

            pub fn endepin6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endepin6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endepin6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin6();
                f(&mut value);
                self.set_endepin6(value)
            }

            pub fn endepin7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_endepin7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_endepin7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin7();
                f(&mut value);
                self.set_endepin7(value)
            }

            pub fn ep0datadone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ep0datadone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ep0datadone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone();
                f(&mut value);
                self.set_ep0datadone(value)
            }

            pub fn endisoin(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endisoin(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endisoin_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoin();
                f(&mut value);
                self.set_endisoin(value)
            }

            pub fn endepout0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endepout0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endepout0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout0();
                f(&mut value);
                self.set_endepout0(value)
            }

            pub fn endepout1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_endepout1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_endepout1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout1();
                f(&mut value);
                self.set_endepout1(value)
            }

            pub fn endepout2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_endepout2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_endepout2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout2();
                f(&mut value);
                self.set_endepout2(value)
            }

            pub fn endepout3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_endepout3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_endepout3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout3();
                f(&mut value);
                self.set_endepout3(value)
            }

            pub fn endepout4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_endepout4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_endepout4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout4();
                f(&mut value);
                self.set_endepout4(value)
            }

            pub fn endepout5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_endepout5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_endepout5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout5();
                f(&mut value);
                self.set_endepout5(value)
            }

            pub fn endepout6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_endepout6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_endepout6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout6();
                f(&mut value);
                self.set_endepout6(value)
            }

            pub fn endepout7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_endepout7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_endepout7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout7();
                f(&mut value);
                self.set_endepout7(value)
            }

            pub fn endisoout(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_endisoout(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_endisoout_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoout();
                f(&mut value);
                self.set_endisoout(value)
            }

            pub fn sof(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_sof(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_sof_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sof();
                f(&mut value);
                self.set_sof(value)
            }

            pub fn usbevent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_usbevent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_usbevent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbevent();
                f(&mut value);
                self.set_usbevent(value)
            }

            pub fn ep0setup(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ep0setup(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ep0setup_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0setup();
                f(&mut value);
                self.set_ep0setup(value)
            }

            pub fn epdata(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_epdata(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_epdata_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epdata();
                f(&mut value);
                self.set_epdata(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENSET_WRITE_VALUE {
            raw: u32,
        }

        impl INTENSET_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_usbreset(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endepin0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endepin1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepin2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepin3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endepin4(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endepin5(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endepin6(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endepin7(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ep0datadone(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_endisoin(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endepout0(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endepout1(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_endepout2(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_endepout3(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_endepout4(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_endepout5(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_endepout6(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_endepout7(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_endisoout(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_sof(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_usbevent(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ep0setup(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_epdata(&mut self) -> &mut Self {
                let value = InterruptSet::Set.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }
        }
    }

    pub mod intenclr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct INTENCLR {
            raw: RawRegister<u32>,
        }

        impl INTENCLR {
            pub fn write_with<F: Fn(&mut INTENCLR_WRITE_VALUE) -> &mut INTENCLR_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = INTENCLR_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for INTENCLR {
            type Value = INTENCLR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                INTENCLR_READ_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for INTENCLR {
            type Value = INTENCLR_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_READ_VALUE {
            raw: u32,
        }

        impl INTENCLR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn usbreset(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_usbreset(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_usbreset_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbreset();
                f(&mut value);
                self.set_usbreset(value)
            }

            pub fn started(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_started(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_started_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.started();
                f(&mut value);
                self.set_started(value)
            }

            pub fn endepin0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_endepin0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endepin0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin0();
                f(&mut value);
                self.set_endepin0(value)
            }

            pub fn endepin1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_endepin1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepin1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin1();
                f(&mut value);
                self.set_endepin1(value)
            }

            pub fn endepin2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_endepin2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepin2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin2();
                f(&mut value);
                self.set_endepin2(value)
            }

            pub fn endepin3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_endepin3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endepin3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin3();
                f(&mut value);
                self.set_endepin3(value)
            }

            pub fn endepin4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_endepin4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endepin4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin4();
                f(&mut value);
                self.set_endepin4(value)
            }

            pub fn endepin5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_endepin5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endepin5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin5();
                f(&mut value);
                self.set_endepin5(value)
            }

            pub fn endepin6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_endepin6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endepin6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin6();
                f(&mut value);
                self.set_endepin6(value)
            }

            pub fn endepin7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_endepin7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_endepin7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepin7();
                f(&mut value);
                self.set_endepin7(value)
            }

            pub fn ep0datadone(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_ep0datadone(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_ep0datadone_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0datadone();
                f(&mut value);
                self.set_ep0datadone(value)
            }

            pub fn endisoin(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_endisoin(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endisoin_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoin();
                f(&mut value);
                self.set_endisoin(value)
            }

            pub fn endepout0(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00001000) >> 12)
            }

            pub fn set_endepout0(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endepout0_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout0();
                f(&mut value);
                self.set_endepout0(value)
            }

            pub fn endepout1(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00002000) >> 13)
            }

            pub fn set_endepout1(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_endepout1_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout1();
                f(&mut value);
                self.set_endepout1(value)
            }

            pub fn endepout2(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00004000) >> 14)
            }

            pub fn set_endepout2(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_endepout2_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout2();
                f(&mut value);
                self.set_endepout2(value)
            }

            pub fn endepout3(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00008000) >> 15)
            }

            pub fn set_endepout3(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_endepout3_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout3();
                f(&mut value);
                self.set_endepout3(value)
            }

            pub fn endepout4(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_endepout4(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_endepout4_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout4();
                f(&mut value);
                self.set_endepout4(value)
            }

            pub fn endepout5(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_endepout5(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_endepout5_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout5();
                f(&mut value);
                self.set_endepout5(value)
            }

            pub fn endepout6(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_endepout6(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_endepout6_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout6();
                f(&mut value);
                self.set_endepout6(value)
            }

            pub fn endepout7(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_endepout7(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_endepout7_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endepout7();
                f(&mut value);
                self.set_endepout7(value)
            }

            pub fn endisoout(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_endisoout(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_endisoout_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.endisoout();
                f(&mut value);
                self.set_endisoout(value)
            }

            pub fn sof(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_sof(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_sof_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.sof();
                f(&mut value);
                self.set_sof(value)
            }

            pub fn usbevent(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_usbevent(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_usbevent_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbevent();
                f(&mut value);
                self.set_usbevent(value)
            }

            pub fn ep0setup(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_ep0setup(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_ep0setup_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ep0setup();
                f(&mut value);
                self.set_ep0setup(value)
            }

            pub fn epdata(&self) -> InterruptState {
                let raw = self.raw;
                InterruptState::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_epdata(&mut self, value: InterruptState) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_epdata_with<F: Fn(&mut InterruptState) -> &mut InterruptState>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epdata();
                f(&mut value);
                self.set_epdata(value)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct INTENCLR_WRITE_VALUE {
            raw: u32,
        }

        impl INTENCLR_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_usbreset(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_started(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_endepin0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_endepin1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_endepin2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_endepin3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_endepin4(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_endepin5(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_endepin6(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_endepin7(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_ep0datadone(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_endisoin(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_endepout0(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00001000) | (value << 12);
                self
            }

            pub fn set_endepout1(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00002000) | (value << 13);
                self
            }

            pub fn set_endepout2(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00004000) | (value << 14);
                self
            }

            pub fn set_endepout3(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00008000) | (value << 15);
                self
            }

            pub fn set_endepout4(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_endepout5(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_endepout6(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_endepout7(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_endisoout(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_sof(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_usbevent(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_ep0setup(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_epdata(&mut self) -> &mut Self {
                let value = InterruptClear::Clear.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }
        }
    }

    pub mod eventcause {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EVENTCAUSE {
            raw: RawRegister<u32>,
        }

        impl EVENTCAUSE {
            pub fn write_with<F: Fn(&mut EVENTCAUSE_VALUE) -> &mut EVENTCAUSE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = EVENTCAUSE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EVENTCAUSE {
            type Value = EVENTCAUSE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EVENTCAUSE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EVENTCAUSE {
            type Value = EVENTCAUSE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EVENTCAUSE_VALUE {
            raw: u32,
        }

        impl EVENTCAUSE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn isooutcrc(&self) -> ISOOUTCRC_FIELD {
                let raw = self.raw;
                ISOOUTCRC_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_isooutcrc(&mut self, value: ISOOUTCRC_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_isooutcrc_with<F: Fn(&mut ISOOUTCRC_FIELD) -> &mut ISOOUTCRC_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.isooutcrc();
                f(&mut value);
                self.set_isooutcrc(value)
            }

            pub fn suspend(&self) -> SUSPEND_FIELD {
                let raw = self.raw;
                SUSPEND_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_suspend(&mut self, value: SUSPEND_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_suspend_with<F: Fn(&mut SUSPEND_FIELD) -> &mut SUSPEND_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.suspend();
                f(&mut value);
                self.set_suspend(value)
            }

            pub fn resume(&self) -> RESUME_FIELD {
                let raw = self.raw;
                RESUME_FIELD::from_value((raw & 0x00000200) >> 9)
            }

            pub fn set_resume(&mut self, value: RESUME_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000200) | (value << 9);
                self
            }

            pub fn set_resume_with<F: Fn(&mut RESUME_FIELD) -> &mut RESUME_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.resume();
                f(&mut value);
                self.set_resume(value)
            }

            pub fn usbwuallowed(&self) -> USBWUALLOWED_FIELD {
                let raw = self.raw;
                USBWUALLOWED_FIELD::from_value((raw & 0x00000400) >> 10)
            }

            pub fn set_usbwuallowed(&mut self, value: USBWUALLOWED_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000400) | (value << 10);
                self
            }

            pub fn set_usbwuallowed_with<
                F: Fn(&mut USBWUALLOWED_FIELD) -> &mut USBWUALLOWED_FIELD,
            >(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.usbwuallowed();
                f(&mut value);
                self.set_usbwuallowed(value)
            }

            pub fn ready(&self) -> READY_FIELD {
                let raw = self.raw;
                READY_FIELD::from_value((raw & 0x00000800) >> 11)
            }

            pub fn set_ready(&mut self, value: READY_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000800) | (value << 11);
                self
            }

            pub fn set_ready_with<F: Fn(&mut READY_FIELD) -> &mut READY_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.ready();
                f(&mut value);
                self.set_ready(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ISOOUTCRC_FIELD u32 =>
                        // No error detected
                        NotDetected = 0,
        // Error detected
                        Detected = 1

                    );

        impl ISOOUTCRC_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SUSPEND_FIELD u32 =>
                        // Suspend not detected
                        NotDetected = 0,
        // Suspend detected
                        Detected = 1

                    );

        impl SUSPEND_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RESUME_FIELD u32 =>
                        // Resume not detected
                        NotDetected = 0,
        // Resume detected
                        Detected = 1

                    );

        impl RESUME_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_detected(&self) -> bool {
                *self == Self::Detected
            }

            pub fn set_detected(&mut self) -> &mut Self {
                *self = Self::Detected;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] USBWUALLOWED_FIELD u32 =>
                        // Wake up not allowed
                        NotAllowed = 0,
        // Wake up allowed
                        Allowed = 1

                    );

        impl USBWUALLOWED_FIELD {
            pub fn is_notallowed(&self) -> bool {
                *self == Self::NotAllowed
            }

            pub fn set_notallowed(&mut self) -> &mut Self {
                *self = Self::NotAllowed;
                self
            }

            pub fn is_allowed(&self) -> bool {
                *self == Self::Allowed
            }

            pub fn set_allowed(&mut self) -> &mut Self {
                *self = Self::Allowed;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] READY_FIELD u32 =>
                        // USBEVENT was not issued due to USBD peripheral ready
                        NotDetected = 0,
        // USBD peripheral is ready
                        Ready = 1

                    );

        impl READY_FIELD {
            pub fn is_notdetected(&self) -> bool {
                *self == Self::NotDetected
            }

            pub fn set_notdetected(&mut self) -> &mut Self {
                *self = Self::NotDetected;
                self
            }

            pub fn is_ready(&self) -> bool {
                *self == Self::Ready
            }

            pub fn set_ready(&mut self) -> &mut Self {
                *self = Self::Ready;
                self
            }
        }
    }

    pub mod halted {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct HALTED {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description collection: IN endpoint halted status. Can be used
            /// as is as response to a GetStatus() request to endpoint.
            pub epin: [epin::EPIN; 8],
            _padding_32: [u8; 4],
            /// Description collection: OUT endpoint halted status. Can be used
            /// as is as response to a GetStatus() request to endpoint.
            pub epout: [epout::EPOUT; 8],
        }

        pub mod epin {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct EPIN {
                raw: RawRegister<u32>,
            }

            impl EPIN {}

            impl RegisterRead for EPIN {
                type Value = EPIN_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    EPIN_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct EPIN_READ_VALUE {
                raw: u32,
            }

            impl EPIN_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn getstatus(&self) -> GETSTATUS_FIELD {
                    let raw = self.raw;
                    GETSTATUS_FIELD::from_value((raw & 0x0000ffff) >> 0)
                }

                pub fn set_getstatus(&mut self, value: GETSTATUS_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ffff) | (value << 0);
                    self
                }

                pub fn set_getstatus_with<F: Fn(&mut GETSTATUS_FIELD) -> &mut GETSTATUS_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.getstatus();
                    f(&mut value);
                    self.set_getstatus(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] GETSTATUS_FIELD u32 =>
                            // Endpoint is not halted
                            NotHalted = 0,
            // Endpoint is halted
                            Halted = 1

                        );

            impl GETSTATUS_FIELD {
                pub fn is_nothalted(&self) -> bool {
                    *self == Self::NotHalted
                }

                pub fn set_nothalted(&mut self) -> &mut Self {
                    *self = Self::NotHalted;
                    self
                }

                pub fn is_halted(&self) -> bool {
                    *self == Self::Halted
                }

                pub fn set_halted(&mut self) -> &mut Self {
                    *self = Self::Halted;
                    self
                }
            }
        }

        pub mod epout {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct EPOUT {
                raw: RawRegister<u32>,
            }

            impl EPOUT {}

            impl RegisterRead for EPOUT {
                type Value = EPOUT_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    EPOUT_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct EPOUT_READ_VALUE {
                raw: u32,
            }

            impl EPOUT_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn getstatus(&self) -> GETSTATUS_FIELD {
                    let raw = self.raw;
                    GETSTATUS_FIELD::from_value((raw & 0x0000ffff) >> 0)
                }

                pub fn set_getstatus(&mut self, value: GETSTATUS_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000ffff) | (value << 0);
                    self
                }

                pub fn set_getstatus_with<F: Fn(&mut GETSTATUS_FIELD) -> &mut GETSTATUS_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.getstatus();
                    f(&mut value);
                    self.set_getstatus(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] GETSTATUS_FIELD u32 =>
                            // Endpoint is not halted
                            NotHalted = 0,
            // Endpoint is halted
                            Halted = 1

                        );

            impl GETSTATUS_FIELD {
                pub fn is_nothalted(&self) -> bool {
                    *self == Self::NotHalted
                }

                pub fn set_nothalted(&mut self) -> &mut Self {
                    *self = Self::NotHalted;
                    self
                }

                pub fn is_halted(&self) -> bool {
                    *self == Self::Halted
                }

                pub fn set_halted(&mut self) -> &mut Self {
                    *self = Self::Halted;
                    self
                }
            }
        }
    }

    pub mod epstatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EPSTATUS {
            raw: RawRegister<u32>,
        }

        impl EPSTATUS {
            pub fn write_with<F: Fn(&mut EPSTATUS_VALUE) -> &mut EPSTATUS_VALUE>(&mut self, f: F) {
                let mut v = EPSTATUS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EPSTATUS {
            type Value = EPSTATUS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EPSTATUS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EPSTATUS {
            type Value = EPSTATUS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EPSTATUS_VALUE {
            raw: u32,
        }

        impl EPSTATUS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn epin0(&self) -> EPIN0_FIELD {
                let raw = self.raw;
                EPIN0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_epin0(&mut self, value: EPIN0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_epin0_with<F: Fn(&mut EPIN0_FIELD) -> &mut EPIN0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin0();
                f(&mut value);
                self.set_epin0(value)
            }

            pub fn epin1(&self) -> EPIN1_FIELD {
                let raw = self.raw;
                EPIN1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_epin1(&mut self, value: EPIN1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_epin1_with<F: Fn(&mut EPIN1_FIELD) -> &mut EPIN1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin1();
                f(&mut value);
                self.set_epin1(value)
            }

            pub fn epin2(&self) -> EPIN2_FIELD {
                let raw = self.raw;
                EPIN2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_epin2(&mut self, value: EPIN2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_epin2_with<F: Fn(&mut EPIN2_FIELD) -> &mut EPIN2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin2();
                f(&mut value);
                self.set_epin2(value)
            }

            pub fn epin3(&self) -> EPIN3_FIELD {
                let raw = self.raw;
                EPIN3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_epin3(&mut self, value: EPIN3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_epin3_with<F: Fn(&mut EPIN3_FIELD) -> &mut EPIN3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin3();
                f(&mut value);
                self.set_epin3(value)
            }

            pub fn epin4(&self) -> EPIN4_FIELD {
                let raw = self.raw;
                EPIN4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_epin4(&mut self, value: EPIN4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_epin4_with<F: Fn(&mut EPIN4_FIELD) -> &mut EPIN4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin4();
                f(&mut value);
                self.set_epin4(value)
            }

            pub fn epin5(&self) -> EPIN5_FIELD {
                let raw = self.raw;
                EPIN5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_epin5(&mut self, value: EPIN5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_epin5_with<F: Fn(&mut EPIN5_FIELD) -> &mut EPIN5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin5();
                f(&mut value);
                self.set_epin5(value)
            }

            pub fn epin6(&self) -> EPIN6_FIELD {
                let raw = self.raw;
                EPIN6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_epin6(&mut self, value: EPIN6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_epin6_with<F: Fn(&mut EPIN6_FIELD) -> &mut EPIN6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin6();
                f(&mut value);
                self.set_epin6(value)
            }

            pub fn epin7(&self) -> EPIN7_FIELD {
                let raw = self.raw;
                EPIN7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_epin7(&mut self, value: EPIN7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_epin7_with<F: Fn(&mut EPIN7_FIELD) -> &mut EPIN7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin7();
                f(&mut value);
                self.set_epin7(value)
            }

            pub fn epin8(&self) -> EPIN8_FIELD {
                let raw = self.raw;
                EPIN8_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_epin8(&mut self, value: EPIN8_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_epin8_with<F: Fn(&mut EPIN8_FIELD) -> &mut EPIN8_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin8();
                f(&mut value);
                self.set_epin8(value)
            }

            pub fn epout0(&self) -> EPOUT0_FIELD {
                let raw = self.raw;
                EPOUT0_FIELD::from_value((raw & 0x00010000) >> 16)
            }

            pub fn set_epout0(&mut self, value: EPOUT0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00010000) | (value << 16);
                self
            }

            pub fn set_epout0_with<F: Fn(&mut EPOUT0_FIELD) -> &mut EPOUT0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout0();
                f(&mut value);
                self.set_epout0(value)
            }

            pub fn epout1(&self) -> EPOUT1_FIELD {
                let raw = self.raw;
                EPOUT1_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_epout1(&mut self, value: EPOUT1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_epout1_with<F: Fn(&mut EPOUT1_FIELD) -> &mut EPOUT1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout1();
                f(&mut value);
                self.set_epout1(value)
            }

            pub fn epout2(&self) -> EPOUT2_FIELD {
                let raw = self.raw;
                EPOUT2_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_epout2(&mut self, value: EPOUT2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_epout2_with<F: Fn(&mut EPOUT2_FIELD) -> &mut EPOUT2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout2();
                f(&mut value);
                self.set_epout2(value)
            }

            pub fn epout3(&self) -> EPOUT3_FIELD {
                let raw = self.raw;
                EPOUT3_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_epout3(&mut self, value: EPOUT3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_epout3_with<F: Fn(&mut EPOUT3_FIELD) -> &mut EPOUT3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout3();
                f(&mut value);
                self.set_epout3(value)
            }

            pub fn epout4(&self) -> EPOUT4_FIELD {
                let raw = self.raw;
                EPOUT4_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_epout4(&mut self, value: EPOUT4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_epout4_with<F: Fn(&mut EPOUT4_FIELD) -> &mut EPOUT4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout4();
                f(&mut value);
                self.set_epout4(value)
            }

            pub fn epout5(&self) -> EPOUT5_FIELD {
                let raw = self.raw;
                EPOUT5_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_epout5(&mut self, value: EPOUT5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_epout5_with<F: Fn(&mut EPOUT5_FIELD) -> &mut EPOUT5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout5();
                f(&mut value);
                self.set_epout5(value)
            }

            pub fn epout6(&self) -> EPOUT6_FIELD {
                let raw = self.raw;
                EPOUT6_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_epout6(&mut self, value: EPOUT6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_epout6_with<F: Fn(&mut EPOUT6_FIELD) -> &mut EPOUT6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout6();
                f(&mut value);
                self.set_epout6(value)
            }

            pub fn epout7(&self) -> EPOUT7_FIELD {
                let raw = self.raw;
                EPOUT7_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_epout7(&mut self, value: EPOUT7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_epout7_with<F: Fn(&mut EPOUT7_FIELD) -> &mut EPOUT7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout7();
                f(&mut value);
                self.set_epout7(value)
            }

            pub fn epout8(&self) -> EPOUT8_FIELD {
                let raw = self.raw;
                EPOUT8_FIELD::from_value((raw & 0x01000000) >> 24)
            }

            pub fn set_epout8(&mut self, value: EPOUT8_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x01000000) | (value << 24);
                self
            }

            pub fn set_epout8_with<F: Fn(&mut EPOUT8_FIELD) -> &mut EPOUT8_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout8();
                f(&mut value);
                self.set_epout8(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN0_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN0_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN1_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN1_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN2_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN2_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN3_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN3_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN4_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN4_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN5_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN5_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN6_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN6_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN7_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN7_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN8_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPIN8_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT0_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT0_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT1_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT1_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT2_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT2_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT3_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT3_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT4_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT4_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT5_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT5_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT6_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT6_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT7_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT7_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT8_FIELD u32 =>
                        // EasyDMA registers have not been captured for this endpoint
                        NoData = 0,
        // EasyDMA registers have been captured for this endpoint
                        DataDone = 1

                    );

        impl EPOUT8_FIELD {
            pub fn is_nodata(&self) -> bool {
                *self == Self::NoData
            }

            pub fn set_nodata(&mut self) -> &mut Self {
                *self = Self::NoData;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }
    }

    pub mod epdatastatus {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EPDATASTATUS {
            raw: RawRegister<u32>,
        }

        impl EPDATASTATUS {
            pub fn write_with<F: Fn(&mut EPDATASTATUS_VALUE) -> &mut EPDATASTATUS_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = EPDATASTATUS_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EPDATASTATUS {
            type Value = EPDATASTATUS_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EPDATASTATUS_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EPDATASTATUS {
            type Value = EPDATASTATUS_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EPDATASTATUS_VALUE {
            raw: u32,
        }

        impl EPDATASTATUS_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn epin1(&self) -> EPIN1_FIELD {
                let raw = self.raw;
                EPIN1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_epin1(&mut self, value: EPIN1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_epin1_with<F: Fn(&mut EPIN1_FIELD) -> &mut EPIN1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin1();
                f(&mut value);
                self.set_epin1(value)
            }

            pub fn epin2(&self) -> EPIN2_FIELD {
                let raw = self.raw;
                EPIN2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_epin2(&mut self, value: EPIN2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_epin2_with<F: Fn(&mut EPIN2_FIELD) -> &mut EPIN2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin2();
                f(&mut value);
                self.set_epin2(value)
            }

            pub fn epin3(&self) -> EPIN3_FIELD {
                let raw = self.raw;
                EPIN3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_epin3(&mut self, value: EPIN3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_epin3_with<F: Fn(&mut EPIN3_FIELD) -> &mut EPIN3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin3();
                f(&mut value);
                self.set_epin3(value)
            }

            pub fn epin4(&self) -> EPIN4_FIELD {
                let raw = self.raw;
                EPIN4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_epin4(&mut self, value: EPIN4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_epin4_with<F: Fn(&mut EPIN4_FIELD) -> &mut EPIN4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin4();
                f(&mut value);
                self.set_epin4(value)
            }

            pub fn epin5(&self) -> EPIN5_FIELD {
                let raw = self.raw;
                EPIN5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_epin5(&mut self, value: EPIN5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_epin5_with<F: Fn(&mut EPIN5_FIELD) -> &mut EPIN5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin5();
                f(&mut value);
                self.set_epin5(value)
            }

            pub fn epin6(&self) -> EPIN6_FIELD {
                let raw = self.raw;
                EPIN6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_epin6(&mut self, value: EPIN6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_epin6_with<F: Fn(&mut EPIN6_FIELD) -> &mut EPIN6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin6();
                f(&mut value);
                self.set_epin6(value)
            }

            pub fn epin7(&self) -> EPIN7_FIELD {
                let raw = self.raw;
                EPIN7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_epin7(&mut self, value: EPIN7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_epin7_with<F: Fn(&mut EPIN7_FIELD) -> &mut EPIN7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epin7();
                f(&mut value);
                self.set_epin7(value)
            }

            pub fn epout1(&self) -> EPOUT1_FIELD {
                let raw = self.raw;
                EPOUT1_FIELD::from_value((raw & 0x00020000) >> 17)
            }

            pub fn set_epout1(&mut self, value: EPOUT1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00020000) | (value << 17);
                self
            }

            pub fn set_epout1_with<F: Fn(&mut EPOUT1_FIELD) -> &mut EPOUT1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout1();
                f(&mut value);
                self.set_epout1(value)
            }

            pub fn epout2(&self) -> EPOUT2_FIELD {
                let raw = self.raw;
                EPOUT2_FIELD::from_value((raw & 0x00040000) >> 18)
            }

            pub fn set_epout2(&mut self, value: EPOUT2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00040000) | (value << 18);
                self
            }

            pub fn set_epout2_with<F: Fn(&mut EPOUT2_FIELD) -> &mut EPOUT2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout2();
                f(&mut value);
                self.set_epout2(value)
            }

            pub fn epout3(&self) -> EPOUT3_FIELD {
                let raw = self.raw;
                EPOUT3_FIELD::from_value((raw & 0x00080000) >> 19)
            }

            pub fn set_epout3(&mut self, value: EPOUT3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00080000) | (value << 19);
                self
            }

            pub fn set_epout3_with<F: Fn(&mut EPOUT3_FIELD) -> &mut EPOUT3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout3();
                f(&mut value);
                self.set_epout3(value)
            }

            pub fn epout4(&self) -> EPOUT4_FIELD {
                let raw = self.raw;
                EPOUT4_FIELD::from_value((raw & 0x00100000) >> 20)
            }

            pub fn set_epout4(&mut self, value: EPOUT4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00100000) | (value << 20);
                self
            }

            pub fn set_epout4_with<F: Fn(&mut EPOUT4_FIELD) -> &mut EPOUT4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout4();
                f(&mut value);
                self.set_epout4(value)
            }

            pub fn epout5(&self) -> EPOUT5_FIELD {
                let raw = self.raw;
                EPOUT5_FIELD::from_value((raw & 0x00200000) >> 21)
            }

            pub fn set_epout5(&mut self, value: EPOUT5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00200000) | (value << 21);
                self
            }

            pub fn set_epout5_with<F: Fn(&mut EPOUT5_FIELD) -> &mut EPOUT5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout5();
                f(&mut value);
                self.set_epout5(value)
            }

            pub fn epout6(&self) -> EPOUT6_FIELD {
                let raw = self.raw;
                EPOUT6_FIELD::from_value((raw & 0x00400000) >> 22)
            }

            pub fn set_epout6(&mut self, value: EPOUT6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00400000) | (value << 22);
                self
            }

            pub fn set_epout6_with<F: Fn(&mut EPOUT6_FIELD) -> &mut EPOUT6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout6();
                f(&mut value);
                self.set_epout6(value)
            }

            pub fn epout7(&self) -> EPOUT7_FIELD {
                let raw = self.raw;
                EPOUT7_FIELD::from_value((raw & 0x00800000) >> 23)
            }

            pub fn set_epout7(&mut self, value: EPOUT7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00800000) | (value << 23);
                self
            }

            pub fn set_epout7_with<F: Fn(&mut EPOUT7_FIELD) -> &mut EPOUT7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.epout7();
                f(&mut value);
                self.set_epout7(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN1_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN1_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN2_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN2_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN3_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN3_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN4_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN4_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN5_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN5_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN6_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN6_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPIN7_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotDone = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        DataDone = 1

                    );

        impl EPIN7_FIELD {
            pub fn is_notdone(&self) -> bool {
                *self == Self::NotDone
            }

            pub fn set_notdone(&mut self) -> &mut Self {
                *self = Self::NotDone;
                self
            }

            pub fn is_datadone(&self) -> bool {
                *self == Self::DataDone
            }

            pub fn set_datadone(&mut self) -> &mut Self {
                *self = Self::DataDone;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT1_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT1_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT2_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT2_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT3_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT3_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT4_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT4_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT5_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT5_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT6_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT6_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] EPOUT7_FIELD u32 =>
                        // No acknowledged data transfer on this endpoint
                        NotStarted = 0,
        // Acknowledged data transfer on this endpoint has occurred
                        Started = 1

                    );

        impl EPOUT7_FIELD {
            pub fn is_notstarted(&self) -> bool {
                *self == Self::NotStarted
            }

            pub fn set_notstarted(&mut self) -> &mut Self {
                *self = Self::NotStarted;
                self
            }

            pub fn is_started(&self) -> bool {
                *self == Self::Started
            }

            pub fn set_started(&mut self) -> &mut Self {
                *self = Self::Started;
                self
            }
        }
    }

    pub mod usbaddr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct USBADDR {
            raw: RawRegister<u32>,
        }

        impl USBADDR {}

        impl RegisterRead for USBADDR {
            type Value = USBADDR_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                USBADDR_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct USBADDR_READ_VALUE {
            raw: u32,
        }

        impl USBADDR_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn addr(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x0000007f) >> 0
            }

            pub fn set_addr(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000007f) | (value << 0);
                self
            }
        }
    }

    pub mod bmrequesttype {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BMREQUESTTYPE {
            raw: RawRegister<u32>,
        }

        impl BMREQUESTTYPE {}

        impl RegisterRead for BMREQUESTTYPE {
            type Value = BMREQUESTTYPE_READ_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                BMREQUESTTYPE_READ_VALUE::from_raw(v)
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct BMREQUESTTYPE_READ_VALUE {
            raw: u32,
        }

        impl BMREQUESTTYPE_READ_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn recipient(&self) -> RECIPIENT_FIELD {
                let raw = self.raw;
                RECIPIENT_FIELD::from_value((raw & 0x0000001f) >> 0)
            }

            pub fn set_recipient(&mut self, value: RECIPIENT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn set_recipient_with<F: Fn(&mut RECIPIENT_FIELD) -> &mut RECIPIENT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.recipient();
                f(&mut value);
                self.set_recipient(value)
            }

            pub fn r#type(&self) -> TYPE_FIELD {
                let raw = self.raw;
                TYPE_FIELD::from_value((raw & 0x00000060) >> 5)
            }

            pub fn set_type(&mut self, value: TYPE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000060) | (value << 5);
                self
            }

            pub fn set_type_with<F: Fn(&mut TYPE_FIELD) -> &mut TYPE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.r#type();
                f(&mut value);
                self.set_type(value)
            }

            pub fn direction(&self) -> DIRECTION_FIELD {
                let raw = self.raw;
                DIRECTION_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_direction(&mut self, value: DIRECTION_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_direction_with<F: Fn(&mut DIRECTION_FIELD) -> &mut DIRECTION_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.direction();
                f(&mut value);
                self.set_direction(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RECIPIENT_FIELD u32 =>
                        // Device
                        Device = 0,
        // Interface
                        Interface = 1,
        // Endpoint
                        Endpoint = 2,
        // Other
                        Other = 3

                    );

        impl RECIPIENT_FIELD {
            pub fn is_device(&self) -> bool {
                *self == Self::Device
            }

            pub fn set_device(&mut self) -> &mut Self {
                *self = Self::Device;
                self
            }

            pub fn is_interface(&self) -> bool {
                *self == Self::Interface
            }

            pub fn set_interface(&mut self) -> &mut Self {
                *self = Self::Interface;
                self
            }

            pub fn is_endpoint(&self) -> bool {
                *self == Self::Endpoint
            }

            pub fn set_endpoint(&mut self) -> &mut Self {
                *self = Self::Endpoint;
                self
            }

            pub fn is_other(&self) -> bool {
                *self == Self::Other
            }

            pub fn set_other(&mut self) -> &mut Self {
                *self = Self::Other;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] TYPE_FIELD u32 =>
                        // Standard
                        Standard = 0,
        // Class
                        Class = 1,
        // Vendor
                        Vendor = 2

                    );

        impl TYPE_FIELD {
            pub fn is_standard(&self) -> bool {
                *self == Self::Standard
            }

            pub fn set_standard(&mut self) -> &mut Self {
                *self = Self::Standard;
                self
            }

            pub fn is_class(&self) -> bool {
                *self == Self::Class
            }

            pub fn set_class(&mut self) -> &mut Self {
                *self = Self::Class;
                self
            }

            pub fn is_vendor(&self) -> bool {
                *self == Self::Vendor
            }

            pub fn set_vendor(&mut self) -> &mut Self {
                *self = Self::Vendor;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] DIRECTION_FIELD u32 =>
                        // Host-to-device
                        HostToDevice = 0,
        // Device-to-host
                        DeviceToHost = 1

                    );

        impl DIRECTION_FIELD {
            pub fn is_hosttodevice(&self) -> bool {
                *self == Self::HostToDevice
            }

            pub fn set_hosttodevice(&mut self) -> &mut Self {
                *self = Self::HostToDevice;
                self
            }

            pub fn is_devicetohost(&self) -> bool {
                *self == Self::DeviceToHost
            }

            pub fn set_devicetohost(&mut self) -> &mut Self {
                *self = Self::DeviceToHost;
                self
            }
        }
    }

    pub mod brequest {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct BREQUEST {
            raw: RawRegister<u32>,
        }

        impl BREQUEST {}

        impl RegisterRead for BREQUEST {
            type Value = BREQUEST_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                BREQUEST_FIELD::from_value((raw & 0x000000ff) >> 0)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] BREQUEST_FIELD u32 =>
                        // Standard request GET_STATUS
                        STD_GET_STATUS = 0,
        // Standard request CLEAR_FEATURE
                        STD_CLEAR_FEATURE = 1,
        // Standard request SET_FEATURE
                        STD_SET_FEATURE = 3,
        // Standard request SET_ADDRESS
                        STD_SET_ADDRESS = 5,
        // Standard request GET_DESCRIPTOR
                        STD_GET_DESCRIPTOR = 6,
        // Standard request SET_DESCRIPTOR
                        STD_SET_DESCRIPTOR = 7,
        // Standard request GET_CONFIGURATION
                        STD_GET_CONFIGURATION = 8,
        // Standard request SET_CONFIGURATION
                        STD_SET_CONFIGURATION = 9,
        // Standard request GET_INTERFACE
                        STD_GET_INTERFACE = 10,
        // Standard request SET_INTERFACE
                        STD_SET_INTERFACE = 11,
        // Standard request SYNCH_FRAME
                        STD_SYNCH_FRAME = 12

                    );

        impl BREQUEST_FIELD {
            pub fn is_std_get_status(&self) -> bool {
                *self == Self::STD_GET_STATUS
            }

            pub fn set_std_get_status(&mut self) -> &mut Self {
                *self = Self::STD_GET_STATUS;
                self
            }

            pub fn is_std_clear_feature(&self) -> bool {
                *self == Self::STD_CLEAR_FEATURE
            }

            pub fn set_std_clear_feature(&mut self) -> &mut Self {
                *self = Self::STD_CLEAR_FEATURE;
                self
            }

            pub fn is_std_set_feature(&self) -> bool {
                *self == Self::STD_SET_FEATURE
            }

            pub fn set_std_set_feature(&mut self) -> &mut Self {
                *self = Self::STD_SET_FEATURE;
                self
            }

            pub fn is_std_set_address(&self) -> bool {
                *self == Self::STD_SET_ADDRESS
            }

            pub fn set_std_set_address(&mut self) -> &mut Self {
                *self = Self::STD_SET_ADDRESS;
                self
            }

            pub fn is_std_get_descriptor(&self) -> bool {
                *self == Self::STD_GET_DESCRIPTOR
            }

            pub fn set_std_get_descriptor(&mut self) -> &mut Self {
                *self = Self::STD_GET_DESCRIPTOR;
                self
            }

            pub fn is_std_set_descriptor(&self) -> bool {
                *self == Self::STD_SET_DESCRIPTOR
            }

            pub fn set_std_set_descriptor(&mut self) -> &mut Self {
                *self = Self::STD_SET_DESCRIPTOR;
                self
            }

            pub fn is_std_get_configuration(&self) -> bool {
                *self == Self::STD_GET_CONFIGURATION
            }

            pub fn set_std_get_configuration(&mut self) -> &mut Self {
                *self = Self::STD_GET_CONFIGURATION;
                self
            }

            pub fn is_std_set_configuration(&self) -> bool {
                *self == Self::STD_SET_CONFIGURATION
            }

            pub fn set_std_set_configuration(&mut self) -> &mut Self {
                *self = Self::STD_SET_CONFIGURATION;
                self
            }

            pub fn is_std_get_interface(&self) -> bool {
                *self == Self::STD_GET_INTERFACE
            }

            pub fn set_std_get_interface(&mut self) -> &mut Self {
                *self = Self::STD_GET_INTERFACE;
                self
            }

            pub fn is_std_set_interface(&self) -> bool {
                *self == Self::STD_SET_INTERFACE
            }

            pub fn set_std_set_interface(&mut self) -> &mut Self {
                *self = Self::STD_SET_INTERFACE;
                self
            }

            pub fn is_std_synch_frame(&self) -> bool {
                *self == Self::STD_SYNCH_FRAME
            }

            pub fn set_std_synch_frame(&mut self) -> &mut Self {
                *self = Self::STD_SYNCH_FRAME;
                self
            }
        }
    }

    pub mod wvaluel {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WVALUEL {
            raw: RawRegister<u32>,
        }

        impl WVALUEL {}

        impl RegisterRead for WVALUEL {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod wvalueh {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WVALUEH {
            raw: RawRegister<u32>,
        }

        impl WVALUEH {}

        impl RegisterRead for WVALUEH {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod windexl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WINDEXL {
            raw: RawRegister<u32>,
        }

        impl WINDEXL {}

        impl RegisterRead for WINDEXL {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod windexh {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WINDEXH {
            raw: RawRegister<u32>,
        }

        impl WINDEXH {}

        impl RegisterRead for WINDEXH {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod wlengthl {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WLENGTHL {
            raw: RawRegister<u32>,
        }

        impl WLENGTHL {}

        impl RegisterRead for WLENGTHL {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod wlengthh {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct WLENGTHH {
            raw: RawRegister<u32>,
        }

        impl WLENGTHH {}

        impl RegisterRead for WLENGTHH {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000000ff) >> 0
            }
        }
    }

    pub mod size {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct SIZE {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description collection: Number of bytes received last in the
            /// data stage of this OUT endpoint
            pub epout: [epout::EPOUT; 8],
            /// Number of bytes received last on this ISO OUT data endpoint
            pub isoout: isoout::ISOOUT,
        }

        pub mod epout {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct EPOUT {
                raw: RawRegister<u32>,
            }

            impl EPOUT {
                pub fn write_with<F: Fn(&mut EPOUT_VALUE) -> &mut EPOUT_VALUE>(&mut self, f: F) {
                    let mut v = EPOUT_VALUE::new();
                    f(&mut v);
                    self.write(v);
                }
            }

            impl RegisterRead for EPOUT {
                type Value = EPOUT_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    EPOUT_VALUE::from_raw(v)
                }
            }

            impl RegisterWrite for EPOUT {
                type Value = EPOUT_VALUE;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    self.raw.write(value.to_raw());
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct EPOUT_VALUE {
                raw: u32,
            }

            impl EPOUT_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn size(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x0000007f) >> 0
                }

                pub fn set_size(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x0000007f) | (value << 0);
                    self
                }
            }
        }

        pub mod isoout {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct ISOOUT {
                raw: RawRegister<u32>,
            }

            impl ISOOUT {}

            impl RegisterRead for ISOOUT {
                type Value = ISOOUT_READ_VALUE;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let v = self.raw.read();
                    ISOOUT_READ_VALUE::from_raw(v)
                }
            }

            #[derive(Clone, Copy, PartialEq)]
            pub struct ISOOUT_READ_VALUE {
                raw: u32,
            }

            impl ISOOUT_READ_VALUE {
                pub fn new() -> Self {
                    Self { raw: 0 }
                }

                #[inline(always)]
                pub fn from_raw(raw: u32) -> Self {
                    Self { raw }
                }

                #[inline(always)]
                pub fn to_raw(&self) -> u32 {
                    self.raw
                }

                pub fn size(&self) -> u32 {
                    let raw = self.raw;
                    (raw & 0x000003ff) >> 0
                }

                pub fn set_size(&mut self, value: u32) -> &mut Self {
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x000003ff) | (value << 0);
                    self
                }

                pub fn zero(&self) -> ZERO_FIELD {
                    let raw = self.raw;
                    ZERO_FIELD::from_value((raw & 0x00010000) >> 16)
                }

                pub fn set_zero(&mut self, value: ZERO_FIELD) -> &mut Self {
                    let value = value.to_value();
                    let old_raw = self.raw;
                    self.raw = (old_raw & !0x00010000) | (value << 16);
                    self
                }

                pub fn set_zero_with<F: Fn(&mut ZERO_FIELD) -> &mut ZERO_FIELD>(
                    &mut self,
                    f: F,
                ) -> &mut Self {
                    let mut value = self.zero();
                    f(&mut value);
                    self.set_zero(value)
                }
            }

            enum_def_with_unknown!(#[allow(non_camel_case_types)] ZERO_FIELD u32 =>
                            // No zero-length data received, use value in SIZE
                            Normal = 0,
            // Zero-length data received, ignore value in SIZE
                            ZeroData = 1

                        );

            impl ZERO_FIELD {
                pub fn is_normal(&self) -> bool {
                    *self == Self::Normal
                }

                pub fn set_normal(&mut self) -> &mut Self {
                    *self = Self::Normal;
                    self
                }

                pub fn is_zerodata(&self) -> bool {
                    *self == Self::ZeroData
                }

                pub fn set_zerodata(&mut self) -> &mut Self {
                    *self = Self::ZeroData;
                    self
                }
            }
        }
    }

    pub mod enable {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ENABLE {
            raw: RawRegister<u32>,
        }

        impl ENABLE {
            pub fn write_disabled(&mut self) {
                self.write(ENABLE_FIELD::Disabled)
            }

            pub fn write_enabled(&mut self) {
                self.write(ENABLE_FIELD::Enabled)
            }
        }

        impl RegisterRead for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                ENABLE_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for ENABLE {
            type Value = ENABLE_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ENABLE_FIELD u32 =>
                        // USB peripheral is disabled
                        Disabled = 0,
        // USB peripheral is enabled
                        Enabled = 1

                    );

        impl ENABLE_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod usbpullup {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct USBPULLUP {
            raw: RawRegister<u32>,
        }

        impl USBPULLUP {
            pub fn write_with<F: Fn(&mut USBPULLUP_VALUE) -> &mut USBPULLUP_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = USBPULLUP_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for USBPULLUP {
            type Value = USBPULLUP_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                USBPULLUP_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for USBPULLUP {
            type Value = USBPULLUP_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct USBPULLUP_VALUE {
            raw: u32,
        }

        impl USBPULLUP_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn connect(&self) -> CONNECT_FIELD {
                let raw = self.raw;
                CONNECT_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_connect(&mut self, value: CONNECT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_connect_with<F: Fn(&mut CONNECT_FIELD) -> &mut CONNECT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.connect();
                f(&mut value);
                self.set_connect(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] CONNECT_FIELD u32 =>
                        // Pull-up is disconnected
                        Disabled = 0,
        // Pull-up is connected to D+
                        Enabled = 1

                    );

        impl CONNECT_FIELD {
            pub fn is_disabled(&self) -> bool {
                *self == Self::Disabled
            }

            pub fn set_disabled(&mut self) -> &mut Self {
                *self = Self::Disabled;
                self
            }

            pub fn is_enabled(&self) -> bool {
                *self == Self::Enabled
            }

            pub fn set_enabled(&mut self) -> &mut Self {
                *self = Self::Enabled;
                self
            }
        }
    }

    pub mod dpdmvalue {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DPDMVALUE {
            raw: RawRegister<u32>,
        }

        impl DPDMVALUE {
            pub fn write_with<F: Fn(&mut DPDMVALUE_VALUE) -> &mut DPDMVALUE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = DPDMVALUE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DPDMVALUE {
            type Value = DPDMVALUE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DPDMVALUE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DPDMVALUE {
            type Value = DPDMVALUE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DPDMVALUE_VALUE {
            raw: u32,
        }

        impl DPDMVALUE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn state(&self) -> STATE_FIELD {
                let raw = self.raw;
                STATE_FIELD::from_value((raw & 0x0000001f) >> 0)
            }

            pub fn set_state(&mut self, value: STATE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000001f) | (value << 0);
                self
            }

            pub fn set_state_with<F: Fn(&mut STATE_FIELD) -> &mut STATE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.state();
                f(&mut value);
                self.set_state(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STATE_FIELD u32 =>
                        // D+ forced low, D- forced high (K state) for a timing preset in hardware (50 us or 5 ms, depending on bus state)
                        Resume = 1,
        // D+ forced high, D- forced low (J state)
                        J = 2,
        // D+ forced low, D- forced high (K state)
                        K = 4

                    );

        impl STATE_FIELD {
            pub fn is_resume(&self) -> bool {
                *self == Self::Resume
            }

            pub fn set_resume(&mut self) -> &mut Self {
                *self = Self::Resume;
                self
            }

            pub fn is_j(&self) -> bool {
                *self == Self::J
            }

            pub fn set_j(&mut self) -> &mut Self {
                *self = Self::J;
                self
            }

            pub fn is_k(&self) -> bool {
                *self == Self::K
            }

            pub fn set_k(&mut self) -> &mut Self {
                *self = Self::K;
                self
            }
        }
    }

    pub mod dtoggle {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct DTOGGLE {
            raw: RawRegister<u32>,
        }

        impl DTOGGLE {
            pub fn write_with<F: Fn(&mut DTOGGLE_VALUE) -> &mut DTOGGLE_VALUE>(&mut self, f: F) {
                let mut v = DTOGGLE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for DTOGGLE {
            type Value = DTOGGLE_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                DTOGGLE_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for DTOGGLE {
            type Value = DTOGGLE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct DTOGGLE_VALUE {
            raw: u32,
        }

        impl DTOGGLE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn ep(&self) -> u32 {
                let raw = self.raw;
                (raw & 0x00000007) >> 0
            }

            pub fn set_ep(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn io(&self) -> IO_FIELD {
                let raw = self.raw;
                IO_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_io(&mut self, value: IO_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_io_with<F: Fn(&mut IO_FIELD) -> &mut IO_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.io();
                f(&mut value);
                self.set_io(value)
            }

            pub fn value(&self) -> VALUE_FIELD {
                let raw = self.raw;
                VALUE_FIELD::from_value((raw & 0x00000300) >> 8)
            }

            pub fn set_value(&mut self, value: VALUE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000300) | (value << 8);
                self
            }

            pub fn set_value_with<F: Fn(&mut VALUE_FIELD) -> &mut VALUE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.value();
                f(&mut value);
                self.set_value(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IO_FIELD u32 =>
                        // Selects OUT endpoint
                        Out = 0,
        // Selects IN endpoint
                        In = 1

                    );

        impl IO_FIELD {
            pub fn is_out(&self) -> bool {
                *self == Self::Out
            }

            pub fn set_out(&mut self) -> &mut Self {
                *self = Self::Out;
                self
            }

            pub fn is_in(&self) -> bool {
                *self == Self::In
            }

            pub fn set_in(&mut self) -> &mut Self {
                *self = Self::In;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] VALUE_FIELD u32 =>
                        // No action on data toggle when writing the register with this value
                        Nop = 0,
        // Data toggle is DATA0 on endpoint set by EP and IO
                        Data0 = 1,
        // Data toggle is DATA1 on endpoint set by EP and IO
                        Data1 = 2

                    );

        impl VALUE_FIELD {
            pub fn is_nop(&self) -> bool {
                *self == Self::Nop
            }

            pub fn set_nop(&mut self) -> &mut Self {
                *self = Self::Nop;
                self
            }

            pub fn is_data0(&self) -> bool {
                *self == Self::Data0
            }

            pub fn set_data0(&mut self) -> &mut Self {
                *self = Self::Data0;
                self
            }

            pub fn is_data1(&self) -> bool {
                *self == Self::Data1
            }

            pub fn set_data1(&mut self) -> &mut Self {
                *self = Self::Data1;
                self
            }
        }
    }

    pub mod epinen {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EPINEN {
            raw: RawRegister<u32>,
        }

        impl EPINEN {
            pub fn write_with<F: Fn(&mut EPINEN_VALUE) -> &mut EPINEN_VALUE>(&mut self, f: F) {
                let mut v = EPINEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EPINEN {
            type Value = EPINEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EPINEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EPINEN {
            type Value = EPINEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EPINEN_VALUE {
            raw: u32,
        }

        impl EPINEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn in0(&self) -> IN0_FIELD {
                let raw = self.raw;
                IN0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_in0(&mut self, value: IN0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_in0_with<F: Fn(&mut IN0_FIELD) -> &mut IN0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in0();
                f(&mut value);
                self.set_in0(value)
            }

            pub fn in1(&self) -> IN1_FIELD {
                let raw = self.raw;
                IN1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_in1(&mut self, value: IN1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_in1_with<F: Fn(&mut IN1_FIELD) -> &mut IN1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in1();
                f(&mut value);
                self.set_in1(value)
            }

            pub fn in2(&self) -> IN2_FIELD {
                let raw = self.raw;
                IN2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_in2(&mut self, value: IN2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_in2_with<F: Fn(&mut IN2_FIELD) -> &mut IN2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in2();
                f(&mut value);
                self.set_in2(value)
            }

            pub fn in3(&self) -> IN3_FIELD {
                let raw = self.raw;
                IN3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_in3(&mut self, value: IN3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_in3_with<F: Fn(&mut IN3_FIELD) -> &mut IN3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in3();
                f(&mut value);
                self.set_in3(value)
            }

            pub fn in4(&self) -> IN4_FIELD {
                let raw = self.raw;
                IN4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_in4(&mut self, value: IN4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_in4_with<F: Fn(&mut IN4_FIELD) -> &mut IN4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in4();
                f(&mut value);
                self.set_in4(value)
            }

            pub fn in5(&self) -> IN5_FIELD {
                let raw = self.raw;
                IN5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_in5(&mut self, value: IN5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_in5_with<F: Fn(&mut IN5_FIELD) -> &mut IN5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in5();
                f(&mut value);
                self.set_in5(value)
            }

            pub fn in6(&self) -> IN6_FIELD {
                let raw = self.raw;
                IN6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_in6(&mut self, value: IN6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_in6_with<F: Fn(&mut IN6_FIELD) -> &mut IN6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in6();
                f(&mut value);
                self.set_in6(value)
            }

            pub fn in7(&self) -> IN7_FIELD {
                let raw = self.raw;
                IN7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_in7(&mut self, value: IN7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_in7_with<F: Fn(&mut IN7_FIELD) -> &mut IN7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.in7();
                f(&mut value);
                self.set_in7(value)
            }

            pub fn isoin(&self) -> ISOIN_FIELD {
                let raw = self.raw;
                ISOIN_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_isoin(&mut self, value: ISOIN_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_isoin_with<F: Fn(&mut ISOIN_FIELD) -> &mut ISOIN_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.isoin();
                f(&mut value);
                self.set_isoin(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN0_FIELD u32 =>
                        // Disable endpoint IN 0 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 0 (response to IN tokens)
                        Enable = 1

                    );

        impl IN0_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN1_FIELD u32 =>
                        // Disable endpoint IN 1 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 1 (response to IN tokens)
                        Enable = 1

                    );

        impl IN1_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN2_FIELD u32 =>
                        // Disable endpoint IN 2 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 2 (response to IN tokens)
                        Enable = 1

                    );

        impl IN2_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN3_FIELD u32 =>
                        // Disable endpoint IN 3 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 3 (response to IN tokens)
                        Enable = 1

                    );

        impl IN3_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN4_FIELD u32 =>
                        // Disable endpoint IN 4 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 4 (response to IN tokens)
                        Enable = 1

                    );

        impl IN4_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN5_FIELD u32 =>
                        // Disable endpoint IN 5 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 5 (response to IN tokens)
                        Enable = 1

                    );

        impl IN5_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN6_FIELD u32 =>
                        // Disable endpoint IN 6 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 6 (response to IN tokens)
                        Enable = 1

                    );

        impl IN6_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IN7_FIELD u32 =>
                        // Disable endpoint IN 7 (no response to IN tokens)
                        Disable = 0,
        // Enable endpoint IN 7 (response to IN tokens)
                        Enable = 1

                    );

        impl IN7_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ISOIN_FIELD u32 =>
                        // Disable ISO IN endpoint 8
                        Disable = 0,
        // Enable ISO IN endpoint 8
                        Enable = 1

                    );

        impl ISOIN_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }
    }

    pub mod epouten {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EPOUTEN {
            raw: RawRegister<u32>,
        }

        impl EPOUTEN {
            pub fn write_with<F: Fn(&mut EPOUTEN_VALUE) -> &mut EPOUTEN_VALUE>(&mut self, f: F) {
                let mut v = EPOUTEN_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for EPOUTEN {
            type Value = EPOUTEN_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                EPOUTEN_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for EPOUTEN {
            type Value = EPOUTEN_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EPOUTEN_VALUE {
            raw: u32,
        }

        impl EPOUTEN_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn out0(&self) -> OUT0_FIELD {
                let raw = self.raw;
                OUT0_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_out0(&mut self, value: OUT0_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_out0_with<F: Fn(&mut OUT0_FIELD) -> &mut OUT0_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out0();
                f(&mut value);
                self.set_out0(value)
            }

            pub fn out1(&self) -> OUT1_FIELD {
                let raw = self.raw;
                OUT1_FIELD::from_value((raw & 0x00000002) >> 1)
            }

            pub fn set_out1(&mut self, value: OUT1_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000002) | (value << 1);
                self
            }

            pub fn set_out1_with<F: Fn(&mut OUT1_FIELD) -> &mut OUT1_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out1();
                f(&mut value);
                self.set_out1(value)
            }

            pub fn out2(&self) -> OUT2_FIELD {
                let raw = self.raw;
                OUT2_FIELD::from_value((raw & 0x00000004) >> 2)
            }

            pub fn set_out2(&mut self, value: OUT2_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000004) | (value << 2);
                self
            }

            pub fn set_out2_with<F: Fn(&mut OUT2_FIELD) -> &mut OUT2_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out2();
                f(&mut value);
                self.set_out2(value)
            }

            pub fn out3(&self) -> OUT3_FIELD {
                let raw = self.raw;
                OUT3_FIELD::from_value((raw & 0x00000008) >> 3)
            }

            pub fn set_out3(&mut self, value: OUT3_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000008) | (value << 3);
                self
            }

            pub fn set_out3_with<F: Fn(&mut OUT3_FIELD) -> &mut OUT3_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out3();
                f(&mut value);
                self.set_out3(value)
            }

            pub fn out4(&self) -> OUT4_FIELD {
                let raw = self.raw;
                OUT4_FIELD::from_value((raw & 0x00000010) >> 4)
            }

            pub fn set_out4(&mut self, value: OUT4_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000010) | (value << 4);
                self
            }

            pub fn set_out4_with<F: Fn(&mut OUT4_FIELD) -> &mut OUT4_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out4();
                f(&mut value);
                self.set_out4(value)
            }

            pub fn out5(&self) -> OUT5_FIELD {
                let raw = self.raw;
                OUT5_FIELD::from_value((raw & 0x00000020) >> 5)
            }

            pub fn set_out5(&mut self, value: OUT5_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000020) | (value << 5);
                self
            }

            pub fn set_out5_with<F: Fn(&mut OUT5_FIELD) -> &mut OUT5_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out5();
                f(&mut value);
                self.set_out5(value)
            }

            pub fn out6(&self) -> OUT6_FIELD {
                let raw = self.raw;
                OUT6_FIELD::from_value((raw & 0x00000040) >> 6)
            }

            pub fn set_out6(&mut self, value: OUT6_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000040) | (value << 6);
                self
            }

            pub fn set_out6_with<F: Fn(&mut OUT6_FIELD) -> &mut OUT6_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out6();
                f(&mut value);
                self.set_out6(value)
            }

            pub fn out7(&self) -> OUT7_FIELD {
                let raw = self.raw;
                OUT7_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_out7(&mut self, value: OUT7_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_out7_with<F: Fn(&mut OUT7_FIELD) -> &mut OUT7_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.out7();
                f(&mut value);
                self.set_out7(value)
            }

            pub fn isoout(&self) -> ISOOUT_FIELD {
                let raw = self.raw;
                ISOOUT_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_isoout(&mut self, value: ISOOUT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_isoout_with<F: Fn(&mut ISOOUT_FIELD) -> &mut ISOOUT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.isoout();
                f(&mut value);
                self.set_isoout(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT0_FIELD u32 =>
                        // Disable endpoint OUT 0 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 0 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT0_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT1_FIELD u32 =>
                        // Disable endpoint OUT 1 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 1 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT1_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT2_FIELD u32 =>
                        // Disable endpoint OUT 2 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 2 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT2_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT3_FIELD u32 =>
                        // Disable endpoint OUT 3 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 3 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT3_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT4_FIELD u32 =>
                        // Disable endpoint OUT 4 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 4 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT4_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT5_FIELD u32 =>
                        // Disable endpoint OUT 5 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 5 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT5_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT6_FIELD u32 =>
                        // Disable endpoint OUT 6 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 6 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT6_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] OUT7_FIELD u32 =>
                        // Disable endpoint OUT 7 (no response to OUT tokens)
                        Disable = 0,
        // Enable endpoint OUT 7 (response to OUT tokens)
                        Enable = 1

                    );

        impl OUT7_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] ISOOUT_FIELD u32 =>
                        // Disable ISO OUT endpoint 8
                        Disable = 0,
        // Enable ISO OUT endpoint 8
                        Enable = 1

                    );

        impl ISOOUT_FIELD {
            pub fn is_disable(&self) -> bool {
                *self == Self::Disable
            }

            pub fn set_disable(&mut self) -> &mut Self {
                *self = Self::Disable;
                self
            }

            pub fn is_enable(&self) -> bool {
                *self == Self::Enable
            }

            pub fn set_enable(&mut self) -> &mut Self {
                *self = Self::Enable;
                self
            }
        }
    }

    pub mod epstall {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct EPSTALL {
            raw: RawRegister<u32>,
        }

        impl EPSTALL {
            pub fn write_with<F: Fn(&mut EPSTALL_WRITE_VALUE) -> &mut EPSTALL_WRITE_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = EPSTALL_WRITE_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterWrite for EPSTALL {
            type Value = EPSTALL_WRITE_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct EPSTALL_WRITE_VALUE {
            raw: u32,
        }

        impl EPSTALL_WRITE_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn set_ep(&mut self, value: u32) -> &mut Self {
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000007) | (value << 0);
                self
            }

            pub fn io(&self) -> IO_FIELD {
                let raw = self.raw;
                IO_FIELD::from_value((raw & 0x00000080) >> 7)
            }

            pub fn set_io(&mut self, value: IO_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000080) | (value << 7);
                self
            }

            pub fn set_io_with<F: Fn(&mut IO_FIELD) -> &mut IO_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.io();
                f(&mut value);
                self.set_io(value)
            }

            pub fn stall(&self) -> STALL_FIELD {
                let raw = self.raw;
                STALL_FIELD::from_value((raw & 0x00000100) >> 8)
            }

            pub fn set_stall(&mut self, value: STALL_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000100) | (value << 8);
                self
            }

            pub fn set_stall_with<F: Fn(&mut STALL_FIELD) -> &mut STALL_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.stall();
                f(&mut value);
                self.set_stall(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] IO_FIELD u32 =>
                        // Selects OUT endpoint
                        Out = 0,
        // Selects IN endpoint
                        In = 1

                    );

        impl IO_FIELD {
            pub fn is_out(&self) -> bool {
                *self == Self::Out
            }

            pub fn set_out(&mut self) -> &mut Self {
                *self = Self::Out;
                self
            }

            pub fn is_in(&self) -> bool {
                *self == Self::In
            }

            pub fn set_in(&mut self) -> &mut Self {
                *self = Self::In;
                self
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] STALL_FIELD u32 =>
                        // Don't stall selected endpoint
                        UnStall = 0,
        // Stall selected endpoint
                        Stall = 1

                    );

        impl STALL_FIELD {
            pub fn is_unstall(&self) -> bool {
                *self == Self::UnStall
            }

            pub fn set_unstall(&mut self) -> &mut Self {
                *self = Self::UnStall;
                self
            }

            pub fn is_stall(&self) -> bool {
                *self == Self::Stall
            }

            pub fn set_stall(&mut self) -> &mut Self {
                *self = Self::Stall;
                self
            }
        }
    }

    pub mod isosplit {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ISOSPLIT {
            raw: RawRegister<u32>,
        }

        impl ISOSPLIT {
            pub fn write_with<F: Fn(&mut ISOSPLIT_VALUE) -> &mut ISOSPLIT_VALUE>(&mut self, f: F) {
                let mut v = ISOSPLIT_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ISOSPLIT {
            type Value = ISOSPLIT_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ISOSPLIT_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ISOSPLIT {
            type Value = ISOSPLIT_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ISOSPLIT_VALUE {
            raw: u32,
        }

        impl ISOSPLIT_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn split(&self) -> SPLIT_FIELD {
                let raw = self.raw;
                SPLIT_FIELD::from_value((raw & 0x0000ffff) >> 0)
            }

            pub fn set_split(&mut self, value: SPLIT_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x0000ffff) | (value << 0);
                self
            }

            pub fn set_split_with<F: Fn(&mut SPLIT_FIELD) -> &mut SPLIT_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.split();
                f(&mut value);
                self.set_split(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] SPLIT_FIELD u32 =>
                        // Full buffer dedicated to either ISO IN or OUT
                        OneDir = 0,
        // Lower half for IN, upper half for OUT
                        HalfIN = 128

                    );

        impl SPLIT_FIELD {
            pub fn is_onedir(&self) -> bool {
                *self == Self::OneDir
            }

            pub fn set_onedir(&mut self) -> &mut Self {
                *self = Self::OneDir;
                self
            }

            pub fn is_halfin(&self) -> bool {
                *self == Self::HalfIN
            }

            pub fn set_halfin(&mut self) -> &mut Self {
                *self = Self::HalfIN;
                self
            }
        }
    }

    pub mod framecntr {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct FRAMECNTR {
            raw: RawRegister<u32>,
        }

        impl FRAMECNTR {}

        impl RegisterRead for FRAMECNTR {
            type Value = u32;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                (raw & 0x000007ff) >> 0
            }
        }
    }

    pub mod lowpower {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct LOWPOWER {
            raw: RawRegister<u32>,
        }

        impl LOWPOWER {
            pub fn write_forcenormal(&mut self) {
                self.write(LOWPOWER_FIELD::ForceNormal)
            }

            pub fn write_lowpower(&mut self) {
                self.write(LOWPOWER_FIELD::LowPower)
            }
        }

        impl RegisterRead for LOWPOWER {
            type Value = LOWPOWER_FIELD;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let raw = self.raw.read();
                LOWPOWER_FIELD::from_value((raw & 0x00000001) >> 0)
            }
        }

        impl RegisterWrite for LOWPOWER {
            type Value = LOWPOWER_FIELD;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                let old_raw = 0;
                let raw = value.to_value();
                self.raw.write(raw);
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] LOWPOWER_FIELD u32 =>
                        // Software must write this value to exit low power mode and before performing a remote wake-up
                        ForceNormal = 0,
        // Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral
                        LowPower = 1

                    );

        impl LOWPOWER_FIELD {
            pub fn is_forcenormal(&self) -> bool {
                *self == Self::ForceNormal
            }

            pub fn set_forcenormal(&mut self) -> &mut Self {
                *self = Self::ForceNormal;
                self
            }

            pub fn is_lowpower(&self) -> bool {
                *self == Self::LowPower
            }

            pub fn set_lowpower(&mut self) -> &mut Self {
                *self = Self::LowPower;
                self
            }
        }
    }

    pub mod isoinconfig {
        #[allow(unused_imports)]
        use super::*;

        #[allow(non_camel_case_types)]
        #[repr(transparent)]
        pub struct ISOINCONFIG {
            raw: RawRegister<u32>,
        }

        impl ISOINCONFIG {
            pub fn write_with<F: Fn(&mut ISOINCONFIG_VALUE) -> &mut ISOINCONFIG_VALUE>(
                &mut self,
                f: F,
            ) {
                let mut v = ISOINCONFIG_VALUE::new();
                f(&mut v);
                self.write(v);
            }
        }

        impl RegisterRead for ISOINCONFIG {
            type Value = ISOINCONFIG_VALUE;

            #[inline(always)]
            fn read(&self) -> Self::Value {
                let v = self.raw.read();
                ISOINCONFIG_VALUE::from_raw(v)
            }
        }

        impl RegisterWrite for ISOINCONFIG {
            type Value = ISOINCONFIG_VALUE;

            #[inline(always)]
            fn write(&mut self, value: Self::Value) {
                self.raw.write(value.to_raw());
            }
        }

        #[derive(Clone, Copy, PartialEq)]
        pub struct ISOINCONFIG_VALUE {
            raw: u32,
        }

        impl ISOINCONFIG_VALUE {
            pub fn new() -> Self {
                Self { raw: 0 }
            }

            #[inline(always)]
            pub fn from_raw(raw: u32) -> Self {
                Self { raw }
            }

            #[inline(always)]
            pub fn to_raw(&self) -> u32 {
                self.raw
            }

            pub fn response(&self) -> RESPONSE_FIELD {
                let raw = self.raw;
                RESPONSE_FIELD::from_value((raw & 0x00000001) >> 0)
            }

            pub fn set_response(&mut self, value: RESPONSE_FIELD) -> &mut Self {
                let value = value.to_value();
                let old_raw = self.raw;
                self.raw = (old_raw & !0x00000001) | (value << 0);
                self
            }

            pub fn set_response_with<F: Fn(&mut RESPONSE_FIELD) -> &mut RESPONSE_FIELD>(
                &mut self,
                f: F,
            ) -> &mut Self {
                let mut value = self.response();
                f(&mut value);
                self.set_response(value)
            }
        }

        enum_def_with_unknown!(#[allow(non_camel_case_types)] RESPONSE_FIELD u32 =>
                        // Endpoint does not respond in that case
                        NoResp = 0,
        // Endpoint responds with a zero-length data packet in that case
                        ZeroData = 1

                    );

        impl RESPONSE_FIELD {
            pub fn is_noresp(&self) -> bool {
                *self == Self::NoResp
            }

            pub fn set_noresp(&mut self) -> &mut Self {
                *self = Self::NoResp;
                self
            }

            pub fn is_zerodata(&self) -> bool {
                *self == Self::ZeroData
            }

            pub fn set_zerodata(&mut self) -> &mut Self {
                *self = Self::ZeroData;
                self
            }
        }
    }

    pub mod epin {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct EPIN {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Data pointer
            pub ptr: ptr::PTR,
            /// Description cluster: Maximum number of bytes to transfer
            pub maxcnt: maxcnt::MAXCNT,
            /// Description cluster: Number of bytes transferred in the last
            /// transaction
            pub amount: amount::AMOUNT,
            _padding_12: [u8; 8],
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000007f) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000007f) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000007f) >> 0
                }
            }
        }
    }

    pub mod isoin {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct ISOIN {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes to transfer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x000003ff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x000003ff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x000003ff) >> 0
                }
            }
        }
    }

    pub mod epout {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct EPOUT {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Description cluster: Data pointer
            pub ptr: ptr::PTR,
            /// Description cluster: Maximum number of bytes to transfer
            pub maxcnt: maxcnt::MAXCNT,
            /// Description cluster: Number of bytes transferred in the last
            /// transaction
            pub amount: amount::AMOUNT,
            _padding_12: [u8; 8],
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000007f) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x0000007f) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x0000007f) >> 0
                }
            }
        }
    }

    pub mod isoout {
        #[allow(unused_imports)]
        use super::*;

        /// Unspecified
        #[repr(C)]
        pub struct ISOOUT {
            // TODO: Add this to the peripherals register block as well.
            _hidden: (),
            /// Data pointer
            pub ptr: ptr::PTR,
            /// Maximum number of bytes to transfer
            pub maxcnt: maxcnt::MAXCNT,
            /// Number of bytes transferred in the last transaction
            pub amount: amount::AMOUNT,
        }

        pub mod ptr {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct PTR {
                raw: RawRegister<u32>,
            }

            impl PTR {}

            impl RegisterRead for PTR {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0xffffffff) >> 0
                }
            }

            impl RegisterWrite for PTR {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0xffffffff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod maxcnt {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct MAXCNT {
                raw: RawRegister<u32>,
            }

            impl MAXCNT {}

            impl RegisterRead for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x000003ff) >> 0
                }
            }

            impl RegisterWrite for MAXCNT {
                type Value = u32;

                #[inline(always)]
                fn write(&mut self, value: Self::Value) {
                    let old_raw = 0;
                    let raw = (old_raw & !0x000003ff) | (value << 0);
                    self.raw.write(raw);
                }
            }
        }

        pub mod amount {
            #[allow(unused_imports)]
            use super::*;

            #[allow(non_camel_case_types)]
            #[repr(transparent)]
            pub struct AMOUNT {
                raw: RawRegister<u32>,
            }

            impl AMOUNT {}

            impl RegisterRead for AMOUNT {
                type Value = u32;

                #[inline(always)]
                fn read(&self) -> Self::Value {
                    let raw = self.raw.read();
                    (raw & 0x000003ff) >> 0
                }
            }
        }
    }
}

pub mod uarte1 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct UARTE1 {
        _hidden: (),
    }

    impl UARTE1 {
        const BASE_ADDRESS: u32 = 0x40028000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for UARTE1 {
        type Target = uarte0::UARTE0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for UARTE1 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod pwm3 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct PWM3 {
        _hidden: (),
    }

    impl PWM3 {
        const BASE_ADDRESS: u32 = 0x4002d000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for PWM3 {
        type Target = pwm0::PWM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for PWM3 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}

pub mod spim3 {
    #[allow(unused_imports)]
    use super::*;

    #[allow(non_camel_case_types)]
    pub struct SPIM3 {
        _hidden: (),
    }

    impl SPIM3 {
        const BASE_ADDRESS: u32 = 0x4002f000;

        pub unsafe fn new() -> Self {
            Self { _hidden: () }
        }
    }

    impl Deref for SPIM3 {
        type Target = spim0::SPIM0_REGISTERS;

        fn deref(&self) -> &Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }

    impl DerefMut for SPIM3 {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { ::core::mem::transmute(Self::BASE_ADDRESS) }
        }
    }
}
