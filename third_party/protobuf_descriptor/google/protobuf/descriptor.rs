// AUTOGENERATED BY THE PROTOBUF COMPILER

#[cfg(feature = "alloc")]
use alloc::string::String;
#[cfg(feature = "alloc")]
use alloc::vec::Vec;
#[cfg(feature = "std")]
use std::sync::Arc;

#[cfg(feature = "alloc")]
use alloc::boxed::Box;

use common::collections::FixedString;
use common::const_default::{ConstDefault, StaticDefault};
use common::errors::*;
use common::fixed::vec::FixedVec;
use common::list::Appendable;
use protobuf_core::*;

use protobuf_core::codecs::*;

use protobuf_core::wire::*;

#[cfg(feature = "alloc")]
use protobuf_core::reflection::*;

#[cfg(feature = "std")]
pub static FILE_DESCRIPTOR_0F2934D003718DD8: protobuf_core::StaticFileDescriptor = protobuf_core::StaticFileDescriptor {
                proto: b"\x0a\x20google\x2fprotobuf\x2fdescriptor\x2eproto\x12\x0fgoogle\x2eprotobuf\x22\x3a\x0a\x11FileDescriptorSet\x12\x23\x0a\x04file\x18\x01\x20\x03\x28\x0b2\x13FileDescriptorProtoB\x00\x3a\x00\x22\xa2\x03\x0a\x13FileDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x11\x0a\x07package\x18\x02\x20\x01\x28\x09B\x00\x12\x14\x0a\x0adependency\x18\x03\x20\x03\x28\x09B\x00\x12\x1b\x0a\x11public\x5fdependency\x18\x0a\x20\x03\x28\x05B\x00\x12\x19\x0a\x0fweak\x5fdependency\x18\x0b\x20\x03\x28\x05B\x00\x12\x27\x0a\x0cmessage\x5ftype\x18\x04\x20\x03\x28\x0b2\x0fDescriptorProtoB\x00\x12\x28\x0a\x09enum\x5ftype\x18\x05\x20\x03\x28\x0b2\x13EnumDescriptorProtoB\x00\x12\x29\x0a\x07service\x18\x06\x20\x03\x28\x0b2\x16ServiceDescriptorProtoB\x00\x12\x29\x0a\x09extension\x18\x07\x20\x03\x28\x0b2\x14FieldDescriptorProtoB\x00\x12\x1e\x0a\x07options\x18\x08\x20\x01\x28\x0b2\x0bFileOptionsB\x00\x12\x2a\x0a\x10source\x5fcode\x5finfo\x18\x09\x20\x01\x28\x0b2\x0eSourceCodeInfoB\x00\x12\x10\x0a\x06syntax\x18\x0c\x20\x01\x28\x09B\x00\x12\x11\x0a\x07edition\x18\x0d\x20\x01\x28\x09B\x00\x3a\x00\x22\x94\x04\x0a\x0fDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x25\x0a\x05field\x18\x02\x20\x03\x28\x0b2\x14FieldDescriptorProtoB\x00\x12\x29\x0a\x09extension\x18\x06\x20\x03\x28\x0b2\x14FieldDescriptorProtoB\x00\x12\x26\x0a\x0bnested\x5ftype\x18\x03\x20\x03\x28\x0b2\x0fDescriptorProtoB\x00\x12\x28\x0a\x09enum\x5ftype\x18\x04\x20\x03\x28\x0b2\x13EnumDescriptorProtoB\x00\x12\x29\x0a\x0fextension\x5frange\x18\x05\x20\x03\x28\x0b2\x0eExtensionRangeB\x00\x12\x2a\x0a\x0aoneof\x5fdecl\x18\x08\x20\x03\x28\x0b2\x14OneofDescriptorProtoB\x00\x12\x21\x0a\x07options\x18\x07\x20\x01\x28\x0b2\x0eMessageOptionsB\x00\x12\x27\x0a\x0ereserved\x5frange\x18\x09\x20\x03\x28\x0b2\x0dReservedRangeB\x00\x12\x17\x0a\x0dreserved\x5fname\x18\x0a\x20\x03\x28\x09B\x00\x1a\x5c\x0a\x0eExtensionRange\x12\x0f\x0a\x05start\x18\x01\x20\x01\x28\x05B\x00\x12\x0d\x0a\x03end\x18\x02\x20\x01\x28\x05B\x00\x12\x28\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x15ExtensionRangeOptionsB\x00\x3a\x00\x1a1\x0a\x0dReservedRange\x12\x0f\x0a\x05start\x18\x01\x20\x01\x28\x05B\x00\x12\x0d\x0a\x03end\x18\x02\x20\x01\x28\x05B\x00\x3a\x00\x3a\x00\x22\x89\x03\x0a\x15ExtensionRangeOptions\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x12\x25\x0a\x0bdeclaration\x18\x02\x20\x03\x28\x0b2\x0bDeclarationB\x03\x88\x01\x02\x12\x1e\x0a\x08features\x182\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x125\x0a\x0cverification\x18\x03\x20\x01\x28\x0b2\x11VerificationState\x3a\x0aUNVERIFIEDB\x00\x1an\x0a\x0bDeclaration\x12\x10\x0a\x06number\x18\x01\x20\x01\x28\x05B\x00\x12\x13\x0a\x09full\x5fname\x18\x02\x20\x01\x28\x09B\x00\x12\x0e\x0a\x04type\x18\x03\x20\x01\x28\x09B\x00\x12\x12\x0a\x08reserved\x18\x05\x20\x01\x28\x08B\x00\x12\x12\x0a\x08repeated\x18\x06\x20\x01\x28\x08B\x00\x3a\x00\x22\x3a\x0a\x11VerificationState\x12\x11\x0a\x0bDECLARATION\x10\x00\x1a\x00\x12\x10\x0a\x0aUNVERIFIED\x10\x01\x1a\x00\x1a\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\xbe\x05\x0a\x14FieldDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x10\x0a\x06number\x18\x03\x20\x01\x28\x05B\x00\x12\x16\x0a\x05label\x18\x04\x20\x01\x28\x0b2\x05LabelB\x00\x12\x14\x0a\x04type\x18\x05\x20\x01\x28\x0b2\x04TypeB\x00\x12\x13\x0a\x09type\x5fname\x18\x06\x20\x01\x28\x09B\x00\x12\x12\x0a\x08extendee\x18\x02\x20\x01\x28\x09B\x00\x12\x17\x0a\x0ddefault\x5fvalue\x18\x07\x20\x01\x28\x09B\x00\x12\x15\x0a\x0boneof\x5findex\x18\x09\x20\x01\x28\x05B\x00\x12\x13\x0a\x09json\x5fname\x18\x0a\x20\x01\x28\x09B\x00\x12\x1f\x0a\x07options\x18\x08\x20\x01\x28\x0b2\x0cFieldOptionsB\x00\x12\x19\x0a\x0fproto3\x5foptional\x18\x11\x20\x01\x28\x08B\x00\x22\xdc\x02\x0a\x04Type\x12\x11\x0a\x0bTYPE\x5fDOUBLE\x10\x01\x1a\x00\x12\x10\x0a\x0aTYPE\x5fFLOAT\x10\x02\x1a\x00\x12\x10\x0a\x0aTYPE\x5fINT64\x10\x03\x1a\x00\x12\x11\x0a\x0bTYPE\x5fUINT64\x10\x04\x1a\x00\x12\x10\x0a\x0aTYPE\x5fINT32\x10\x05\x1a\x00\x12\x12\x0a\x0cTYPE\x5fFIXED64\x10\x06\x1a\x00\x12\x12\x0a\x0cTYPE\x5fFIXED32\x10\x07\x1a\x00\x12\x0f\x0a\x09TYPE\x5fBOOL\x10\x08\x1a\x00\x12\x11\x0a\x0bTYPE\x5fSTRING\x10\x09\x1a\x00\x12\x10\x0a\x0aTYPE\x5fGROUP\x10\x0a\x1a\x00\x12\x12\x0a\x0cTYPE\x5fMESSAGE\x10\x0b\x1a\x00\x12\x10\x0a\x0aTYPE\x5fBYTES\x10\x0c\x1a\x00\x12\x11\x0a\x0bTYPE\x5fUINT32\x10\x0d\x1a\x00\x12\x0f\x0a\x09TYPE\x5fENUM\x10\x0e\x1a\x00\x12\x13\x0a\x0dTYPE\x5fSFIXED32\x10\x0f\x1a\x00\x12\x13\x0a\x0dTYPE\x5fSFIXED64\x10\x10\x1a\x00\x12\x11\x0a\x0bTYPE\x5fSINT32\x10\x11\x1a\x00\x12\x11\x0a\x0bTYPE\x5fSINT64\x10\x12\x1a\x00\x1a\x00\x22K\x0a\x05Label\x12\x14\x0a\x0eLABEL\x5fOPTIONAL\x10\x01\x1a\x00\x12\x14\x0a\x0eLABEL\x5fREQUIRED\x10\x02\x1a\x00\x12\x14\x0a\x0eLABEL\x5fREPEATED\x10\x03\x1a\x00\x1a\x00\x3a\x00\x22I\x0a\x14OneofDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x1f\x0a\x07options\x18\x02\x20\x01\x28\x0b2\x0cOneofOptionsB\x00\x3a\x00\x22\xef\x01\x0a\x13EnumDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x29\x0a\x05value\x18\x02\x20\x03\x28\x0b2\x18EnumValueDescriptorProtoB\x00\x12\x1e\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x0bEnumOptionsB\x00\x12\x2b\x0a\x0ereserved\x5frange\x18\x04\x20\x03\x28\x0b2\x11EnumReservedRangeB\x00\x12\x17\x0a\x0dreserved\x5fname\x18\x05\x20\x03\x28\x09B\x00\x1a5\x0a\x11EnumReservedRange\x12\x0f\x0a\x05start\x18\x01\x20\x01\x28\x05B\x00\x12\x0d\x0a\x03end\x18\x02\x20\x01\x28\x05B\x00\x3a\x00\x3a\x00\x22c\x0a\x18EnumValueDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x10\x0a\x06number\x18\x02\x20\x01\x28\x05B\x00\x12\x23\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x10EnumValueOptionsB\x00\x3a\x00\x22v\x0a\x16ServiceDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x27\x0a\x06method\x18\x02\x20\x03\x28\x0b2\x15MethodDescriptorProtoB\x00\x12\x21\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x0eServiceOptionsB\x00\x3a\x00\x22\xbe\x01\x0a\x15MethodDescriptorProto\x12\x0e\x0a\x04name\x18\x01\x20\x01\x28\x09B\x00\x12\x14\x0a\x0ainput\x5ftype\x18\x02\x20\x01\x28\x09B\x00\x12\x15\x0a\x0boutput\x5ftype\x18\x03\x20\x01\x28\x09B\x00\x12\x20\x0a\x07options\x18\x04\x20\x01\x28\x0b2\x0dMethodOptionsB\x00\x12\x21\x0a\x10client\x5fstreaming\x18\x05\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x21\x0a\x10server\x5fstreaming\x18\x06\x20\x01\x28\x08\x3a\x05falseB\x00\x3a\x00\x22\xc8\x06\x0a\x0bFileOptions\x12\x16\x0a\x0cjava\x5fpackage\x18\x01\x20\x01\x28\x09B\x00\x12\x1e\x0a\x14java\x5fouter\x5fclassname\x18\x08\x20\x01\x28\x09B\x00\x12\x24\x0a\x13java\x5fmultiple\x5ffiles\x18\x0a\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x29\x0a\x1djava\x5fgenerate\x5fequals\x5fand\x5fhash\x18\x14\x20\x01\x28\x08B\x02\x18\x01\x12\x27\x0a\x16java\x5fstring\x5fcheck\x5futf8\x18\x1b\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x2b\x0a\x0coptimize\x5ffor\x18\x09\x20\x01\x28\x0b2\x0cOptimizeMode\x3a\x05SPEEDB\x00\x12\x14\x0a\x0ago\x5fpackage\x18\x0b\x20\x01\x28\x09B\x00\x12\x24\x0a\x13cc\x5fgeneric\x5fservices\x18\x10\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x26\x0a\x15java\x5fgeneric\x5fservices\x18\x11\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x24\x0a\x13py\x5fgeneric\x5fservices\x18\x12\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x25\x0a\x14php\x5fgeneric\x5fservices\x18\x2a\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x1b\x0a\x0adeprecated\x18\x17\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x20\x0a\x10cc\x5fenable\x5farenas\x18\x1f\x20\x01\x28\x08\x3a\x04trueB\x00\x12\x1b\x0a\x11objc\x5fclass\x5fprefix\x18\x24\x20\x01\x28\x09B\x00\x12\x1a\x0a\x10csharp\x5fnamespace\x18\x25\x20\x01\x28\x09B\x00\x12\x16\x0a\x0cswift\x5fprefix\x18\x27\x20\x01\x28\x09B\x00\x12\x1a\x0a\x10php\x5fclass\x5fprefix\x18\x28\x20\x01\x28\x09B\x00\x12\x17\x0a\x0dphp\x5fnamespace\x18\x29\x20\x01\x28\x09B\x00\x12\x20\x0a\x16php\x5fmetadata\x5fnamespace\x18\x2c\x20\x01\x28\x09B\x00\x12\x16\x0a\x0cruby\x5fpackage\x18\x2d\x20\x01\x28\x09B\x00\x12\x1e\x0a\x08features\x182\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x22B\x0a\x0cOptimizeMode\x12\x0b\x0a\x05SPEED\x10\x01\x1a\x00\x12\x0f\x0a\x09CODE\x5fSIZE\x10\x02\x1a\x00\x12\x12\x0a\x0cLITE\x5fRUNTIME\x10\x03\x1a\x00\x1a\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\xba\x02\x0a\x0eMessageOptions\x12\x28\x0a\x17message\x5fset\x5fwire\x5fformat\x18\x01\x20\x01\x28\x08\x3a\x05falseB\x00\x120\x0a\x1fno\x5fstandard\x5fdescriptor\x5faccessor\x18\x02\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x1b\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x13\x0a\x09map\x5fentry\x18\x07\x20\x01\x28\x08B\x00\x122\x0a\x26deprecated\x5flegacy\x5fjson\x5ffield\x5fconflicts\x18\x0b\x20\x01\x28\x08B\x02\x18\x01\x12\x1e\x0a\x08features\x18\x0c\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\x84\x08\x0a\x0cFieldOptions\x12\x1e\x0a\x05ctype\x18\x01\x20\x01\x28\x0b2\x05CType\x3a\x06STRINGB\x00\x12\x10\x0a\x06packed\x18\x02\x20\x01\x28\x08B\x00\x12\x23\x0a\x06jstype\x18\x06\x20\x01\x28\x0b2\x06JSType\x3a\x09JS\x5fNORMALB\x00\x12\x15\x0a\x04lazy\x18\x05\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x20\x0a\x0funverified\x5flazy\x18\x0f\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x1b\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x15\x0a\x04weak\x18\x0a\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x1d\x0a\x0cdebug\x5fredact\x18\x10\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x24\x0a\x09retention\x18\x11\x20\x01\x28\x0b2\x0fOptionRetentionB\x00\x12\x23\x0a\x07targets\x18\x13\x20\x03\x28\x0b2\x10OptionTargetTypeB\x00\x12\x2a\x0a\x10edition\x5fdefaults\x18\x14\x20\x03\x28\x0b2\x0eEditionDefaultB\x00\x12\x1e\x0a\x08features\x18\x15\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x1a6\x0a\x0eEditionDefault\x12\x11\x0a\x07edition\x18\x01\x20\x01\x28\x09B\x00\x12\x0f\x0a\x05value\x18\x02\x20\x01\x28\x09B\x00\x3a\x00\x227\x0a\x05CType\x12\x0c\x0a\x06STRING\x10\x00\x1a\x00\x12\x0a\x0a\x04CORD\x10\x01\x1a\x00\x12\x12\x0a\x0cSTRING\x5fPIECE\x10\x02\x1a\x00\x1a\x00\x22\x3d\x0a\x06JSType\x12\x0f\x0a\x09JS\x5fNORMAL\x10\x00\x1a\x00\x12\x0f\x0a\x09JS\x5fSTRING\x10\x01\x1a\x00\x12\x0f\x0a\x09JS\x5fNUMBER\x10\x02\x1a\x00\x1a\x00\x22\x5d\x0a\x0fOptionRetention\x12\x17\x0a\x11RETENTION\x5fUNKNOWN\x10\x00\x1a\x00\x12\x17\x0a\x11RETENTION\x5fRUNTIME\x10\x01\x1a\x00\x12\x16\x0a\x10RETENTION\x5fSOURCE\x10\x02\x1a\x00\x1a\x00\x22\xa2\x02\x0a\x10OptionTargetType\x12\x19\x0a\x13TARGET\x5fTYPE\x5fUNKNOWN\x10\x00\x1a\x00\x12\x16\x0a\x10TARGET\x5fTYPE\x5fFILE\x10\x01\x1a\x00\x12\x21\x0a\x1bTARGET\x5fTYPE\x5fEXTENSION\x5fRANGE\x10\x02\x1a\x00\x12\x19\x0a\x13TARGET\x5fTYPE\x5fMESSAGE\x10\x03\x1a\x00\x12\x17\x0a\x11TARGET\x5fTYPE\x5fFIELD\x10\x04\x1a\x00\x12\x17\x0a\x11TARGET\x5fTYPE\x5fONEOF\x10\x05\x1a\x00\x12\x16\x0a\x10TARGET\x5fTYPE\x5fENUM\x10\x06\x1a\x00\x12\x1c\x0a\x16TARGET\x5fTYPE\x5fENUM\x5fENTRY\x10\x07\x1a\x00\x12\x19\x0a\x13TARGET\x5fTYPE\x5fSERVICE\x10\x08\x1a\x00\x12\x18\x0a\x12TARGET\x5fTYPE\x5fMETHOD\x10\x09\x1a\x00\x1a\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22v\x0a\x0cOneofOptions\x12\x1e\x0a\x08features\x18\x01\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\xdd\x01\x0a\x0bEnumOptions\x12\x15\x0a\x0ballow\x5falias\x18\x02\x20\x01\x28\x08B\x00\x12\x1b\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x3a\x05falseB\x00\x122\x0a\x26deprecated\x5flegacy\x5fjson\x5ffield\x5fconflicts\x18\x06\x20\x01\x28\x08B\x02\x18\x01\x12\x1e\x0a\x08features\x18\x07\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\xb6\x01\x0a\x10EnumValueOptions\x12\x1b\x0a\x0adeprecated\x18\x01\x20\x01\x28\x08\x3a\x05falseB\x00\x12\x1e\x0a\x08features\x18\x02\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x12\x1d\x0a\x0cdebug\x5fredact\x18\x03\x20\x01\x28\x08\x3a\x05falseB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\x95\x01\x0a\x0eServiceOptions\x12\x1e\x0a\x08features\x18\x22\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x12\x1b\x0a\x0adeprecated\x18\x21\x20\x01\x28\x08\x3a\x05falseB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\xb2\x02\x0a\x0dMethodOptions\x12\x1b\x0a\x0adeprecated\x18\x21\x20\x01\x28\x08\x3a\x05falseB\x00\x12B\x0a\x11idempotency\x5flevel\x18\x22\x20\x01\x28\x0b2\x10IdempotencyLevel\x3a\x13IDEMPOTENCY\x5fUNKNOWNB\x00\x12\x1e\x0a\x08features\x18\x23\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x124\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOptionB\x00\x22X\x0a\x10IdempotencyLevel\x12\x19\x0a\x13IDEMPOTENCY\x5fUNKNOWN\x10\x00\x1a\x00\x12\x15\x0a\x0fNO\x5fSIDE\x5fEFFECTS\x10\x01\x1a\x00\x12\x10\x0a\x0aIDEMPOTENT\x10\x02\x1a\x00\x1a\x00\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x3a\x00\x22\x8f\x02\x0a\x13UninterpretedOption\x12\x18\x0a\x04name\x18\x02\x20\x03\x28\x0b2\x08NamePartB\x00\x12\x1a\x0a\x10identifier\x5fvalue\x18\x03\x20\x01\x28\x09B\x00\x12\x1c\x0a\x12positive\x5fint\x5fvalue\x18\x04\x20\x01\x28\x04B\x00\x12\x1c\x0a\x12negative\x5fint\x5fvalue\x18\x05\x20\x01\x28\x03B\x00\x12\x16\x0a\x0cdouble\x5fvalue\x18\x06\x20\x01\x28\x01B\x00\x12\x16\x0a\x0cstring\x5fvalue\x18\x07\x20\x01\x28\x0cB\x00\x12\x19\x0a\x0faggregate\x5fvalue\x18\x08\x20\x01\x28\x09B\x00\x1a9\x0a\x08NamePart\x12\x13\x0a\x09name\x5fpart\x18\x01\x20\x02\x28\x09B\x00\x12\x16\x0a\x0cis\x5fextension\x18\x02\x20\x02\x28\x08B\x00\x3a\x00\x3a\x00\x22\xb6\x06\x0a\x0aFeatureSet\x12B\x0a\x0efield\x5fpresence\x18\x01\x20\x01\x28\x0b2\x0dFieldPresenceB\x1b\x88\x01\x01\x9a\x01\x02\x04\x01\xa2\x01\x10\x0a\x042023\x12\x08EXPLICIT\x124\x0a\x09enum\x5ftype\x18\x02\x20\x01\x28\x0b2\x08EnumTypeB\x17\x88\x01\x01\x9a\x01\x02\x06\x01\xa2\x01\x0c\x0a\x042023\x12\x04OPEN\x12Q\x0a\x17repeated\x5ffield\x5fencoding\x18\x03\x20\x01\x28\x0b2\x15RepeatedFieldEncodingB\x19\x88\x01\x01\x9a\x01\x02\x04\x01\xa2\x01\x0e\x0a\x042023\x12\x06PACKED\x12M\x0a\x10message\x5fencoding\x18\x05\x20\x01\x28\x0b2\x0fMessageEncodingB\x22\x88\x01\x01\x9a\x01\x02\x04\x01\xa2\x01\x17\x0a\x042023\x12\x0fLENGTH\x5fPREFIXED\x12\x3a\x0a\x0bjson\x5fformat\x18\x06\x20\x01\x28\x0b2\x0aJsonFormatB\x19\x88\x01\x01\x9a\x01\x03\x03\x06\x01\xa2\x01\x0d\x0a\x042023\x12\x05ALLOW\x22f\x0a\x0dFieldPresence\x12\x1c\x0a\x16FIELD\x5fPRESENCE\x5fUNKNOWN\x10\x00\x1a\x00\x12\x0e\x0a\x08EXPLICIT\x10\x01\x1a\x00\x12\x0e\x0a\x08IMPLICIT\x10\x02\x1a\x00\x12\x15\x0a\x0fLEGACY\x5fREQUIRED\x10\x03\x1a\x00\x1a\x00\x22\x3f\x0a\x08EnumType\x12\x17\x0a\x11ENUM\x5fTYPE\x5fUNKNOWN\x10\x00\x1a\x00\x12\x0a\x0a\x04OPEN\x10\x01\x1a\x00\x12\x0c\x0a\x06CLOSED\x10\x02\x1a\x00\x1a\x00\x22\x5e\x0a\x15RepeatedFieldEncoding\x12\x25\x0a\x1fREPEATED\x5fFIELD\x5fENCODING\x5fUNKNOWN\x10\x00\x1a\x00\x12\x0c\x0a\x06PACKED\x10\x01\x1a\x00\x12\x0e\x0a\x08EXPANDED\x10\x02\x1a\x00\x1a\x00\x22\x5b\x0a\x0fMessageEncoding\x12\x1e\x0a\x18MESSAGE\x5fENCODING\x5fUNKNOWN\x10\x00\x1a\x00\x12\x15\x0a\x0fLENGTH\x5fPREFIXED\x10\x01\x1a\x00\x12\x0f\x0a\x09DELIMITED\x10\x02\x1a\x00\x1a\x00\x22P\x0a\x0aJsonFormat\x12\x19\x0a\x13JSON\x5fFORMAT\x5fUNKNOWN\x10\x00\x1a\x00\x12\x0b\x0a\x05ALLOW\x10\x01\x1a\x00\x12\x18\x0a\x12LEGACY\x5fBEST\x5fEFFORT\x10\x02\x1a\x00\x1a\x00\x2a\x06\x08\xe8\x07\x10\xe8\x07\x2a\x06\x08\xe9\x07\x10\xe9\x07\x2a\x06\x08\x8bN\x10\x8fN\x3a\x00\x22\xcb\x01\x0a\x12FeatureSetDefaults\x12\x2c\x0a\x08defaults\x18\x01\x20\x03\x28\x0b2\x18FeatureSetEditionDefaultB\x00\x12\x19\x0a\x0fminimum\x5fedition\x18\x02\x20\x01\x28\x09B\x00\x12\x19\x0a\x0fmaximum\x5fedition\x18\x03\x20\x01\x28\x09B\x00\x1aO\x0a\x18FeatureSetEditionDefault\x12\x11\x0a\x07edition\x18\x01\x20\x01\x28\x09B\x00\x12\x1e\x0a\x08features\x18\x02\x20\x01\x28\x0b2\x0aFeatureSetB\x00\x3a\x00\x3a\x00\x22\xc1\x01\x0a\x0eSourceCodeInfo\x12\x1c\x0a\x08location\x18\x01\x20\x03\x28\x0b2\x08LocationB\x00\x1a\x8e\x01\x0a\x08Location\x12\x10\x0a\x04path\x18\x01\x20\x03\x28\x05B\x02\x10\x01\x12\x10\x0a\x04span\x18\x02\x20\x03\x28\x05B\x02\x10\x01\x12\x1a\x0a\x10leading\x5fcomments\x18\x03\x20\x01\x28\x09B\x00\x12\x1b\x0a\x11trailing\x5fcomments\x18\x04\x20\x01\x28\x09B\x00\x12\x23\x0a\x19leading\x5fdetached\x5fcomments\x18\x06\x20\x03\x28\x09B\x00\x3a\x00\x3a\x00\x22\xe1\x01\x0a\x11GeneratedCodeInfo\x12\x20\x0a\x0aannotation\x18\x01\x20\x03\x28\x0b2\x0aAnnotationB\x00\x1a\xa7\x01\x0a\x0aAnnotation\x12\x10\x0a\x04path\x18\x01\x20\x03\x28\x05B\x02\x10\x01\x12\x15\x0a\x0bsource\x5ffile\x18\x02\x20\x01\x28\x09B\x00\x12\x0f\x0a\x05begin\x18\x03\x20\x01\x28\x05B\x00\x12\x0d\x0a\x03end\x18\x04\x20\x01\x28\x05B\x00\x12\x1c\x0a\x08semantic\x18\x05\x20\x01\x28\x0b2\x08SemanticB\x00\x220\x0a\x08Semantic\x12\x0a\x0a\x04NONE\x10\x00\x1a\x00\x12\x09\x0a\x03SET\x10\x01\x1a\x00\x12\x0b\x0a\x05ALIAS\x10\x02\x1a\x00\x1a\x00\x3a\x00\x3a\x00B\x7e\x0a\x13com\x2egoogle\x2eprotobufB\x10DescriptorProtosH\x01Z\x2dgoogle\x2egolang\x2eorg\x2fprotobuf\x2ftypes\x2fdescriptorpb\xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1aGoogle\x2eProtobuf\x2eReflectionb\x06proto2",
                dependencies: &[]
            };
#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FileDescriptorSet {
    file: Vec<MessagePtr<FileDescriptorProto>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FileDescriptorSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FileDescriptorSet {
    fn static_default() -> &'static Self {
        static VALUE: FileDescriptorSet = FileDescriptorSet::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FileDescriptorSet {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FileDescriptorSet {
    pub const FILE_FIELD_NUM: protobuf_core::FieldNumber = 1;

    pub fn file(&self) -> &[MessagePtr<FileDescriptorProto>] {
        &self.file
    }

    pub fn file_mut(&mut self) -> &mut Vec<MessagePtr<FileDescriptorProto>> {
        &mut self.file
    }

    pub fn file_len(&self) -> usize {
        self.file.len()
    }

    pub fn add_file(&mut self, v: FileDescriptorProto) -> &mut MessagePtr<FileDescriptorProto> {
        self.file.push(MessagePtr::new(v));
        self.file.last_mut().unwrap()
    }

    pub fn new_file(&mut self) -> &mut MessagePtr<FileDescriptorProto> {
        self.file.push(<MessagePtr<FileDescriptorProto>>::default());
        self.file.last_mut().unwrap()
    }

    pub fn clear_file(&mut self) {
        self.file.clear();
    }
}

impl protobuf_core::StaticMessage for FileDescriptorSet {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FileDescriptorSet"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FileDescriptorSet {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FileDescriptorSet"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.file.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(1, &self.file, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FileDescriptorSet {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("file"),
            number: 1,
        }]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.file.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.file.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.file.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.file.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "file" => 1,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FileDescriptorProto {
    name: Option<String>,
    package: Option<String>,
    dependency: Vec<String>,
    public_dependency: Vec<i32>,
    weak_dependency: Vec<i32>,
    message_type: Vec<MessagePtr<DescriptorProto>>,
    enum_type: Vec<MessagePtr<EnumDescriptorProto>>,
    service: Vec<MessagePtr<ServiceDescriptorProto>>,
    extension: Vec<MessagePtr<FieldDescriptorProto>>,
    options: Option<MessagePtr<FileOptions>>,
    source_code_info: Option<MessagePtr<SourceCodeInfo>>,
    syntax: Option<String>,
    edition: Option<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FileDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FileDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: FileDescriptorProto = FileDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FileDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FileDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const PACKAGE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const DEPENDENCY_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const PUBLIC_DEPENDENCY_FIELD_NUM: protobuf_core::FieldNumber = 10;
    pub const WEAK_DEPENDENCY_FIELD_NUM: protobuf_core::FieldNumber = 11;
    pub const MESSAGE_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const ENUM_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const SERVICE_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const EXTENSION_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 8;
    pub const SOURCE_CODE_INFO_FIELD_NUM: protobuf_core::FieldNumber = 9;
    pub const SYNTAX_FIELD_NUM: protobuf_core::FieldNumber = 12;
    pub const EDITION_FIELD_NUM: protobuf_core::FieldNumber = 13;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn package(&self) -> &str {
        self.package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }
    pub fn set_package<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.package = Some(v);
    }
    pub fn package_mut(&mut self) -> &mut String {
        self.package.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_package(&mut self) {
        self.package = None;
    }

    pub fn dependency(&self) -> &[String] {
        &self.dependency
    }

    pub fn dependency_mut(&mut self) -> &mut Vec<String> {
        &mut self.dependency
    }

    pub fn dependency_len(&self) -> usize {
        self.dependency.len()
    }

    pub fn add_dependency(&mut self, v: String) -> &mut String {
        self.dependency.push(v);
        self.dependency.last_mut().unwrap()
    }

    pub fn new_dependency(&mut self) -> &mut String {
        self.dependency.push(<String>::default());
        self.dependency.last_mut().unwrap()
    }

    pub fn clear_dependency(&mut self) {
        self.dependency.clear();
    }

    pub fn public_dependency(&self) -> &[i32] {
        &self.public_dependency
    }

    pub fn public_dependency_mut(&mut self) -> &mut Vec<i32> {
        &mut self.public_dependency
    }

    pub fn public_dependency_len(&self) -> usize {
        self.public_dependency.len()
    }

    pub fn add_public_dependency(&mut self, v: i32) -> &mut i32 {
        self.public_dependency.push(v);
        self.public_dependency.last_mut().unwrap()
    }

    pub fn new_public_dependency(&mut self) -> &mut i32 {
        self.public_dependency.push(<i32>::default());
        self.public_dependency.last_mut().unwrap()
    }

    pub fn clear_public_dependency(&mut self) {
        self.public_dependency.clear();
    }

    pub fn weak_dependency(&self) -> &[i32] {
        &self.weak_dependency
    }

    pub fn weak_dependency_mut(&mut self) -> &mut Vec<i32> {
        &mut self.weak_dependency
    }

    pub fn weak_dependency_len(&self) -> usize {
        self.weak_dependency.len()
    }

    pub fn add_weak_dependency(&mut self, v: i32) -> &mut i32 {
        self.weak_dependency.push(v);
        self.weak_dependency.last_mut().unwrap()
    }

    pub fn new_weak_dependency(&mut self) -> &mut i32 {
        self.weak_dependency.push(<i32>::default());
        self.weak_dependency.last_mut().unwrap()
    }

    pub fn clear_weak_dependency(&mut self) {
        self.weak_dependency.clear();
    }

    pub fn message_type(&self) -> &[MessagePtr<DescriptorProto>] {
        &self.message_type
    }

    pub fn message_type_mut(&mut self) -> &mut Vec<MessagePtr<DescriptorProto>> {
        &mut self.message_type
    }

    pub fn message_type_len(&self) -> usize {
        self.message_type.len()
    }

    pub fn add_message_type(&mut self, v: DescriptorProto) -> &mut MessagePtr<DescriptorProto> {
        self.message_type.push(MessagePtr::new(v));
        self.message_type.last_mut().unwrap()
    }

    pub fn new_message_type(&mut self) -> &mut MessagePtr<DescriptorProto> {
        self.message_type
            .push(<MessagePtr<DescriptorProto>>::default());
        self.message_type.last_mut().unwrap()
    }

    pub fn clear_message_type(&mut self) {
        self.message_type.clear();
    }

    pub fn enum_type(&self) -> &[MessagePtr<EnumDescriptorProto>] {
        &self.enum_type
    }

    pub fn enum_type_mut(&mut self) -> &mut Vec<MessagePtr<EnumDescriptorProto>> {
        &mut self.enum_type
    }

    pub fn enum_type_len(&self) -> usize {
        self.enum_type.len()
    }

    pub fn add_enum_type(
        &mut self,
        v: EnumDescriptorProto,
    ) -> &mut MessagePtr<EnumDescriptorProto> {
        self.enum_type.push(MessagePtr::new(v));
        self.enum_type.last_mut().unwrap()
    }

    pub fn new_enum_type(&mut self) -> &mut MessagePtr<EnumDescriptorProto> {
        self.enum_type
            .push(<MessagePtr<EnumDescriptorProto>>::default());
        self.enum_type.last_mut().unwrap()
    }

    pub fn clear_enum_type(&mut self) {
        self.enum_type.clear();
    }

    pub fn service(&self) -> &[MessagePtr<ServiceDescriptorProto>] {
        &self.service
    }

    pub fn service_mut(&mut self) -> &mut Vec<MessagePtr<ServiceDescriptorProto>> {
        &mut self.service
    }

    pub fn service_len(&self) -> usize {
        self.service.len()
    }

    pub fn add_service(
        &mut self,
        v: ServiceDescriptorProto,
    ) -> &mut MessagePtr<ServiceDescriptorProto> {
        self.service.push(MessagePtr::new(v));
        self.service.last_mut().unwrap()
    }

    pub fn new_service(&mut self) -> &mut MessagePtr<ServiceDescriptorProto> {
        self.service
            .push(<MessagePtr<ServiceDescriptorProto>>::default());
        self.service.last_mut().unwrap()
    }

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn extension(&self) -> &[MessagePtr<FieldDescriptorProto>] {
        &self.extension
    }

    pub fn extension_mut(&mut self) -> &mut Vec<MessagePtr<FieldDescriptorProto>> {
        &mut self.extension
    }

    pub fn extension_len(&self) -> usize {
        self.extension.len()
    }

    pub fn add_extension(
        &mut self,
        v: FieldDescriptorProto,
    ) -> &mut MessagePtr<FieldDescriptorProto> {
        self.extension.push(MessagePtr::new(v));
        self.extension.last_mut().unwrap()
    }

    pub fn new_extension(&mut self) -> &mut MessagePtr<FieldDescriptorProto> {
        self.extension
            .push(<MessagePtr<FieldDescriptorProto>>::default());
        self.extension.last_mut().unwrap()
    }

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    pub fn options(&self) -> &FileOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FileOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<FileOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut FileOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(FileOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn source_code_info(&self) -> &SourceCodeInfo {
        self.source_code_info
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(SourceCodeInfo::static_default())
    }
    pub fn has_source_code_info(&self) -> bool {
        self.source_code_info.is_some()
    }
    pub fn set_source_code_info<V: ::core::convert::Into<SourceCodeInfo>>(&mut self, v: V) {
        let v = v.into();
        self.source_code_info = Some(MessagePtr::new(v));
    }
    pub fn source_code_info_mut(&mut self) -> &mut SourceCodeInfo {
        self.source_code_info
            .get_or_insert_with(|| MessagePtr::new(SourceCodeInfo::default()))
            .as_mut()
    }
    pub fn clear_source_code_info(&mut self) {
        self.source_code_info = None;
    }

    pub fn syntax(&self) -> &str {
        self.syntax.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }
    pub fn set_syntax<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.syntax = Some(v);
    }
    pub fn syntax_mut(&mut self) -> &mut String {
        self.syntax.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_syntax(&mut self) {
        self.syntax = None;
    }

    pub fn edition(&self) -> &str {
        self.edition.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_edition(&self) -> bool {
        self.edition.is_some()
    }
    pub fn set_edition<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.edition = Some(v);
    }
    pub fn edition_mut(&mut self) -> &mut String {
        self.edition.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_edition(&mut self) {
        self.edition = None;
    }
}

impl protobuf_core::StaticMessage for FileDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FileDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FileDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FileDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => self.package = Some(StringCodec::parse(&f)?),
                3 => {
                    for v in StringCodec::parse_repeated(&f) {
                        self.dependency.push(v?);
                    }
                }
                10 => {
                    for v in Int32Codec::parse_repeated(&f) {
                        self.public_dependency.push(v?);
                    }
                }
                11 => {
                    for v in Int32Codec::parse_repeated(&f) {
                        self.weak_dependency.push(v?);
                    }
                }
                4 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.message_type.push(MessagePtr::new(v?));
                    }
                }
                5 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.enum_type.push(MessagePtr::new(v?));
                    }
                }
                6 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.service.push(MessagePtr::new(v?));
                    }
                }
                7 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.extension.push(MessagePtr::new(v?));
                    }
                }
                8 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                9 => self.source_code_info = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                12 => self.syntax = Some(StringCodec::parse(&f)?),
                13 => self.edition = Some(StringCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.package.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        StringCodec::serialize_repeated(3, &self.dependency, out)?;
        Int32Codec::serialize_repeated(10, &self.public_dependency, out)?;
        Int32Codec::serialize_repeated(11, &self.weak_dependency, out)?;
        MessageCodec::serialize_repeated(4, &self.message_type, out)?;
        MessageCodec::serialize_repeated(5, &self.enum_type, out)?;
        MessageCodec::serialize_repeated(6, &self.service, out)?;
        MessageCodec::serialize_repeated(7, &self.extension, out)?;
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(8, v.as_ref(), out)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            MessageCodec::serialize(9, v.as_ref(), out)?;
        }
        if let Some(v) = self.syntax.as_ref() {
            StringCodec::serialize(12, v, out)?;
        }
        if let Some(v) = self.edition.as_ref() {
            StringCodec::serialize(13, v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FileDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("package"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("dependency"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("public_dependency"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("weak_dependency"),
                number: 11,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("message_type"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("enum_type"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("service"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("source_code_info"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("syntax"),
                number: 12,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("edition"),
                number: 13,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.package.reflect_clear_field(),
            3 => self.dependency.reflect_clear_field(),
            10 => self.public_dependency.reflect_clear_field(),
            11 => self.weak_dependency.reflect_clear_field(),
            4 => self.message_type.reflect_clear_field(),
            5 => self.enum_type.reflect_clear_field(),
            6 => self.service.reflect_clear_field(),
            7 => self.extension.reflect_clear_field(),
            8 => self.options.reflect_clear_field(),
            9 => self.source_code_info.reflect_clear_field(),
            12 => self.syntax.reflect_clear_field(),
            13 => self.edition.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.package.reflect_has_field(),
            3 => self.dependency.reflect_has_field(),
            10 => self.public_dependency.reflect_has_field(),
            11 => self.weak_dependency.reflect_has_field(),
            4 => self.message_type.reflect_has_field(),
            5 => self.enum_type.reflect_has_field(),
            6 => self.service.reflect_has_field(),
            7 => self.extension.reflect_has_field(),
            8 => self.options.reflect_has_field(),
            9 => self.source_code_info.reflect_has_field(),
            12 => self.syntax.reflect_has_field(),
            13 => self.edition.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.package.reflect_field(),
            3 => self.dependency.reflect_field(),
            10 => self.public_dependency.reflect_field(),
            11 => self.weak_dependency.reflect_field(),
            4 => self.message_type.reflect_field(),
            5 => self.enum_type.reflect_field(),
            6 => self.service.reflect_field(),
            7 => self.extension.reflect_field(),
            8 => self.options.reflect_field(),
            9 => self.source_code_info.reflect_field(),
            12 => self.syntax.reflect_field(),
            13 => self.edition.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.package.reflect_field_mut(),
            3 => self.dependency.reflect_field_mut(),
            10 => self.public_dependency.reflect_field_mut(),
            11 => self.weak_dependency.reflect_field_mut(),
            4 => self.message_type.reflect_field_mut(),
            5 => self.enum_type.reflect_field_mut(),
            6 => self.service.reflect_field_mut(),
            7 => self.extension.reflect_field_mut(),
            8 => self.options.reflect_field_mut(),
            9 => self.source_code_info.reflect_field_mut(),
            12 => self.syntax.reflect_field_mut(),
            13 => self.edition.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "package" => 2,
            "dependency" => 3,
            "public_dependency" => 10,
            "weak_dependency" => 11,
            "message_type" => 4,
            "enum_type" => 5,
            "service" => 6,
            "extension" => 7,
            "options" => 8,
            "source_code_info" => 9,
            "syntax" => 12,
            "edition" => 13,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct DescriptorProto_ExtensionRange {
    start: Option<i32>,
    end: Option<i32>,
    options: Option<MessagePtr<ExtensionRangeOptions>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for DescriptorProto_ExtensionRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for DescriptorProto_ExtensionRange {
    fn static_default() -> &'static Self {
        static VALUE: DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for DescriptorProto_ExtensionRange {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl DescriptorProto_ExtensionRange {
    pub const START_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const END_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }

    pub fn options(&self) -> &ExtensionRangeOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(ExtensionRangeOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<ExtensionRangeOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut ExtensionRangeOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(ExtensionRangeOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::StaticMessage for DescriptorProto_ExtensionRange {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ExtensionRange"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for DescriptorProto_ExtensionRange {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ExtensionRange"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.start = Some(Int32Codec::parse(&f)?),
                2 => self.end = Some(Int32Codec::parse(&f)?),
                3 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.start.as_ref() {
            Int32Codec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.end.as_ref() {
            Int32Codec::serialize(2, *v, out)?;
        }
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(3, v.as_ref(), out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for DescriptorProto_ExtensionRange {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.start.reflect_clear_field(),
            2 => self.end.reflect_clear_field(),
            3 => self.options.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.start.reflect_has_field(),
            2 => self.end.reflect_has_field(),
            3 => self.options.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.start.reflect_field(),
            2 => self.end.reflect_field(),
            3 => self.options.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_field_mut(),
            2 => self.end.reflect_field_mut(),
            3 => self.options.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,
            "options" => 3,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct DescriptorProto_ReservedRange {
    start: Option<i32>,
    end: Option<i32>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for DescriptorProto_ReservedRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for DescriptorProto_ReservedRange {
    fn static_default() -> &'static Self {
        static VALUE: DescriptorProto_ReservedRange = DescriptorProto_ReservedRange::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for DescriptorProto_ReservedRange {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl DescriptorProto_ReservedRange {
    pub const START_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const END_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }
}

impl protobuf_core::StaticMessage for DescriptorProto_ReservedRange {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ReservedRange"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for DescriptorProto_ReservedRange {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ReservedRange"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.start = Some(Int32Codec::parse(&f)?),
                2 => self.end = Some(Int32Codec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.start.as_ref() {
            Int32Codec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.end.as_ref() {
            Int32Codec::serialize(2, *v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for DescriptorProto_ReservedRange {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.start.reflect_clear_field(),
            2 => self.end.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.start.reflect_has_field(),
            2 => self.end.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.start.reflect_field(),
            2 => self.end.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_field_mut(),
            2 => self.end.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct DescriptorProto {
    name: Option<String>,
    field: Vec<MessagePtr<FieldDescriptorProto>>,
    extension: Vec<MessagePtr<FieldDescriptorProto>>,
    nested_type: Vec<MessagePtr<DescriptorProto>>,
    enum_type: Vec<MessagePtr<EnumDescriptorProto>>,
    extension_range: Vec<MessagePtr<DescriptorProto_ExtensionRange>>,
    oneof_decl: Vec<MessagePtr<OneofDescriptorProto>>,
    options: Option<MessagePtr<MessageOptions>>,
    reserved_range: Vec<MessagePtr<DescriptorProto_ReservedRange>>,
    reserved_name: Vec<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for DescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for DescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: DescriptorProto = DescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for DescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl DescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const FIELD_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const EXTENSION_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const NESTED_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const ENUM_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const EXTENSION_RANGE_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const ONEOF_DECL_FIELD_NUM: protobuf_core::FieldNumber = 8;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const RESERVED_RANGE_FIELD_NUM: protobuf_core::FieldNumber = 9;
    pub const RESERVED_NAME_FIELD_NUM: protobuf_core::FieldNumber = 10;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn field(&self) -> &[MessagePtr<FieldDescriptorProto>] {
        &self.field
    }

    pub fn field_mut(&mut self) -> &mut Vec<MessagePtr<FieldDescriptorProto>> {
        &mut self.field
    }

    pub fn field_len(&self) -> usize {
        self.field.len()
    }

    pub fn add_field(&mut self, v: FieldDescriptorProto) -> &mut MessagePtr<FieldDescriptorProto> {
        self.field.push(MessagePtr::new(v));
        self.field.last_mut().unwrap()
    }

    pub fn new_field(&mut self) -> &mut MessagePtr<FieldDescriptorProto> {
        self.field
            .push(<MessagePtr<FieldDescriptorProto>>::default());
        self.field.last_mut().unwrap()
    }

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn extension(&self) -> &[MessagePtr<FieldDescriptorProto>] {
        &self.extension
    }

    pub fn extension_mut(&mut self) -> &mut Vec<MessagePtr<FieldDescriptorProto>> {
        &mut self.extension
    }

    pub fn extension_len(&self) -> usize {
        self.extension.len()
    }

    pub fn add_extension(
        &mut self,
        v: FieldDescriptorProto,
    ) -> &mut MessagePtr<FieldDescriptorProto> {
        self.extension.push(MessagePtr::new(v));
        self.extension.last_mut().unwrap()
    }

    pub fn new_extension(&mut self) -> &mut MessagePtr<FieldDescriptorProto> {
        self.extension
            .push(<MessagePtr<FieldDescriptorProto>>::default());
        self.extension.last_mut().unwrap()
    }

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    pub fn nested_type(&self) -> &[MessagePtr<DescriptorProto>] {
        &self.nested_type
    }

    pub fn nested_type_mut(&mut self) -> &mut Vec<MessagePtr<DescriptorProto>> {
        &mut self.nested_type
    }

    pub fn nested_type_len(&self) -> usize {
        self.nested_type.len()
    }

    pub fn add_nested_type(&mut self, v: DescriptorProto) -> &mut MessagePtr<DescriptorProto> {
        self.nested_type.push(MessagePtr::new(v));
        self.nested_type.last_mut().unwrap()
    }

    pub fn new_nested_type(&mut self) -> &mut MessagePtr<DescriptorProto> {
        self.nested_type
            .push(<MessagePtr<DescriptorProto>>::default());
        self.nested_type.last_mut().unwrap()
    }

    pub fn clear_nested_type(&mut self) {
        self.nested_type.clear();
    }

    pub fn enum_type(&self) -> &[MessagePtr<EnumDescriptorProto>] {
        &self.enum_type
    }

    pub fn enum_type_mut(&mut self) -> &mut Vec<MessagePtr<EnumDescriptorProto>> {
        &mut self.enum_type
    }

    pub fn enum_type_len(&self) -> usize {
        self.enum_type.len()
    }

    pub fn add_enum_type(
        &mut self,
        v: EnumDescriptorProto,
    ) -> &mut MessagePtr<EnumDescriptorProto> {
        self.enum_type.push(MessagePtr::new(v));
        self.enum_type.last_mut().unwrap()
    }

    pub fn new_enum_type(&mut self) -> &mut MessagePtr<EnumDescriptorProto> {
        self.enum_type
            .push(<MessagePtr<EnumDescriptorProto>>::default());
        self.enum_type.last_mut().unwrap()
    }

    pub fn clear_enum_type(&mut self) {
        self.enum_type.clear();
    }

    pub fn extension_range(&self) -> &[MessagePtr<DescriptorProto_ExtensionRange>] {
        &self.extension_range
    }

    pub fn extension_range_mut(&mut self) -> &mut Vec<MessagePtr<DescriptorProto_ExtensionRange>> {
        &mut self.extension_range
    }

    pub fn extension_range_len(&self) -> usize {
        self.extension_range.len()
    }

    pub fn add_extension_range(
        &mut self,
        v: DescriptorProto_ExtensionRange,
    ) -> &mut MessagePtr<DescriptorProto_ExtensionRange> {
        self.extension_range.push(MessagePtr::new(v));
        self.extension_range.last_mut().unwrap()
    }

    pub fn new_extension_range(&mut self) -> &mut MessagePtr<DescriptorProto_ExtensionRange> {
        self.extension_range
            .push(<MessagePtr<DescriptorProto_ExtensionRange>>::default());
        self.extension_range.last_mut().unwrap()
    }

    pub fn clear_extension_range(&mut self) {
        self.extension_range.clear();
    }

    pub fn oneof_decl(&self) -> &[MessagePtr<OneofDescriptorProto>] {
        &self.oneof_decl
    }

    pub fn oneof_decl_mut(&mut self) -> &mut Vec<MessagePtr<OneofDescriptorProto>> {
        &mut self.oneof_decl
    }

    pub fn oneof_decl_len(&self) -> usize {
        self.oneof_decl.len()
    }

    pub fn add_oneof_decl(
        &mut self,
        v: OneofDescriptorProto,
    ) -> &mut MessagePtr<OneofDescriptorProto> {
        self.oneof_decl.push(MessagePtr::new(v));
        self.oneof_decl.last_mut().unwrap()
    }

    pub fn new_oneof_decl(&mut self) -> &mut MessagePtr<OneofDescriptorProto> {
        self.oneof_decl
            .push(<MessagePtr<OneofDescriptorProto>>::default());
        self.oneof_decl.last_mut().unwrap()
    }

    pub fn clear_oneof_decl(&mut self) {
        self.oneof_decl.clear();
    }

    pub fn options(&self) -> &MessageOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(MessageOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<MessageOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut MessageOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(MessageOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn reserved_range(&self) -> &[MessagePtr<DescriptorProto_ReservedRange>] {
        &self.reserved_range
    }

    pub fn reserved_range_mut(&mut self) -> &mut Vec<MessagePtr<DescriptorProto_ReservedRange>> {
        &mut self.reserved_range
    }

    pub fn reserved_range_len(&self) -> usize {
        self.reserved_range.len()
    }

    pub fn add_reserved_range(
        &mut self,
        v: DescriptorProto_ReservedRange,
    ) -> &mut MessagePtr<DescriptorProto_ReservedRange> {
        self.reserved_range.push(MessagePtr::new(v));
        self.reserved_range.last_mut().unwrap()
    }

    pub fn new_reserved_range(&mut self) -> &mut MessagePtr<DescriptorProto_ReservedRange> {
        self.reserved_range
            .push(<MessagePtr<DescriptorProto_ReservedRange>>::default());
        self.reserved_range.last_mut().unwrap()
    }

    pub fn clear_reserved_range(&mut self) {
        self.reserved_range.clear();
    }

    pub fn reserved_name(&self) -> &[String] {
        &self.reserved_name
    }

    pub fn reserved_name_mut(&mut self) -> &mut Vec<String> {
        &mut self.reserved_name
    }

    pub fn reserved_name_len(&self) -> usize {
        self.reserved_name.len()
    }

    pub fn add_reserved_name(&mut self, v: String) -> &mut String {
        self.reserved_name.push(v);
        self.reserved_name.last_mut().unwrap()
    }

    pub fn new_reserved_name(&mut self) -> &mut String {
        self.reserved_name.push(<String>::default());
        self.reserved_name.last_mut().unwrap()
    }

    pub fn clear_reserved_name(&mut self) {
        self.reserved_name.clear();
    }
}

impl protobuf_core::StaticMessage for DescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for DescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.DescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.field.push(MessagePtr::new(v?));
                    }
                }
                6 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.extension.push(MessagePtr::new(v?));
                    }
                }
                3 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.nested_type.push(MessagePtr::new(v?));
                    }
                }
                4 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.enum_type.push(MessagePtr::new(v?));
                    }
                }
                5 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.extension_range.push(MessagePtr::new(v?));
                    }
                }
                8 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.oneof_decl.push(MessagePtr::new(v?));
                    }
                }
                7 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                9 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.reserved_range.push(MessagePtr::new(v?));
                    }
                }
                10 => {
                    for v in StringCodec::parse_repeated(&f) {
                        self.reserved_name.push(v?);
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        MessageCodec::serialize_repeated(2, &self.field, out)?;
        MessageCodec::serialize_repeated(6, &self.extension, out)?;
        MessageCodec::serialize_repeated(3, &self.nested_type, out)?;
        MessageCodec::serialize_repeated(4, &self.enum_type, out)?;
        MessageCodec::serialize_repeated(5, &self.extension_range, out)?;
        MessageCodec::serialize_repeated(8, &self.oneof_decl, out)?;
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(7, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(9, &self.reserved_range, out)?;
        StringCodec::serialize_repeated(10, &self.reserved_name, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for DescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("field"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("nested_type"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("enum_type"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension_range"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("oneof_decl"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_range"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_name"),
                number: 10,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.field.reflect_clear_field(),
            6 => self.extension.reflect_clear_field(),
            3 => self.nested_type.reflect_clear_field(),
            4 => self.enum_type.reflect_clear_field(),
            5 => self.extension_range.reflect_clear_field(),
            8 => self.oneof_decl.reflect_clear_field(),
            7 => self.options.reflect_clear_field(),
            9 => self.reserved_range.reflect_clear_field(),
            10 => self.reserved_name.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.field.reflect_has_field(),
            6 => self.extension.reflect_has_field(),
            3 => self.nested_type.reflect_has_field(),
            4 => self.enum_type.reflect_has_field(),
            5 => self.extension_range.reflect_has_field(),
            8 => self.oneof_decl.reflect_has_field(),
            7 => self.options.reflect_has_field(),
            9 => self.reserved_range.reflect_has_field(),
            10 => self.reserved_name.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.field.reflect_field(),
            6 => self.extension.reflect_field(),
            3 => self.nested_type.reflect_field(),
            4 => self.enum_type.reflect_field(),
            5 => self.extension_range.reflect_field(),
            8 => self.oneof_decl.reflect_field(),
            7 => self.options.reflect_field(),
            9 => self.reserved_range.reflect_field(),
            10 => self.reserved_name.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.field.reflect_field_mut(),
            6 => self.extension.reflect_field_mut(),
            3 => self.nested_type.reflect_field_mut(),
            4 => self.enum_type.reflect_field_mut(),
            5 => self.extension_range.reflect_field_mut(),
            8 => self.oneof_decl.reflect_field_mut(),
            7 => self.options.reflect_field_mut(),
            9 => self.reserved_range.reflect_field_mut(),
            10 => self.reserved_name.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "field" => 2,
            "extension" => 6,
            "nested_type" => 3,
            "enum_type" => 4,
            "extension_range" => 5,
            "oneof_decl" => 8,
            "options" => 7,
            "reserved_range" => 9,
            "reserved_name" => 10,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum ExtensionRangeOptions_VerificationState {
    DECLARATION = 0,
    UNVERIFIED = 1,
}

impl ExtensionRangeOptions_VerificationState {}

impl core::default::Default for ExtensionRangeOptions_VerificationState {
    fn default() -> Self {
        Self::DECLARATION
    }
}

impl common::const_default::ConstDefault for ExtensionRangeOptions_VerificationState {
    const DEFAULT: Self = Self::DECLARATION;
}

impl ReflectStatic for ExtensionRangeOptions_VerificationState {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for ExtensionRangeOptions_VerificationState {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => ExtensionRangeOptions_VerificationState::DECLARATION,
            1 => ExtensionRangeOptions_VerificationState::UNVERIFIED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "DECLARATION" => Self::DECLARATION,
            "UNVERIFIED" => Self::UNVERIFIED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::DECLARATION => "DECLARATION",
            Self::UNVERIFIED => "UNVERIFIED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for ExtensionRangeOptions_VerificationState {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct ExtensionRangeOptions_Declaration {
    number: Option<i32>,
    full_name: Option<String>,
    typ: Option<String>,
    reserved: Option<bool>,
    repeated: Option<bool>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for ExtensionRangeOptions_Declaration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for ExtensionRangeOptions_Declaration {
    fn static_default() -> &'static Self {
        static VALUE: ExtensionRangeOptions_Declaration =
            ExtensionRangeOptions_Declaration::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for ExtensionRangeOptions_Declaration {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl ExtensionRangeOptions_Declaration {
    pub const NUMBER_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const FULL_NAME_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const TYP_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const RESERVED_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const REPEATED_FIELD_NUM: protobuf_core::FieldNumber = 6;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or_default()
    }
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    pub fn set_number<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.number = Some(v);
    }
    pub fn number_mut(&mut self) -> &mut i32 {
        self.number.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_number(&mut self) {
        self.number = None;
    }

    pub fn full_name(&self) -> &str {
        self.full_name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_full_name(&self) -> bool {
        self.full_name.is_some()
    }
    pub fn set_full_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.full_name = Some(v);
    }
    pub fn full_name_mut(&mut self) -> &mut String {
        self.full_name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_full_name(&mut self) {
        self.full_name = None;
    }

    pub fn typ(&self) -> &str {
        self.typ.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }
    pub fn set_typ<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.typ = Some(v);
    }
    pub fn typ_mut(&mut self) -> &mut String {
        self.typ.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_typ(&mut self) {
        self.typ = None;
    }

    pub fn reserved(&self) -> bool {
        self.reserved.unwrap_or_default()
    }
    pub fn has_reserved(&self) -> bool {
        self.reserved.is_some()
    }
    pub fn set_reserved<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.reserved = Some(v);
    }
    pub fn reserved_mut(&mut self) -> &mut bool {
        self.reserved.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_reserved(&mut self) {
        self.reserved = None;
    }

    pub fn repeated(&self) -> bool {
        self.repeated.unwrap_or_default()
    }
    pub fn has_repeated(&self) -> bool {
        self.repeated.is_some()
    }
    pub fn set_repeated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.repeated = Some(v);
    }
    pub fn repeated_mut(&mut self) -> &mut bool {
        self.repeated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_repeated(&mut self) {
        self.repeated = None;
    }
}

impl protobuf_core::StaticMessage for ExtensionRangeOptions_Declaration {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.ExtensionRangeOptions.Declaration"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for ExtensionRangeOptions_Declaration {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.ExtensionRangeOptions.Declaration"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.number = Some(Int32Codec::parse(&f)?),
                2 => self.full_name = Some(StringCodec::parse(&f)?),
                3 => self.typ = Some(StringCodec::parse(&f)?),
                5 => self.reserved = Some(BoolCodec::parse(&f)?),
                6 => self.repeated = Some(BoolCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.number.as_ref() {
            Int32Codec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.full_name.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.typ.as_ref() {
            StringCodec::serialize(3, v, out)?;
        }
        if let Some(v) = self.reserved.as_ref() {
            BoolCodec::serialize(5, *v, out)?;
        }
        if let Some(v) = self.repeated.as_ref() {
            BoolCodec::serialize(6, *v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for ExtensionRangeOptions_Declaration {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("number"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("full_name"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("type"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("repeated"),
                number: 6,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.number.reflect_clear_field(),
            2 => self.full_name.reflect_clear_field(),
            3 => self.typ.reflect_clear_field(),
            5 => self.reserved.reflect_clear_field(),
            6 => self.repeated.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.number.reflect_has_field(),
            2 => self.full_name.reflect_has_field(),
            3 => self.typ.reflect_has_field(),
            5 => self.reserved.reflect_has_field(),
            6 => self.repeated.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.number.reflect_field(),
            2 => self.full_name.reflect_field(),
            3 => self.typ.reflect_field(),
            5 => self.reserved.reflect_field(),
            6 => self.repeated.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.number.reflect_field_mut(),
            2 => self.full_name.reflect_field_mut(),
            3 => self.typ.reflect_field_mut(),
            5 => self.reserved.reflect_field_mut(),
            6 => self.repeated.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "number" => 1,
            "full_name" => 2,
            "type" => 3,
            "reserved" => 5,
            "repeated" => 6,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct ExtensionRangeOptions {
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    declaration: Vec<MessagePtr<ExtensionRangeOptions_Declaration>>,
    features: Option<MessagePtr<FeatureSet>>,
    verification: Option<ExtensionRangeOptions_VerificationState>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for ExtensionRangeOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for ExtensionRangeOptions {
    fn static_default() -> &'static Self {
        static VALUE: ExtensionRangeOptions = ExtensionRangeOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for ExtensionRangeOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl ExtensionRangeOptions {
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;
    pub const DECLARATION_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 50;
    pub const VERIFICATION_FIELD_NUM: protobuf_core::FieldNumber = 3;

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }

    pub fn declaration(&self) -> &[MessagePtr<ExtensionRangeOptions_Declaration>] {
        &self.declaration
    }

    pub fn declaration_mut(&mut self) -> &mut Vec<MessagePtr<ExtensionRangeOptions_Declaration>> {
        &mut self.declaration
    }

    pub fn declaration_len(&self) -> usize {
        self.declaration.len()
    }

    pub fn add_declaration(
        &mut self,
        v: ExtensionRangeOptions_Declaration,
    ) -> &mut MessagePtr<ExtensionRangeOptions_Declaration> {
        self.declaration.push(MessagePtr::new(v));
        self.declaration.last_mut().unwrap()
    }

    pub fn new_declaration(&mut self) -> &mut MessagePtr<ExtensionRangeOptions_Declaration> {
        self.declaration
            .push(<MessagePtr<ExtensionRangeOptions_Declaration>>::default());
        self.declaration.last_mut().unwrap()
    }

    pub fn clear_declaration(&mut self) {
        self.declaration.clear();
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn verification(&self) -> ExtensionRangeOptions_VerificationState {
        self.verification
            .unwrap_or(ExtensionRangeOptions_VerificationState::UNVERIFIED)
    }
    pub fn has_verification(&self) -> bool {
        self.verification.is_some()
    }
    pub fn set_verification<V: ::core::convert::Into<ExtensionRangeOptions_VerificationState>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.verification = Some(v);
    }
    pub fn verification_mut(&mut self) -> &mut ExtensionRangeOptions_VerificationState {
        self.verification
            .get_or_insert_with(|| <ExtensionRangeOptions_VerificationState>::default())
    }
    pub fn clear_verification(&mut self) {
        self.verification = None;
    }
}

impl protobuf_core::StaticMessage for ExtensionRangeOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.ExtensionRangeOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for ExtensionRangeOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.ExtensionRangeOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }
                2 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.declaration.push(MessagePtr::new(v?));
                    }
                }
                50 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                3 => self.verification = Some(EnumCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        MessageCodec::serialize_repeated(2, &self.declaration, out)?;
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(50, v.as_ref(), out)?;
        }
        if let Some(v) = self.verification.as_ref() {
            EnumCodec::serialize(3, v, out)?;
        }
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for ExtensionRangeOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("declaration"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 50,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("verification"),
                number: 3,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            999 => self.uninterpreted_option.reflect_clear_field(),
            2 => self.declaration.reflect_clear_field(),
            50 => self.features.reflect_clear_field(),
            3 => self.verification.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            999 => self.uninterpreted_option.reflect_has_field(),
            2 => self.declaration.reflect_has_field(),
            50 => self.features.reflect_has_field(),
            3 => self.verification.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            999 => self.uninterpreted_option.reflect_field(),
            2 => self.declaration.reflect_field(),
            50 => self.features.reflect_field(),
            3 => self.verification.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            999 => self.uninterpreted_option.reflect_field_mut(),
            2 => self.declaration.reflect_field_mut(),
            50 => self.features.reflect_field_mut(),
            3 => self.verification.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "uninterpreted_option" => 999,
            "declaration" => 2,
            "features" => 50,
            "verification" => 3,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldDescriptorProto_Type {
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18,
}

impl FieldDescriptorProto_Type {}

impl core::default::Default for FieldDescriptorProto_Type {
    fn default() -> Self {
        Self::TYPE_DOUBLE
    }
}

impl common::const_default::ConstDefault for FieldDescriptorProto_Type {
    const DEFAULT: Self = Self::TYPE_DOUBLE;
}

impl ReflectStatic for FieldDescriptorProto_Type {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldDescriptorProto_Type {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            1 => FieldDescriptorProto_Type::TYPE_DOUBLE,
            2 => FieldDescriptorProto_Type::TYPE_FLOAT,
            3 => FieldDescriptorProto_Type::TYPE_INT64,
            4 => FieldDescriptorProto_Type::TYPE_UINT64,
            5 => FieldDescriptorProto_Type::TYPE_INT32,
            6 => FieldDescriptorProto_Type::TYPE_FIXED64,
            7 => FieldDescriptorProto_Type::TYPE_FIXED32,
            8 => FieldDescriptorProto_Type::TYPE_BOOL,
            9 => FieldDescriptorProto_Type::TYPE_STRING,
            10 => FieldDescriptorProto_Type::TYPE_GROUP,
            11 => FieldDescriptorProto_Type::TYPE_MESSAGE,
            12 => FieldDescriptorProto_Type::TYPE_BYTES,
            13 => FieldDescriptorProto_Type::TYPE_UINT32,
            14 => FieldDescriptorProto_Type::TYPE_ENUM,
            15 => FieldDescriptorProto_Type::TYPE_SFIXED32,
            16 => FieldDescriptorProto_Type::TYPE_SFIXED64,
            17 => FieldDescriptorProto_Type::TYPE_SINT32,
            18 => FieldDescriptorProto_Type::TYPE_SINT64,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "TYPE_DOUBLE" => Self::TYPE_DOUBLE,
            "TYPE_FLOAT" => Self::TYPE_FLOAT,
            "TYPE_INT64" => Self::TYPE_INT64,
            "TYPE_UINT64" => Self::TYPE_UINT64,
            "TYPE_INT32" => Self::TYPE_INT32,
            "TYPE_FIXED64" => Self::TYPE_FIXED64,
            "TYPE_FIXED32" => Self::TYPE_FIXED32,
            "TYPE_BOOL" => Self::TYPE_BOOL,
            "TYPE_STRING" => Self::TYPE_STRING,
            "TYPE_GROUP" => Self::TYPE_GROUP,
            "TYPE_MESSAGE" => Self::TYPE_MESSAGE,
            "TYPE_BYTES" => Self::TYPE_BYTES,
            "TYPE_UINT32" => Self::TYPE_UINT32,
            "TYPE_ENUM" => Self::TYPE_ENUM,
            "TYPE_SFIXED32" => Self::TYPE_SFIXED32,
            "TYPE_SFIXED64" => Self::TYPE_SFIXED64,
            "TYPE_SINT32" => Self::TYPE_SINT32,
            "TYPE_SINT64" => Self::TYPE_SINT64,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::TYPE_DOUBLE => "TYPE_DOUBLE",
            Self::TYPE_FLOAT => "TYPE_FLOAT",
            Self::TYPE_INT64 => "TYPE_INT64",
            Self::TYPE_UINT64 => "TYPE_UINT64",
            Self::TYPE_INT32 => "TYPE_INT32",
            Self::TYPE_FIXED64 => "TYPE_FIXED64",
            Self::TYPE_FIXED32 => "TYPE_FIXED32",
            Self::TYPE_BOOL => "TYPE_BOOL",
            Self::TYPE_STRING => "TYPE_STRING",
            Self::TYPE_GROUP => "TYPE_GROUP",
            Self::TYPE_MESSAGE => "TYPE_MESSAGE",
            Self::TYPE_BYTES => "TYPE_BYTES",
            Self::TYPE_UINT32 => "TYPE_UINT32",
            Self::TYPE_ENUM => "TYPE_ENUM",
            Self::TYPE_SFIXED32 => "TYPE_SFIXED32",
            Self::TYPE_SFIXED64 => "TYPE_SFIXED64",
            Self::TYPE_SINT32 => "TYPE_SINT32",
            Self::TYPE_SINT64 => "TYPE_SINT64",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldDescriptorProto_Type {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldDescriptorProto_Label {
    LABEL_OPTIONAL = 1,
    LABEL_REQUIRED = 2,
    LABEL_REPEATED = 3,
}

impl FieldDescriptorProto_Label {}

impl core::default::Default for FieldDescriptorProto_Label {
    fn default() -> Self {
        Self::LABEL_OPTIONAL
    }
}

impl common::const_default::ConstDefault for FieldDescriptorProto_Label {
    const DEFAULT: Self = Self::LABEL_OPTIONAL;
}

impl ReflectStatic for FieldDescriptorProto_Label {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldDescriptorProto_Label {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            1 => FieldDescriptorProto_Label::LABEL_OPTIONAL,
            2 => FieldDescriptorProto_Label::LABEL_REQUIRED,
            3 => FieldDescriptorProto_Label::LABEL_REPEATED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "LABEL_OPTIONAL" => Self::LABEL_OPTIONAL,
            "LABEL_REQUIRED" => Self::LABEL_REQUIRED,
            "LABEL_REPEATED" => Self::LABEL_REPEATED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::LABEL_OPTIONAL => "LABEL_OPTIONAL",
            Self::LABEL_REQUIRED => "LABEL_REQUIRED",
            Self::LABEL_REPEATED => "LABEL_REPEATED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldDescriptorProto_Label {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FieldDescriptorProto {
    name: Option<String>,
    number: Option<i32>,
    label: Option<FieldDescriptorProto_Label>,
    typ: Option<FieldDescriptorProto_Type>,
    type_name: Option<String>,
    extendee: Option<String>,
    default_value: Option<String>,
    oneof_index: Option<i32>,
    json_name: Option<String>,
    options: Option<MessagePtr<FieldOptions>>,
    proto3_optional: Option<bool>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FieldDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FieldDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: FieldDescriptorProto = FieldDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FieldDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FieldDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const NUMBER_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const LABEL_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const TYP_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const TYPE_NAME_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const EXTENDEE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const DEFAULT_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const ONEOF_INDEX_FIELD_NUM: protobuf_core::FieldNumber = 9;
    pub const JSON_NAME_FIELD_NUM: protobuf_core::FieldNumber = 10;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 8;
    pub const PROTO3_OPTIONAL_FIELD_NUM: protobuf_core::FieldNumber = 17;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn number(&self) -> i32 {
        self.number.unwrap_or_default()
    }
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    pub fn set_number<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.number = Some(v);
    }
    pub fn number_mut(&mut self) -> &mut i32 {
        self.number.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_number(&mut self) {
        self.number = None;
    }

    pub fn label(&self) -> FieldDescriptorProto_Label {
        self.label.unwrap_or_default()
    }
    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }
    pub fn set_label<V: ::core::convert::Into<FieldDescriptorProto_Label>>(&mut self, v: V) {
        let v = v.into();
        self.label = Some(v);
    }
    pub fn label_mut(&mut self) -> &mut FieldDescriptorProto_Label {
        self.label
            .get_or_insert_with(|| <FieldDescriptorProto_Label>::default())
    }
    pub fn clear_label(&mut self) {
        self.label = None;
    }

    pub fn typ(&self) -> FieldDescriptorProto_Type {
        self.typ.unwrap_or_default()
    }
    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }
    pub fn set_typ<V: ::core::convert::Into<FieldDescriptorProto_Type>>(&mut self, v: V) {
        let v = v.into();
        self.typ = Some(v);
    }
    pub fn typ_mut(&mut self) -> &mut FieldDescriptorProto_Type {
        self.typ
            .get_or_insert_with(|| <FieldDescriptorProto_Type>::default())
    }
    pub fn clear_typ(&mut self) {
        self.typ = None;
    }

    pub fn type_name(&self) -> &str {
        self.type_name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }
    pub fn set_type_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.type_name = Some(v);
    }
    pub fn type_name_mut(&mut self) -> &mut String {
        self.type_name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_type_name(&mut self) {
        self.type_name = None;
    }

    pub fn extendee(&self) -> &str {
        self.extendee.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }
    pub fn set_extendee<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.extendee = Some(v);
    }
    pub fn extendee_mut(&mut self) -> &mut String {
        self.extendee.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_extendee(&mut self) {
        self.extendee = None;
    }

    pub fn default_value(&self) -> &str {
        self.default_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }
    pub fn set_default_value<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.default_value = Some(v);
    }
    pub fn default_value_mut(&mut self) -> &mut String {
        self.default_value
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value = None;
    }

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or_default()
    }
    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }
    pub fn set_oneof_index<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.oneof_index = Some(v);
    }
    pub fn oneof_index_mut(&mut self) -> &mut i32 {
        self.oneof_index.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = None;
    }

    pub fn json_name(&self) -> &str {
        self.json_name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }
    pub fn set_json_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.json_name = Some(v);
    }
    pub fn json_name_mut(&mut self) -> &mut String {
        self.json_name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_json_name(&mut self) {
        self.json_name = None;
    }

    pub fn options(&self) -> &FieldOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FieldOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<FieldOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut FieldOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(FieldOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn proto3_optional(&self) -> bool {
        self.proto3_optional.unwrap_or_default()
    }
    pub fn has_proto3_optional(&self) -> bool {
        self.proto3_optional.is_some()
    }
    pub fn set_proto3_optional<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.proto3_optional = Some(v);
    }
    pub fn proto3_optional_mut(&mut self) -> &mut bool {
        self.proto3_optional
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_proto3_optional(&mut self) {
        self.proto3_optional = None;
    }
}

impl protobuf_core::StaticMessage for FieldDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FieldDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FieldDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FieldDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                3 => self.number = Some(Int32Codec::parse(&f)?),
                4 => self.label = Some(EnumCodec::parse(&f)?),
                5 => self.typ = Some(EnumCodec::parse(&f)?),
                6 => self.type_name = Some(StringCodec::parse(&f)?),
                2 => self.extendee = Some(StringCodec::parse(&f)?),
                7 => self.default_value = Some(StringCodec::parse(&f)?),
                9 => self.oneof_index = Some(Int32Codec::parse(&f)?),
                10 => self.json_name = Some(StringCodec::parse(&f)?),
                8 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                17 => self.proto3_optional = Some(BoolCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.number.as_ref() {
            Int32Codec::serialize(3, *v, out)?;
        }
        if let Some(v) = self.label.as_ref() {
            EnumCodec::serialize(4, v, out)?;
        }
        if let Some(v) = self.typ.as_ref() {
            EnumCodec::serialize(5, v, out)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            StringCodec::serialize(6, v, out)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            StringCodec::serialize(7, v, out)?;
        }
        if let Some(v) = self.oneof_index.as_ref() {
            Int32Codec::serialize(9, *v, out)?;
        }
        if let Some(v) = self.json_name.as_ref() {
            StringCodec::serialize(10, v, out)?;
        }
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(8, v.as_ref(), out)?;
        }
        if let Some(v) = self.proto3_optional.as_ref() {
            BoolCodec::serialize(17, *v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FieldDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("number"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("label"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("type"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("type_name"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extendee"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("default_value"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("oneof_index"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("json_name"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("proto3_optional"),
                number: 17,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            3 => self.number.reflect_clear_field(),
            4 => self.label.reflect_clear_field(),
            5 => self.typ.reflect_clear_field(),
            6 => self.type_name.reflect_clear_field(),
            2 => self.extendee.reflect_clear_field(),
            7 => self.default_value.reflect_clear_field(),
            9 => self.oneof_index.reflect_clear_field(),
            10 => self.json_name.reflect_clear_field(),
            8 => self.options.reflect_clear_field(),
            17 => self.proto3_optional.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            3 => self.number.reflect_has_field(),
            4 => self.label.reflect_has_field(),
            5 => self.typ.reflect_has_field(),
            6 => self.type_name.reflect_has_field(),
            2 => self.extendee.reflect_has_field(),
            7 => self.default_value.reflect_has_field(),
            9 => self.oneof_index.reflect_has_field(),
            10 => self.json_name.reflect_has_field(),
            8 => self.options.reflect_has_field(),
            17 => self.proto3_optional.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            3 => self.number.reflect_field(),
            4 => self.label.reflect_field(),
            5 => self.typ.reflect_field(),
            6 => self.type_name.reflect_field(),
            2 => self.extendee.reflect_field(),
            7 => self.default_value.reflect_field(),
            9 => self.oneof_index.reflect_field(),
            10 => self.json_name.reflect_field(),
            8 => self.options.reflect_field(),
            17 => self.proto3_optional.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            3 => self.number.reflect_field_mut(),
            4 => self.label.reflect_field_mut(),
            5 => self.typ.reflect_field_mut(),
            6 => self.type_name.reflect_field_mut(),
            2 => self.extendee.reflect_field_mut(),
            7 => self.default_value.reflect_field_mut(),
            9 => self.oneof_index.reflect_field_mut(),
            10 => self.json_name.reflect_field_mut(),
            8 => self.options.reflect_field_mut(),
            17 => self.proto3_optional.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "number" => 3,
            "label" => 4,
            "type" => 5,
            "type_name" => 6,
            "extendee" => 2,
            "default_value" => 7,
            "oneof_index" => 9,
            "json_name" => 10,
            "options" => 8,
            "proto3_optional" => 17,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct OneofDescriptorProto {
    name: Option<String>,
    options: Option<MessagePtr<OneofOptions>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for OneofDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for OneofDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: OneofDescriptorProto = OneofDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for OneofDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl OneofDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn options(&self) -> &OneofOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(OneofOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<OneofOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut OneofOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(OneofOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::StaticMessage for OneofDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.OneofDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for OneofDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.OneofDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(2, v.as_ref(), out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for OneofDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.options.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.options.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.options.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.options.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "options" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct EnumDescriptorProto_EnumReservedRange {
    start: Option<i32>,
    end: Option<i32>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for EnumDescriptorProto_EnumReservedRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for EnumDescriptorProto_EnumReservedRange {
    fn static_default() -> &'static Self {
        static VALUE: EnumDescriptorProto_EnumReservedRange =
            EnumDescriptorProto_EnumReservedRange::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for EnumDescriptorProto_EnumReservedRange {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl EnumDescriptorProto_EnumReservedRange {
    pub const START_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const END_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }
}

impl protobuf_core::StaticMessage for EnumDescriptorProto_EnumReservedRange {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto.EnumReservedRange"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for EnumDescriptorProto_EnumReservedRange {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto.EnumReservedRange"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.start = Some(Int32Codec::parse(&f)?),
                2 => self.end = Some(Int32Codec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.start.as_ref() {
            Int32Codec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.end.as_ref() {
            Int32Codec::serialize(2, *v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for EnumDescriptorProto_EnumReservedRange {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.start.reflect_clear_field(),
            2 => self.end.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.start.reflect_has_field(),
            2 => self.end.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.start.reflect_field(),
            2 => self.end.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_field_mut(),
            2 => self.end.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct EnumDescriptorProto {
    name: Option<String>,
    value: Vec<MessagePtr<EnumValueDescriptorProto>>,
    options: Option<MessagePtr<EnumOptions>>,
    reserved_range: Vec<MessagePtr<EnumDescriptorProto_EnumReservedRange>>,
    reserved_name: Vec<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for EnumDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for EnumDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: EnumDescriptorProto = EnumDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for EnumDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl EnumDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const VALUE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const RESERVED_RANGE_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const RESERVED_NAME_FIELD_NUM: protobuf_core::FieldNumber = 5;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn value(&self) -> &[MessagePtr<EnumValueDescriptorProto>] {
        &self.value
    }

    pub fn value_mut(&mut self) -> &mut Vec<MessagePtr<EnumValueDescriptorProto>> {
        &mut self.value
    }

    pub fn value_len(&self) -> usize {
        self.value.len()
    }

    pub fn add_value(
        &mut self,
        v: EnumValueDescriptorProto,
    ) -> &mut MessagePtr<EnumValueDescriptorProto> {
        self.value.push(MessagePtr::new(v));
        self.value.last_mut().unwrap()
    }

    pub fn new_value(&mut self) -> &mut MessagePtr<EnumValueDescriptorProto> {
        self.value
            .push(<MessagePtr<EnumValueDescriptorProto>>::default());
        self.value.last_mut().unwrap()
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn options(&self) -> &EnumOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(EnumOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<EnumOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut EnumOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(EnumOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn reserved_range(&self) -> &[MessagePtr<EnumDescriptorProto_EnumReservedRange>] {
        &self.reserved_range
    }

    pub fn reserved_range_mut(
        &mut self,
    ) -> &mut Vec<MessagePtr<EnumDescriptorProto_EnumReservedRange>> {
        &mut self.reserved_range
    }

    pub fn reserved_range_len(&self) -> usize {
        self.reserved_range.len()
    }

    pub fn add_reserved_range(
        &mut self,
        v: EnumDescriptorProto_EnumReservedRange,
    ) -> &mut MessagePtr<EnumDescriptorProto_EnumReservedRange> {
        self.reserved_range.push(MessagePtr::new(v));
        self.reserved_range.last_mut().unwrap()
    }

    pub fn new_reserved_range(&mut self) -> &mut MessagePtr<EnumDescriptorProto_EnumReservedRange> {
        self.reserved_range
            .push(<MessagePtr<EnumDescriptorProto_EnumReservedRange>>::default());
        self.reserved_range.last_mut().unwrap()
    }

    pub fn clear_reserved_range(&mut self) {
        self.reserved_range.clear();
    }

    pub fn reserved_name(&self) -> &[String] {
        &self.reserved_name
    }

    pub fn reserved_name_mut(&mut self) -> &mut Vec<String> {
        &mut self.reserved_name
    }

    pub fn reserved_name_len(&self) -> usize {
        self.reserved_name.len()
    }

    pub fn add_reserved_name(&mut self, v: String) -> &mut String {
        self.reserved_name.push(v);
        self.reserved_name.last_mut().unwrap()
    }

    pub fn new_reserved_name(&mut self) -> &mut String {
        self.reserved_name.push(<String>::default());
        self.reserved_name.last_mut().unwrap()
    }

    pub fn clear_reserved_name(&mut self) {
        self.reserved_name.clear();
    }
}

impl protobuf_core::StaticMessage for EnumDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for EnumDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.value.push(MessagePtr::new(v?));
                    }
                }
                3 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                4 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.reserved_range.push(MessagePtr::new(v?));
                    }
                }
                5 => {
                    for v in StringCodec::parse_repeated(&f) {
                        self.reserved_name.push(v?);
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        MessageCodec::serialize_repeated(2, &self.value, out)?;
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(3, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(4, &self.reserved_range, out)?;
        StringCodec::serialize_repeated(5, &self.reserved_name, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for EnumDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("value"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_range"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_name"),
                number: 5,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.value.reflect_clear_field(),
            3 => self.options.reflect_clear_field(),
            4 => self.reserved_range.reflect_clear_field(),
            5 => self.reserved_name.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.value.reflect_has_field(),
            3 => self.options.reflect_has_field(),
            4 => self.reserved_range.reflect_has_field(),
            5 => self.reserved_name.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.value.reflect_field(),
            3 => self.options.reflect_field(),
            4 => self.reserved_range.reflect_field(),
            5 => self.reserved_name.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.value.reflect_field_mut(),
            3 => self.options.reflect_field_mut(),
            4 => self.reserved_range.reflect_field_mut(),
            5 => self.reserved_name.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "value" => 2,
            "options" => 3,
            "reserved_range" => 4,
            "reserved_name" => 5,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct EnumValueDescriptorProto {
    name: Option<String>,
    number: Option<i32>,
    options: Option<MessagePtr<EnumValueOptions>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for EnumValueDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for EnumValueDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: EnumValueDescriptorProto = EnumValueDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for EnumValueDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl EnumValueDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const NUMBER_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 3;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn number(&self) -> i32 {
        self.number.unwrap_or_default()
    }
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    pub fn set_number<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.number = Some(v);
    }
    pub fn number_mut(&mut self) -> &mut i32 {
        self.number.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_number(&mut self) {
        self.number = None;
    }

    pub fn options(&self) -> &EnumValueOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(EnumValueOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<EnumValueOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut EnumValueOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(EnumValueOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::StaticMessage for EnumValueDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.EnumValueDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for EnumValueDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.EnumValueDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => self.number = Some(Int32Codec::parse(&f)?),
                3 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.number.as_ref() {
            Int32Codec::serialize(2, *v, out)?;
        }
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(3, v.as_ref(), out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for EnumValueDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("number"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.number.reflect_clear_field(),
            3 => self.options.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.number.reflect_has_field(),
            3 => self.options.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.number.reflect_field(),
            3 => self.options.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.number.reflect_field_mut(),
            3 => self.options.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "number" => 2,
            "options" => 3,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct ServiceDescriptorProto {
    name: Option<String>,
    method: Vec<MessagePtr<MethodDescriptorProto>>,
    options: Option<MessagePtr<ServiceOptions>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for ServiceDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for ServiceDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: ServiceDescriptorProto = ServiceDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for ServiceDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl ServiceDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const METHOD_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 3;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn method(&self) -> &[MessagePtr<MethodDescriptorProto>] {
        &self.method
    }

    pub fn method_mut(&mut self) -> &mut Vec<MessagePtr<MethodDescriptorProto>> {
        &mut self.method
    }

    pub fn method_len(&self) -> usize {
        self.method.len()
    }

    pub fn add_method(
        &mut self,
        v: MethodDescriptorProto,
    ) -> &mut MessagePtr<MethodDescriptorProto> {
        self.method.push(MessagePtr::new(v));
        self.method.last_mut().unwrap()
    }

    pub fn new_method(&mut self) -> &mut MessagePtr<MethodDescriptorProto> {
        self.method
            .push(<MessagePtr<MethodDescriptorProto>>::default());
        self.method.last_mut().unwrap()
    }

    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    pub fn options(&self) -> &ServiceOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(ServiceOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<ServiceOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut ServiceOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(ServiceOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::StaticMessage for ServiceDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.ServiceDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for ServiceDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.ServiceDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.method.push(MessagePtr::new(v?));
                    }
                }
                3 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        MessageCodec::serialize_repeated(2, &self.method, out)?;
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(3, v.as_ref(), out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for ServiceDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("method"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.method.reflect_clear_field(),
            3 => self.options.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.method.reflect_has_field(),
            3 => self.options.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.method.reflect_field(),
            3 => self.options.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.method.reflect_field_mut(),
            3 => self.options.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "method" => 2,
            "options" => 3,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct MethodDescriptorProto {
    name: Option<String>,
    input_type: Option<String>,
    output_type: Option<String>,
    options: Option<MessagePtr<MethodOptions>>,
    client_streaming: Option<bool>,
    server_streaming: Option<bool>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for MethodDescriptorProto {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for MethodDescriptorProto {
    fn static_default() -> &'static Self {
        static VALUE: MethodDescriptorProto = MethodDescriptorProto::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for MethodDescriptorProto {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl MethodDescriptorProto {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const INPUT_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const OUTPUT_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const OPTIONS_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const CLIENT_STREAMING_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const SERVER_STREAMING_FIELD_NUM: protobuf_core::FieldNumber = 6;

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn input_type(&self) -> &str {
        self.input_type.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }
    pub fn set_input_type<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.input_type = Some(v);
    }
    pub fn input_type_mut(&mut self) -> &mut String {
        self.input_type.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_input_type(&mut self) {
        self.input_type = None;
    }

    pub fn output_type(&self) -> &str {
        self.output_type.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }
    pub fn set_output_type<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.output_type = Some(v);
    }
    pub fn output_type_mut(&mut self) -> &mut String {
        self.output_type.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_output_type(&mut self) {
        self.output_type = None;
    }

    pub fn options(&self) -> &MethodOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(MethodOptions::static_default())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::core::convert::Into<MethodOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut MethodOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(MethodOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(false)
    }
    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }
    pub fn set_client_streaming<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.client_streaming = Some(v);
    }
    pub fn client_streaming_mut(&mut self) -> &mut bool {
        self.client_streaming
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = None;
    }

    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(false)
    }
    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }
    pub fn set_server_streaming<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.server_streaming = Some(v);
    }
    pub fn server_streaming_mut(&mut self) -> &mut bool {
        self.server_streaming
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = None;
    }
}

impl protobuf_core::StaticMessage for MethodDescriptorProto {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.MethodDescriptorProto"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for MethodDescriptorProto {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.MethodDescriptorProto"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name = Some(StringCodec::parse(&f)?),
                2 => self.input_type = Some(StringCodec::parse(&f)?),
                3 => self.output_type = Some(StringCodec::parse(&f)?),
                4 => self.options = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                5 => self.client_streaming = Some(BoolCodec::parse(&f)?),
                6 => self.server_streaming = Some(BoolCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            StringCodec::serialize(3, v, out)?;
        }
        if let Some(v) = self.options.as_ref() {
            MessageCodec::serialize(4, v.as_ref(), out)?;
        }
        if let Some(v) = self.client_streaming.as_ref() {
            BoolCodec::serialize(5, *v, out)?;
        }
        if let Some(v) = self.server_streaming.as_ref() {
            BoolCodec::serialize(6, *v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for MethodDescriptorProto {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("input_type"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("output_type"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("client_streaming"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("server_streaming"),
                number: 6,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name.reflect_clear_field(),
            2 => self.input_type.reflect_clear_field(),
            3 => self.output_type.reflect_clear_field(),
            4 => self.options.reflect_clear_field(),
            5 => self.client_streaming.reflect_clear_field(),
            6 => self.server_streaming.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name.reflect_has_field(),
            2 => self.input_type.reflect_has_field(),
            3 => self.output_type.reflect_has_field(),
            4 => self.options.reflect_has_field(),
            5 => self.client_streaming.reflect_has_field(),
            6 => self.server_streaming.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name.reflect_field(),
            2 => self.input_type.reflect_field(),
            3 => self.output_type.reflect_field(),
            4 => self.options.reflect_field(),
            5 => self.client_streaming.reflect_field(),
            6 => self.server_streaming.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_field_mut(),
            2 => self.input_type.reflect_field_mut(),
            3 => self.output_type.reflect_field_mut(),
            4 => self.options.reflect_field_mut(),
            5 => self.client_streaming.reflect_field_mut(),
            6 => self.server_streaming.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "input_type" => 2,
            "output_type" => 3,
            "options" => 4,
            "client_streaming" => 5,
            "server_streaming" => 6,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FileOptions_OptimizeMode {
    SPEED = 1,
    CODE_SIZE = 2,
    LITE_RUNTIME = 3,
}

impl FileOptions_OptimizeMode {}

impl core::default::Default for FileOptions_OptimizeMode {
    fn default() -> Self {
        Self::SPEED
    }
}

impl common::const_default::ConstDefault for FileOptions_OptimizeMode {
    const DEFAULT: Self = Self::SPEED;
}

impl ReflectStatic for FileOptions_OptimizeMode {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FileOptions_OptimizeMode {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            1 => FileOptions_OptimizeMode::SPEED,
            2 => FileOptions_OptimizeMode::CODE_SIZE,
            3 => FileOptions_OptimizeMode::LITE_RUNTIME,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "SPEED" => Self::SPEED,
            "CODE_SIZE" => Self::CODE_SIZE,
            "LITE_RUNTIME" => Self::LITE_RUNTIME,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::SPEED => "SPEED",
            Self::CODE_SIZE => "CODE_SIZE",
            Self::LITE_RUNTIME => "LITE_RUNTIME",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FileOptions_OptimizeMode {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FileOptions {
    java_package: Option<String>,
    java_outer_classname: Option<String>,
    java_multiple_files: Option<bool>,
    java_generate_equals_and_hash: Option<bool>,
    java_string_check_utf8: Option<bool>,
    optimize_for: Option<FileOptions_OptimizeMode>,
    go_package: Option<String>,
    cc_generic_services: Option<bool>,
    java_generic_services: Option<bool>,
    py_generic_services: Option<bool>,
    php_generic_services: Option<bool>,
    deprecated: Option<bool>,
    cc_enable_arenas: Option<bool>,
    objc_class_prefix: Option<String>,
    csharp_namespace: Option<String>,
    swift_prefix: Option<String>,
    php_class_prefix: Option<String>,
    php_namespace: Option<String>,
    php_metadata_namespace: Option<String>,
    ruby_package: Option<String>,
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FileOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FileOptions {
    fn static_default() -> &'static Self {
        static VALUE: FileOptions = FileOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FileOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FileOptions {
    pub const JAVA_PACKAGE_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const JAVA_OUTER_CLASSNAME_FIELD_NUM: protobuf_core::FieldNumber = 8;
    pub const JAVA_MULTIPLE_FILES_FIELD_NUM: protobuf_core::FieldNumber = 10;
    pub const JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUM: protobuf_core::FieldNumber = 20;
    pub const JAVA_STRING_CHECK_UTF8_FIELD_NUM: protobuf_core::FieldNumber = 27;
    pub const OPTIMIZE_FOR_FIELD_NUM: protobuf_core::FieldNumber = 9;
    pub const GO_PACKAGE_FIELD_NUM: protobuf_core::FieldNumber = 11;
    pub const CC_GENERIC_SERVICES_FIELD_NUM: protobuf_core::FieldNumber = 16;
    pub const JAVA_GENERIC_SERVICES_FIELD_NUM: protobuf_core::FieldNumber = 17;
    pub const PY_GENERIC_SERVICES_FIELD_NUM: protobuf_core::FieldNumber = 18;
    pub const PHP_GENERIC_SERVICES_FIELD_NUM: protobuf_core::FieldNumber = 42;
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 23;
    pub const CC_ENABLE_ARENAS_FIELD_NUM: protobuf_core::FieldNumber = 31;
    pub const OBJC_CLASS_PREFIX_FIELD_NUM: protobuf_core::FieldNumber = 36;
    pub const CSHARP_NAMESPACE_FIELD_NUM: protobuf_core::FieldNumber = 37;
    pub const SWIFT_PREFIX_FIELD_NUM: protobuf_core::FieldNumber = 39;
    pub const PHP_CLASS_PREFIX_FIELD_NUM: protobuf_core::FieldNumber = 40;
    pub const PHP_NAMESPACE_FIELD_NUM: protobuf_core::FieldNumber = 41;
    pub const PHP_METADATA_NAMESPACE_FIELD_NUM: protobuf_core::FieldNumber = 44;
    pub const RUBY_PACKAGE_FIELD_NUM: protobuf_core::FieldNumber = 45;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 50;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn java_package(&self) -> &str {
        self.java_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }
    pub fn set_java_package<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.java_package = Some(v);
    }
    pub fn java_package_mut(&mut self) -> &mut String {
        self.java_package.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_java_package(&mut self) {
        self.java_package = None;
    }

    pub fn java_outer_classname(&self) -> &str {
        self.java_outer_classname
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }
    pub fn set_java_outer_classname<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.java_outer_classname = Some(v);
    }
    pub fn java_outer_classname_mut(&mut self) -> &mut String {
        self.java_outer_classname
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = None;
    }

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }
    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }
    pub fn set_java_multiple_files<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_multiple_files = Some(v);
    }
    pub fn java_multiple_files_mut(&mut self) -> &mut bool {
        self.java_multiple_files
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = None;
    }

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or_default()
    }
    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }
    pub fn set_java_generate_equals_and_hash<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_generate_equals_and_hash = Some(v);
    }
    pub fn java_generate_equals_and_hash_mut(&mut self) -> &mut bool {
        self.java_generate_equals_and_hash
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = None;
    }

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }
    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }
    pub fn set_java_string_check_utf8<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_string_check_utf8 = Some(v);
    }
    pub fn java_string_check_utf8_mut(&mut self) -> &mut bool {
        self.java_string_check_utf8
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = None;
    }

    pub fn optimize_for(&self) -> FileOptions_OptimizeMode {
        self.optimize_for.unwrap_or(FileOptions_OptimizeMode::SPEED)
    }
    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }
    pub fn set_optimize_for<V: ::core::convert::Into<FileOptions_OptimizeMode>>(&mut self, v: V) {
        let v = v.into();
        self.optimize_for = Some(v);
    }
    pub fn optimize_for_mut(&mut self) -> &mut FileOptions_OptimizeMode {
        self.optimize_for
            .get_or_insert_with(|| <FileOptions_OptimizeMode>::default())
    }
    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = None;
    }

    pub fn go_package(&self) -> &str {
        self.go_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }
    pub fn set_go_package<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.go_package = Some(v);
    }
    pub fn go_package_mut(&mut self) -> &mut String {
        self.go_package.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_go_package(&mut self) {
        self.go_package = None;
    }

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }
    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }
    pub fn set_cc_generic_services<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.cc_generic_services = Some(v);
    }
    pub fn cc_generic_services_mut(&mut self) -> &mut bool {
        self.cc_generic_services
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = None;
    }

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }
    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }
    pub fn set_java_generic_services<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_generic_services = Some(v);
    }
    pub fn java_generic_services_mut(&mut self) -> &mut bool {
        self.java_generic_services
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = None;
    }

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }
    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }
    pub fn set_py_generic_services<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.py_generic_services = Some(v);
    }
    pub fn py_generic_services_mut(&mut self) -> &mut bool {
        self.py_generic_services
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = None;
    }

    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(false)
    }
    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }
    pub fn set_php_generic_services<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.php_generic_services = Some(v);
    }
    pub fn php_generic_services_mut(&mut self) -> &mut bool {
        self.php_generic_services
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(true)
    }
    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }
    pub fn set_cc_enable_arenas<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.cc_enable_arenas = Some(v);
    }
    pub fn cc_enable_arenas_mut(&mut self) -> &mut bool {
        self.cc_enable_arenas
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = None;
    }

    pub fn objc_class_prefix(&self) -> &str {
        self.objc_class_prefix
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }
    pub fn set_objc_class_prefix<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.objc_class_prefix = Some(v);
    }
    pub fn objc_class_prefix_mut(&mut self) -> &mut String {
        self.objc_class_prefix
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = None;
    }

    pub fn csharp_namespace(&self) -> &str {
        self.csharp_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }
    pub fn set_csharp_namespace<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.csharp_namespace = Some(v);
    }
    pub fn csharp_namespace_mut(&mut self) -> &mut String {
        self.csharp_namespace
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = None;
    }

    pub fn swift_prefix(&self) -> &str {
        self.swift_prefix.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }
    pub fn set_swift_prefix<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.swift_prefix = Some(v);
    }
    pub fn swift_prefix_mut(&mut self) -> &mut String {
        self.swift_prefix.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = None;
    }

    pub fn php_class_prefix(&self) -> &str {
        self.php_class_prefix
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }
    pub fn set_php_class_prefix<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_class_prefix = Some(v);
    }
    pub fn php_class_prefix_mut(&mut self) -> &mut String {
        self.php_class_prefix
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = None;
    }

    pub fn php_namespace(&self) -> &str {
        self.php_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }
    pub fn set_php_namespace<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_namespace = Some(v);
    }
    pub fn php_namespace_mut(&mut self) -> &mut String {
        self.php_namespace
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = None;
    }

    pub fn php_metadata_namespace(&self) -> &str {
        self.php_metadata_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }
    pub fn set_php_metadata_namespace<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_metadata_namespace = Some(v);
    }
    pub fn php_metadata_namespace_mut(&mut self) -> &mut String {
        self.php_metadata_namespace
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = None;
    }

    pub fn ruby_package(&self) -> &str {
        self.ruby_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }
    pub fn set_ruby_package<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.ruby_package = Some(v);
    }
    pub fn ruby_package_mut(&mut self) -> &mut String {
        self.ruby_package.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for FileOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FileOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FileOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FileOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.java_package = Some(StringCodec::parse(&f)?),
                8 => self.java_outer_classname = Some(StringCodec::parse(&f)?),
                10 => self.java_multiple_files = Some(BoolCodec::parse(&f)?),
                20 => self.java_generate_equals_and_hash = Some(BoolCodec::parse(&f)?),
                27 => self.java_string_check_utf8 = Some(BoolCodec::parse(&f)?),
                9 => self.optimize_for = Some(EnumCodec::parse(&f)?),
                11 => self.go_package = Some(StringCodec::parse(&f)?),
                16 => self.cc_generic_services = Some(BoolCodec::parse(&f)?),
                17 => self.java_generic_services = Some(BoolCodec::parse(&f)?),
                18 => self.py_generic_services = Some(BoolCodec::parse(&f)?),
                42 => self.php_generic_services = Some(BoolCodec::parse(&f)?),
                23 => self.deprecated = Some(BoolCodec::parse(&f)?),
                31 => self.cc_enable_arenas = Some(BoolCodec::parse(&f)?),
                36 => self.objc_class_prefix = Some(StringCodec::parse(&f)?),
                37 => self.csharp_namespace = Some(StringCodec::parse(&f)?),
                39 => self.swift_prefix = Some(StringCodec::parse(&f)?),
                40 => self.php_class_prefix = Some(StringCodec::parse(&f)?),
                41 => self.php_namespace = Some(StringCodec::parse(&f)?),
                44 => self.php_metadata_namespace = Some(StringCodec::parse(&f)?),
                45 => self.ruby_package = Some(StringCodec::parse(&f)?),
                50 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.java_package.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            StringCodec::serialize(8, v, out)?;
        }
        if let Some(v) = self.java_multiple_files.as_ref() {
            BoolCodec::serialize(10, *v, out)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash.as_ref() {
            BoolCodec::serialize(20, *v, out)?;
        }
        if let Some(v) = self.java_string_check_utf8.as_ref() {
            BoolCodec::serialize(27, *v, out)?;
        }
        if let Some(v) = self.optimize_for.as_ref() {
            EnumCodec::serialize(9, v, out)?;
        }
        if let Some(v) = self.go_package.as_ref() {
            StringCodec::serialize(11, v, out)?;
        }
        if let Some(v) = self.cc_generic_services.as_ref() {
            BoolCodec::serialize(16, *v, out)?;
        }
        if let Some(v) = self.java_generic_services.as_ref() {
            BoolCodec::serialize(17, *v, out)?;
        }
        if let Some(v) = self.py_generic_services.as_ref() {
            BoolCodec::serialize(18, *v, out)?;
        }
        if let Some(v) = self.php_generic_services.as_ref() {
            BoolCodec::serialize(42, *v, out)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(23, *v, out)?;
        }
        if let Some(v) = self.cc_enable_arenas.as_ref() {
            BoolCodec::serialize(31, *v, out)?;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            StringCodec::serialize(36, v, out)?;
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            StringCodec::serialize(37, v, out)?;
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            StringCodec::serialize(39, v, out)?;
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            StringCodec::serialize(40, v, out)?;
        }
        if let Some(v) = self.php_namespace.as_ref() {
            StringCodec::serialize(41, v, out)?;
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            StringCodec::serialize(44, v, out)?;
        }
        if let Some(v) = self.ruby_package.as_ref() {
            StringCodec::serialize(45, v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(50, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FileOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_package"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_outer_classname"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_multiple_files"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_generate_equals_and_hash"),
                number: 20,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_string_check_utf8"),
                number: 27,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("optimize_for"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("go_package"),
                number: 11,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("cc_generic_services"),
                number: 16,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_generic_services"),
                number: 17,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("py_generic_services"),
                number: 18,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_generic_services"),
                number: 42,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 23,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("cc_enable_arenas"),
                number: 31,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("objc_class_prefix"),
                number: 36,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("csharp_namespace"),
                number: 37,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("swift_prefix"),
                number: 39,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_class_prefix"),
                number: 40,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_namespace"),
                number: 41,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_metadata_namespace"),
                number: 44,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("ruby_package"),
                number: 45,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 50,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.java_package.reflect_clear_field(),
            8 => self.java_outer_classname.reflect_clear_field(),
            10 => self.java_multiple_files.reflect_clear_field(),
            20 => self.java_generate_equals_and_hash.reflect_clear_field(),
            27 => self.java_string_check_utf8.reflect_clear_field(),
            9 => self.optimize_for.reflect_clear_field(),
            11 => self.go_package.reflect_clear_field(),
            16 => self.cc_generic_services.reflect_clear_field(),
            17 => self.java_generic_services.reflect_clear_field(),
            18 => self.py_generic_services.reflect_clear_field(),
            42 => self.php_generic_services.reflect_clear_field(),
            23 => self.deprecated.reflect_clear_field(),
            31 => self.cc_enable_arenas.reflect_clear_field(),
            36 => self.objc_class_prefix.reflect_clear_field(),
            37 => self.csharp_namespace.reflect_clear_field(),
            39 => self.swift_prefix.reflect_clear_field(),
            40 => self.php_class_prefix.reflect_clear_field(),
            41 => self.php_namespace.reflect_clear_field(),
            44 => self.php_metadata_namespace.reflect_clear_field(),
            45 => self.ruby_package.reflect_clear_field(),
            50 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.java_package.reflect_has_field(),
            8 => self.java_outer_classname.reflect_has_field(),
            10 => self.java_multiple_files.reflect_has_field(),
            20 => self.java_generate_equals_and_hash.reflect_has_field(),
            27 => self.java_string_check_utf8.reflect_has_field(),
            9 => self.optimize_for.reflect_has_field(),
            11 => self.go_package.reflect_has_field(),
            16 => self.cc_generic_services.reflect_has_field(),
            17 => self.java_generic_services.reflect_has_field(),
            18 => self.py_generic_services.reflect_has_field(),
            42 => self.php_generic_services.reflect_has_field(),
            23 => self.deprecated.reflect_has_field(),
            31 => self.cc_enable_arenas.reflect_has_field(),
            36 => self.objc_class_prefix.reflect_has_field(),
            37 => self.csharp_namespace.reflect_has_field(),
            39 => self.swift_prefix.reflect_has_field(),
            40 => self.php_class_prefix.reflect_has_field(),
            41 => self.php_namespace.reflect_has_field(),
            44 => self.php_metadata_namespace.reflect_has_field(),
            45 => self.ruby_package.reflect_has_field(),
            50 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.java_package.reflect_field(),
            8 => self.java_outer_classname.reflect_field(),
            10 => self.java_multiple_files.reflect_field(),
            20 => self.java_generate_equals_and_hash.reflect_field(),
            27 => self.java_string_check_utf8.reflect_field(),
            9 => self.optimize_for.reflect_field(),
            11 => self.go_package.reflect_field(),
            16 => self.cc_generic_services.reflect_field(),
            17 => self.java_generic_services.reflect_field(),
            18 => self.py_generic_services.reflect_field(),
            42 => self.php_generic_services.reflect_field(),
            23 => self.deprecated.reflect_field(),
            31 => self.cc_enable_arenas.reflect_field(),
            36 => self.objc_class_prefix.reflect_field(),
            37 => self.csharp_namespace.reflect_field(),
            39 => self.swift_prefix.reflect_field(),
            40 => self.php_class_prefix.reflect_field(),
            41 => self.php_namespace.reflect_field(),
            44 => self.php_metadata_namespace.reflect_field(),
            45 => self.ruby_package.reflect_field(),
            50 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.java_package.reflect_field_mut(),
            8 => self.java_outer_classname.reflect_field_mut(),
            10 => self.java_multiple_files.reflect_field_mut(),
            20 => self.java_generate_equals_and_hash.reflect_field_mut(),
            27 => self.java_string_check_utf8.reflect_field_mut(),
            9 => self.optimize_for.reflect_field_mut(),
            11 => self.go_package.reflect_field_mut(),
            16 => self.cc_generic_services.reflect_field_mut(),
            17 => self.java_generic_services.reflect_field_mut(),
            18 => self.py_generic_services.reflect_field_mut(),
            42 => self.php_generic_services.reflect_field_mut(),
            23 => self.deprecated.reflect_field_mut(),
            31 => self.cc_enable_arenas.reflect_field_mut(),
            36 => self.objc_class_prefix.reflect_field_mut(),
            37 => self.csharp_namespace.reflect_field_mut(),
            39 => self.swift_prefix.reflect_field_mut(),
            40 => self.php_class_prefix.reflect_field_mut(),
            41 => self.php_namespace.reflect_field_mut(),
            44 => self.php_metadata_namespace.reflect_field_mut(),
            45 => self.ruby_package.reflect_field_mut(),
            50 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "java_package" => 1,
            "java_outer_classname" => 8,
            "java_multiple_files" => 10,
            "java_generate_equals_and_hash" => 20,
            "java_string_check_utf8" => 27,
            "optimize_for" => 9,
            "go_package" => 11,
            "cc_generic_services" => 16,
            "java_generic_services" => 17,
            "py_generic_services" => 18,
            "php_generic_services" => 42,
            "deprecated" => 23,
            "cc_enable_arenas" => 31,
            "objc_class_prefix" => 36,
            "csharp_namespace" => 37,
            "swift_prefix" => 39,
            "php_class_prefix" => 40,
            "php_namespace" => 41,
            "php_metadata_namespace" => 44,
            "ruby_package" => 45,
            "features" => 50,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct MessageOptions {
    message_set_wire_format: Option<bool>,
    no_standard_descriptor_accessor: Option<bool>,
    deprecated: Option<bool>,
    map_entry: Option<bool>,
    deprecated_legacy_json_field_conflicts: Option<bool>,
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for MessageOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for MessageOptions {
    fn static_default() -> &'static Self {
        static VALUE: MessageOptions = MessageOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for MessageOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl MessageOptions {
    pub const MESSAGE_SET_WIRE_FORMAT_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const MAP_ENTRY_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const DEPRECATED_LEGACY_JSON_FIELD_CONFLICTS_FIELD_NUM: protobuf_core::FieldNumber = 11;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 12;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }
    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }
    pub fn set_message_set_wire_format<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.message_set_wire_format = Some(v);
    }
    pub fn message_set_wire_format_mut(&mut self) -> &mut bool {
        self.message_set_wire_format
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = None;
    }

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }
    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }
    pub fn set_no_standard_descriptor_accessor<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.no_standard_descriptor_accessor = Some(v);
    }
    pub fn no_standard_descriptor_accessor_mut(&mut self) -> &mut bool {
        self.no_standard_descriptor_accessor
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or_default()
    }
    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }
    pub fn set_map_entry<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.map_entry = Some(v);
    }
    pub fn map_entry_mut(&mut self) -> &mut bool {
        self.map_entry.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_map_entry(&mut self) {
        self.map_entry = None;
    }

    pub fn deprecated_legacy_json_field_conflicts(&self) -> bool {
        self.deprecated_legacy_json_field_conflicts
            .unwrap_or_default()
    }
    pub fn has_deprecated_legacy_json_field_conflicts(&self) -> bool {
        self.deprecated_legacy_json_field_conflicts.is_some()
    }
    pub fn set_deprecated_legacy_json_field_conflicts<V: ::core::convert::Into<bool>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.deprecated_legacy_json_field_conflicts = Some(v);
    }
    pub fn deprecated_legacy_json_field_conflicts_mut(&mut self) -> &mut bool {
        self.deprecated_legacy_json_field_conflicts
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated_legacy_json_field_conflicts(&mut self) {
        self.deprecated_legacy_json_field_conflicts = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for MessageOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.MessageOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for MessageOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.MessageOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.message_set_wire_format = Some(BoolCodec::parse(&f)?),
                2 => self.no_standard_descriptor_accessor = Some(BoolCodec::parse(&f)?),
                3 => self.deprecated = Some(BoolCodec::parse(&f)?),
                7 => self.map_entry = Some(BoolCodec::parse(&f)?),
                11 => self.deprecated_legacy_json_field_conflicts = Some(BoolCodec::parse(&f)?),
                12 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.message_set_wire_format.as_ref() {
            BoolCodec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor.as_ref() {
            BoolCodec::serialize(2, *v, out)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(3, *v, out)?;
        }
        if let Some(v) = self.map_entry.as_ref() {
            BoolCodec::serialize(7, *v, out)?;
        }
        if let Some(v) = self.deprecated_legacy_json_field_conflicts.as_ref() {
            BoolCodec::serialize(11, *v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(12, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for MessageOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("message_set_wire_format"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("no_standard_descriptor_accessor"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("map_entry"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated_legacy_json_field_conflicts"),
                number: 11,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 12,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.message_set_wire_format.reflect_clear_field(),
            2 => self.no_standard_descriptor_accessor.reflect_clear_field(),
            3 => self.deprecated.reflect_clear_field(),
            7 => self.map_entry.reflect_clear_field(),
            11 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_clear_field(),
            12 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.message_set_wire_format.reflect_has_field(),
            2 => self.no_standard_descriptor_accessor.reflect_has_field(),
            3 => self.deprecated.reflect_has_field(),
            7 => self.map_entry.reflect_has_field(),
            11 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_has_field(),
            12 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.message_set_wire_format.reflect_field(),
            2 => self.no_standard_descriptor_accessor.reflect_field(),
            3 => self.deprecated.reflect_field(),
            7 => self.map_entry.reflect_field(),
            11 => self.deprecated_legacy_json_field_conflicts.reflect_field(),
            12 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.message_set_wire_format.reflect_field_mut(),
            2 => self.no_standard_descriptor_accessor.reflect_field_mut(),
            3 => self.deprecated.reflect_field_mut(),
            7 => self.map_entry.reflect_field_mut(),
            11 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_field_mut(),
            12 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "message_set_wire_format" => 1,
            "no_standard_descriptor_accessor" => 2,
            "deprecated" => 3,
            "map_entry" => 7,
            "deprecated_legacy_json_field_conflicts" => 11,
            "features" => 12,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldOptions_CType {
    STRING = 0,
    CORD = 1,
    STRING_PIECE = 2,
}

impl FieldOptions_CType {}

impl core::default::Default for FieldOptions_CType {
    fn default() -> Self {
        Self::STRING
    }
}

impl common::const_default::ConstDefault for FieldOptions_CType {
    const DEFAULT: Self = Self::STRING;
}

impl ReflectStatic for FieldOptions_CType {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldOptions_CType {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FieldOptions_CType::STRING,
            1 => FieldOptions_CType::CORD,
            2 => FieldOptions_CType::STRING_PIECE,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "STRING" => Self::STRING,
            "CORD" => Self::CORD,
            "STRING_PIECE" => Self::STRING_PIECE,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::STRING => "STRING",
            Self::CORD => "CORD",
            Self::STRING_PIECE => "STRING_PIECE",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_CType {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldOptions_JSType {
    JS_NORMAL = 0,
    JS_STRING = 1,
    JS_NUMBER = 2,
}

impl FieldOptions_JSType {}

impl core::default::Default for FieldOptions_JSType {
    fn default() -> Self {
        Self::JS_NORMAL
    }
}

impl common::const_default::ConstDefault for FieldOptions_JSType {
    const DEFAULT: Self = Self::JS_NORMAL;
}

impl ReflectStatic for FieldOptions_JSType {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldOptions_JSType {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FieldOptions_JSType::JS_NORMAL,
            1 => FieldOptions_JSType::JS_STRING,
            2 => FieldOptions_JSType::JS_NUMBER,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "JS_NORMAL" => Self::JS_NORMAL,
            "JS_STRING" => Self::JS_STRING,
            "JS_NUMBER" => Self::JS_NUMBER,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::JS_NORMAL => "JS_NORMAL",
            Self::JS_STRING => "JS_STRING",
            Self::JS_NUMBER => "JS_NUMBER",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_JSType {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldOptions_OptionRetention {
    RETENTION_UNKNOWN = 0,
    RETENTION_RUNTIME = 1,
    RETENTION_SOURCE = 2,
}

impl FieldOptions_OptionRetention {}

impl core::default::Default for FieldOptions_OptionRetention {
    fn default() -> Self {
        Self::RETENTION_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FieldOptions_OptionRetention {
    const DEFAULT: Self = Self::RETENTION_UNKNOWN;
}

impl ReflectStatic for FieldOptions_OptionRetention {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldOptions_OptionRetention {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FieldOptions_OptionRetention::RETENTION_UNKNOWN,
            1 => FieldOptions_OptionRetention::RETENTION_RUNTIME,
            2 => FieldOptions_OptionRetention::RETENTION_SOURCE,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "RETENTION_UNKNOWN" => Self::RETENTION_UNKNOWN,
            "RETENTION_RUNTIME" => Self::RETENTION_RUNTIME,
            "RETENTION_SOURCE" => Self::RETENTION_SOURCE,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::RETENTION_UNKNOWN => "RETENTION_UNKNOWN",
            Self::RETENTION_RUNTIME => "RETENTION_RUNTIME",
            Self::RETENTION_SOURCE => "RETENTION_SOURCE",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_OptionRetention {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FieldOptions_OptionTargetType {
    TARGET_TYPE_UNKNOWN = 0,
    TARGET_TYPE_FILE = 1,
    TARGET_TYPE_EXTENSION_RANGE = 2,
    TARGET_TYPE_MESSAGE = 3,
    TARGET_TYPE_FIELD = 4,
    TARGET_TYPE_ONEOF = 5,
    TARGET_TYPE_ENUM = 6,
    TARGET_TYPE_ENUM_ENTRY = 7,
    TARGET_TYPE_SERVICE = 8,
    TARGET_TYPE_METHOD = 9,
}

impl FieldOptions_OptionTargetType {}

impl core::default::Default for FieldOptions_OptionTargetType {
    fn default() -> Self {
        Self::TARGET_TYPE_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FieldOptions_OptionTargetType {
    const DEFAULT: Self = Self::TARGET_TYPE_UNKNOWN;
}

impl ReflectStatic for FieldOptions_OptionTargetType {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FieldOptions_OptionTargetType {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FieldOptions_OptionTargetType::TARGET_TYPE_UNKNOWN,
            1 => FieldOptions_OptionTargetType::TARGET_TYPE_FILE,
            2 => FieldOptions_OptionTargetType::TARGET_TYPE_EXTENSION_RANGE,
            3 => FieldOptions_OptionTargetType::TARGET_TYPE_MESSAGE,
            4 => FieldOptions_OptionTargetType::TARGET_TYPE_FIELD,
            5 => FieldOptions_OptionTargetType::TARGET_TYPE_ONEOF,
            6 => FieldOptions_OptionTargetType::TARGET_TYPE_ENUM,
            7 => FieldOptions_OptionTargetType::TARGET_TYPE_ENUM_ENTRY,
            8 => FieldOptions_OptionTargetType::TARGET_TYPE_SERVICE,
            9 => FieldOptions_OptionTargetType::TARGET_TYPE_METHOD,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "TARGET_TYPE_UNKNOWN" => Self::TARGET_TYPE_UNKNOWN,
            "TARGET_TYPE_FILE" => Self::TARGET_TYPE_FILE,
            "TARGET_TYPE_EXTENSION_RANGE" => Self::TARGET_TYPE_EXTENSION_RANGE,
            "TARGET_TYPE_MESSAGE" => Self::TARGET_TYPE_MESSAGE,
            "TARGET_TYPE_FIELD" => Self::TARGET_TYPE_FIELD,
            "TARGET_TYPE_ONEOF" => Self::TARGET_TYPE_ONEOF,
            "TARGET_TYPE_ENUM" => Self::TARGET_TYPE_ENUM,
            "TARGET_TYPE_ENUM_ENTRY" => Self::TARGET_TYPE_ENUM_ENTRY,
            "TARGET_TYPE_SERVICE" => Self::TARGET_TYPE_SERVICE,
            "TARGET_TYPE_METHOD" => Self::TARGET_TYPE_METHOD,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::TARGET_TYPE_UNKNOWN => "TARGET_TYPE_UNKNOWN",
            Self::TARGET_TYPE_FILE => "TARGET_TYPE_FILE",
            Self::TARGET_TYPE_EXTENSION_RANGE => "TARGET_TYPE_EXTENSION_RANGE",
            Self::TARGET_TYPE_MESSAGE => "TARGET_TYPE_MESSAGE",
            Self::TARGET_TYPE_FIELD => "TARGET_TYPE_FIELD",
            Self::TARGET_TYPE_ONEOF => "TARGET_TYPE_ONEOF",
            Self::TARGET_TYPE_ENUM => "TARGET_TYPE_ENUM",
            Self::TARGET_TYPE_ENUM_ENTRY => "TARGET_TYPE_ENUM_ENTRY",
            Self::TARGET_TYPE_SERVICE => "TARGET_TYPE_SERVICE",
            Self::TARGET_TYPE_METHOD => "TARGET_TYPE_METHOD",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_OptionTargetType {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FieldOptions_EditionDefault {
    edition: Option<String>,
    value: Option<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FieldOptions_EditionDefault {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FieldOptions_EditionDefault {
    fn static_default() -> &'static Self {
        static VALUE: FieldOptions_EditionDefault = FieldOptions_EditionDefault::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FieldOptions_EditionDefault {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FieldOptions_EditionDefault {
    pub const EDITION_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const VALUE_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn edition(&self) -> &str {
        self.edition.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_edition(&self) -> bool {
        self.edition.is_some()
    }
    pub fn set_edition<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.edition = Some(v);
    }
    pub fn edition_mut(&mut self) -> &mut String {
        self.edition.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_edition(&mut self) {
        self.edition = None;
    }

    pub fn value(&self) -> &str {
        self.value.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }
    pub fn set_value<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.value = Some(v);
    }
    pub fn value_mut(&mut self) -> &mut String {
        self.value.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_value(&mut self) {
        self.value = None;
    }
}

impl protobuf_core::StaticMessage for FieldOptions_EditionDefault {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FieldOptions.EditionDefault"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FieldOptions_EditionDefault {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FieldOptions.EditionDefault"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.edition = Some(StringCodec::parse(&f)?),
                2 => self.value = Some(StringCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.edition.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.value.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FieldOptions_EditionDefault {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("edition"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("value"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.edition.reflect_clear_field(),
            2 => self.value.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.edition.reflect_has_field(),
            2 => self.value.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.edition.reflect_field(),
            2 => self.value.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.edition.reflect_field_mut(),
            2 => self.value.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "edition" => 1,
            "value" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FieldOptions {
    ctype: Option<FieldOptions_CType>,
    packed: Option<bool>,
    jstype: Option<FieldOptions_JSType>,
    lazy: Option<bool>,
    unverified_lazy: Option<bool>,
    deprecated: Option<bool>,
    weak: Option<bool>,
    debug_redact: Option<bool>,
    retention: Option<FieldOptions_OptionRetention>,
    targets: Vec<FieldOptions_OptionTargetType>,
    edition_defaults: Vec<MessagePtr<FieldOptions_EditionDefault>>,
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FieldOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FieldOptions {
    fn static_default() -> &'static Self {
        static VALUE: FieldOptions = FieldOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FieldOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FieldOptions {
    pub const CTYPE_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const PACKED_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const JSTYPE_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const LAZY_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const UNVERIFIED_LAZY_FIELD_NUM: protobuf_core::FieldNumber = 15;
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const WEAK_FIELD_NUM: protobuf_core::FieldNumber = 10;
    pub const DEBUG_REDACT_FIELD_NUM: protobuf_core::FieldNumber = 16;
    pub const RETENTION_FIELD_NUM: protobuf_core::FieldNumber = 17;
    pub const TARGETS_FIELD_NUM: protobuf_core::FieldNumber = 19;
    pub const EDITION_DEFAULTS_FIELD_NUM: protobuf_core::FieldNumber = 20;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 21;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn ctype(&self) -> FieldOptions_CType {
        self.ctype.unwrap_or(FieldOptions_CType::STRING)
    }
    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }
    pub fn set_ctype<V: ::core::convert::Into<FieldOptions_CType>>(&mut self, v: V) {
        let v = v.into();
        self.ctype = Some(v);
    }
    pub fn ctype_mut(&mut self) -> &mut FieldOptions_CType {
        self.ctype
            .get_or_insert_with(|| <FieldOptions_CType>::default())
    }
    pub fn clear_ctype(&mut self) {
        self.ctype = None;
    }

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or_default()
    }
    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }
    pub fn set_packed<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.packed = Some(v);
    }
    pub fn packed_mut(&mut self) -> &mut bool {
        self.packed.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_packed(&mut self) {
        self.packed = None;
    }

    pub fn jstype(&self) -> FieldOptions_JSType {
        self.jstype.unwrap_or(FieldOptions_JSType::JS_NORMAL)
    }
    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }
    pub fn set_jstype<V: ::core::convert::Into<FieldOptions_JSType>>(&mut self, v: V) {
        let v = v.into();
        self.jstype = Some(v);
    }
    pub fn jstype_mut(&mut self) -> &mut FieldOptions_JSType {
        self.jstype
            .get_or_insert_with(|| <FieldOptions_JSType>::default())
    }
    pub fn clear_jstype(&mut self) {
        self.jstype = None;
    }

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }
    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }
    pub fn set_lazy<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.lazy = Some(v);
    }
    pub fn lazy_mut(&mut self) -> &mut bool {
        self.lazy.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_lazy(&mut self) {
        self.lazy = None;
    }

    pub fn unverified_lazy(&self) -> bool {
        self.unverified_lazy.unwrap_or(false)
    }
    pub fn has_unverified_lazy(&self) -> bool {
        self.unverified_lazy.is_some()
    }
    pub fn set_unverified_lazy<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.unverified_lazy = Some(v);
    }
    pub fn unverified_lazy_mut(&mut self) -> &mut bool {
        self.unverified_lazy
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_unverified_lazy(&mut self) {
        self.unverified_lazy = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }
    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }
    pub fn set_weak<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.weak = Some(v);
    }
    pub fn weak_mut(&mut self) -> &mut bool {
        self.weak.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_weak(&mut self) {
        self.weak = None;
    }

    pub fn debug_redact(&self) -> bool {
        self.debug_redact.unwrap_or(false)
    }
    pub fn has_debug_redact(&self) -> bool {
        self.debug_redact.is_some()
    }
    pub fn set_debug_redact<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.debug_redact = Some(v);
    }
    pub fn debug_redact_mut(&mut self) -> &mut bool {
        self.debug_redact.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_debug_redact(&mut self) {
        self.debug_redact = None;
    }

    pub fn retention(&self) -> FieldOptions_OptionRetention {
        self.retention.unwrap_or_default()
    }
    pub fn has_retention(&self) -> bool {
        self.retention.is_some()
    }
    pub fn set_retention<V: ::core::convert::Into<FieldOptions_OptionRetention>>(&mut self, v: V) {
        let v = v.into();
        self.retention = Some(v);
    }
    pub fn retention_mut(&mut self) -> &mut FieldOptions_OptionRetention {
        self.retention
            .get_or_insert_with(|| <FieldOptions_OptionRetention>::default())
    }
    pub fn clear_retention(&mut self) {
        self.retention = None;
    }

    pub fn targets(&self) -> &[FieldOptions_OptionTargetType] {
        &self.targets
    }

    pub fn targets_mut(&mut self) -> &mut Vec<FieldOptions_OptionTargetType> {
        &mut self.targets
    }

    pub fn targets_len(&self) -> usize {
        self.targets.len()
    }

    pub fn add_targets(
        &mut self,
        v: FieldOptions_OptionTargetType,
    ) -> &mut FieldOptions_OptionTargetType {
        self.targets.push(v);
        self.targets.last_mut().unwrap()
    }

    pub fn new_targets(&mut self) -> &mut FieldOptions_OptionTargetType {
        self.targets
            .push(<FieldOptions_OptionTargetType>::default());
        self.targets.last_mut().unwrap()
    }

    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    pub fn edition_defaults(&self) -> &[MessagePtr<FieldOptions_EditionDefault>] {
        &self.edition_defaults
    }

    pub fn edition_defaults_mut(&mut self) -> &mut Vec<MessagePtr<FieldOptions_EditionDefault>> {
        &mut self.edition_defaults
    }

    pub fn edition_defaults_len(&self) -> usize {
        self.edition_defaults.len()
    }

    pub fn add_edition_defaults(
        &mut self,
        v: FieldOptions_EditionDefault,
    ) -> &mut MessagePtr<FieldOptions_EditionDefault> {
        self.edition_defaults.push(MessagePtr::new(v));
        self.edition_defaults.last_mut().unwrap()
    }

    pub fn new_edition_defaults(&mut self) -> &mut MessagePtr<FieldOptions_EditionDefault> {
        self.edition_defaults
            .push(<MessagePtr<FieldOptions_EditionDefault>>::default());
        self.edition_defaults.last_mut().unwrap()
    }

    pub fn clear_edition_defaults(&mut self) {
        self.edition_defaults.clear();
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for FieldOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FieldOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FieldOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FieldOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.ctype = Some(EnumCodec::parse(&f)?),
                2 => self.packed = Some(BoolCodec::parse(&f)?),
                6 => self.jstype = Some(EnumCodec::parse(&f)?),
                5 => self.lazy = Some(BoolCodec::parse(&f)?),
                15 => self.unverified_lazy = Some(BoolCodec::parse(&f)?),
                3 => self.deprecated = Some(BoolCodec::parse(&f)?),
                10 => self.weak = Some(BoolCodec::parse(&f)?),
                16 => self.debug_redact = Some(BoolCodec::parse(&f)?),
                17 => self.retention = Some(EnumCodec::parse(&f)?),
                19 => {
                    for v in EnumCodec::parse_repeated(&f) {
                        self.targets.push(v?);
                    }
                }
                20 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.edition_defaults.push(MessagePtr::new(v?));
                    }
                }
                21 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.ctype.as_ref() {
            EnumCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.packed.as_ref() {
            BoolCodec::serialize(2, *v, out)?;
        }
        if let Some(v) = self.jstype.as_ref() {
            EnumCodec::serialize(6, v, out)?;
        }
        if let Some(v) = self.lazy.as_ref() {
            BoolCodec::serialize(5, *v, out)?;
        }
        if let Some(v) = self.unverified_lazy.as_ref() {
            BoolCodec::serialize(15, *v, out)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(3, *v, out)?;
        }
        if let Some(v) = self.weak.as_ref() {
            BoolCodec::serialize(10, *v, out)?;
        }
        if let Some(v) = self.debug_redact.as_ref() {
            BoolCodec::serialize(16, *v, out)?;
        }
        if let Some(v) = self.retention.as_ref() {
            EnumCodec::serialize(17, v, out)?;
        }
        EnumCodec::serialize_repeated(19, &self.targets, out)?;
        MessageCodec::serialize_repeated(20, &self.edition_defaults, out)?;
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(21, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FieldOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("ctype"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("packed"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("jstype"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("lazy"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("unverified_lazy"),
                number: 15,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("weak"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("debug_redact"),
                number: 16,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("retention"),
                number: 17,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("targets"),
                number: 19,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("edition_defaults"),
                number: 20,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 21,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.ctype.reflect_clear_field(),
            2 => self.packed.reflect_clear_field(),
            6 => self.jstype.reflect_clear_field(),
            5 => self.lazy.reflect_clear_field(),
            15 => self.unverified_lazy.reflect_clear_field(),
            3 => self.deprecated.reflect_clear_field(),
            10 => self.weak.reflect_clear_field(),
            16 => self.debug_redact.reflect_clear_field(),
            17 => self.retention.reflect_clear_field(),
            19 => self.targets.reflect_clear_field(),
            20 => self.edition_defaults.reflect_clear_field(),
            21 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.ctype.reflect_has_field(),
            2 => self.packed.reflect_has_field(),
            6 => self.jstype.reflect_has_field(),
            5 => self.lazy.reflect_has_field(),
            15 => self.unverified_lazy.reflect_has_field(),
            3 => self.deprecated.reflect_has_field(),
            10 => self.weak.reflect_has_field(),
            16 => self.debug_redact.reflect_has_field(),
            17 => self.retention.reflect_has_field(),
            19 => self.targets.reflect_has_field(),
            20 => self.edition_defaults.reflect_has_field(),
            21 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.ctype.reflect_field(),
            2 => self.packed.reflect_field(),
            6 => self.jstype.reflect_field(),
            5 => self.lazy.reflect_field(),
            15 => self.unverified_lazy.reflect_field(),
            3 => self.deprecated.reflect_field(),
            10 => self.weak.reflect_field(),
            16 => self.debug_redact.reflect_field(),
            17 => self.retention.reflect_field(),
            19 => self.targets.reflect_field(),
            20 => self.edition_defaults.reflect_field(),
            21 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.ctype.reflect_field_mut(),
            2 => self.packed.reflect_field_mut(),
            6 => self.jstype.reflect_field_mut(),
            5 => self.lazy.reflect_field_mut(),
            15 => self.unverified_lazy.reflect_field_mut(),
            3 => self.deprecated.reflect_field_mut(),
            10 => self.weak.reflect_field_mut(),
            16 => self.debug_redact.reflect_field_mut(),
            17 => self.retention.reflect_field_mut(),
            19 => self.targets.reflect_field_mut(),
            20 => self.edition_defaults.reflect_field_mut(),
            21 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "ctype" => 1,
            "packed" => 2,
            "jstype" => 6,
            "lazy" => 5,
            "unverified_lazy" => 15,
            "deprecated" => 3,
            "weak" => 10,
            "debug_redact" => 16,
            "retention" => 17,
            "targets" => 19,
            "edition_defaults" => 20,
            "features" => 21,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct OneofOptions {
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for OneofOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for OneofOptions {
    fn static_default() -> &'static Self {
        static VALUE: OneofOptions = OneofOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for OneofOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl OneofOptions {
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for OneofOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.OneofOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for OneofOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.OneofOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(1, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for OneofOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "features" => 1,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct EnumOptions {
    allow_alias: Option<bool>,
    deprecated: Option<bool>,
    deprecated_legacy_json_field_conflicts: Option<bool>,
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for EnumOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for EnumOptions {
    fn static_default() -> &'static Self {
        static VALUE: EnumOptions = EnumOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for EnumOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl EnumOptions {
    pub const ALLOW_ALIAS_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const DEPRECATED_LEGACY_JSON_FIELD_CONFLICTS_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or_default()
    }
    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }
    pub fn set_allow_alias<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.allow_alias = Some(v);
    }
    pub fn allow_alias_mut(&mut self) -> &mut bool {
        self.allow_alias.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn deprecated_legacy_json_field_conflicts(&self) -> bool {
        self.deprecated_legacy_json_field_conflicts
            .unwrap_or_default()
    }
    pub fn has_deprecated_legacy_json_field_conflicts(&self) -> bool {
        self.deprecated_legacy_json_field_conflicts.is_some()
    }
    pub fn set_deprecated_legacy_json_field_conflicts<V: ::core::convert::Into<bool>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.deprecated_legacy_json_field_conflicts = Some(v);
    }
    pub fn deprecated_legacy_json_field_conflicts_mut(&mut self) -> &mut bool {
        self.deprecated_legacy_json_field_conflicts
            .get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated_legacy_json_field_conflicts(&mut self) {
        self.deprecated_legacy_json_field_conflicts = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for EnumOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.EnumOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for EnumOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.EnumOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                2 => self.allow_alias = Some(BoolCodec::parse(&f)?),
                3 => self.deprecated = Some(BoolCodec::parse(&f)?),
                6 => self.deprecated_legacy_json_field_conflicts = Some(BoolCodec::parse(&f)?),
                7 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.allow_alias.as_ref() {
            BoolCodec::serialize(2, *v, out)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(3, *v, out)?;
        }
        if let Some(v) = self.deprecated_legacy_json_field_conflicts.as_ref() {
            BoolCodec::serialize(6, *v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(7, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for EnumOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("allow_alias"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated_legacy_json_field_conflicts"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            2 => self.allow_alias.reflect_clear_field(),
            3 => self.deprecated.reflect_clear_field(),
            6 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_clear_field(),
            7 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            2 => self.allow_alias.reflect_has_field(),
            3 => self.deprecated.reflect_has_field(),
            6 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_has_field(),
            7 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            2 => self.allow_alias.reflect_field(),
            3 => self.deprecated.reflect_field(),
            6 => self.deprecated_legacy_json_field_conflicts.reflect_field(),
            7 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            2 => self.allow_alias.reflect_field_mut(),
            3 => self.deprecated.reflect_field_mut(),
            6 => self
                .deprecated_legacy_json_field_conflicts
                .reflect_field_mut(),
            7 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "allow_alias" => 2,
            "deprecated" => 3,
            "deprecated_legacy_json_field_conflicts" => 6,
            "features" => 7,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct EnumValueOptions {
    deprecated: Option<bool>,
    features: Option<MessagePtr<FeatureSet>>,
    debug_redact: Option<bool>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for EnumValueOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for EnumValueOptions {
    fn static_default() -> &'static Self {
        static VALUE: EnumValueOptions = EnumValueOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for EnumValueOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl EnumValueOptions {
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const DEBUG_REDACT_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn debug_redact(&self) -> bool {
        self.debug_redact.unwrap_or(false)
    }
    pub fn has_debug_redact(&self) -> bool {
        self.debug_redact.is_some()
    }
    pub fn set_debug_redact<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.debug_redact = Some(v);
    }
    pub fn debug_redact_mut(&mut self) -> &mut bool {
        self.debug_redact.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_debug_redact(&mut self) {
        self.debug_redact = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for EnumValueOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.EnumValueOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for EnumValueOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.EnumValueOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.deprecated = Some(BoolCodec::parse(&f)?),
                2 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                3 => self.debug_redact = Some(BoolCodec::parse(&f)?),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(1, *v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(2, v.as_ref(), out)?;
        }
        if let Some(v) = self.debug_redact.as_ref() {
            BoolCodec::serialize(3, *v, out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for EnumValueOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("debug_redact"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.deprecated.reflect_clear_field(),
            2 => self.features.reflect_clear_field(),
            3 => self.debug_redact.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.deprecated.reflect_has_field(),
            2 => self.features.reflect_has_field(),
            3 => self.debug_redact.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.deprecated.reflect_field(),
            2 => self.features.reflect_field(),
            3 => self.debug_redact.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.deprecated.reflect_field_mut(),
            2 => self.features.reflect_field_mut(),
            3 => self.debug_redact.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "deprecated" => 1,
            "features" => 2,
            "debug_redact" => 3,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct ServiceOptions {
    features: Option<MessagePtr<FeatureSet>>,
    deprecated: Option<bool>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for ServiceOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for ServiceOptions {
    fn static_default() -> &'static Self {
        static VALUE: ServiceOptions = ServiceOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for ServiceOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl ServiceOptions {
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 34;
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 33;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for ServiceOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.ServiceOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for ServiceOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.ServiceOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                34 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                33 => self.deprecated = Some(BoolCodec::parse(&f)?),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(34, v.as_ref(), out)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(33, *v, out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for ServiceOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 34,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 33,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            34 => self.features.reflect_clear_field(),
            33 => self.deprecated.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            34 => self.features.reflect_has_field(),
            33 => self.deprecated.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            34 => self.features.reflect_field(),
            33 => self.deprecated.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            34 => self.features.reflect_field_mut(),
            33 => self.deprecated.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "features" => 34,
            "deprecated" => 33,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum MethodOptions_IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    NO_SIDE_EFFECTS = 1,
    IDEMPOTENT = 2,
}

impl MethodOptions_IdempotencyLevel {}

impl core::default::Default for MethodOptions_IdempotencyLevel {
    fn default() -> Self {
        Self::IDEMPOTENCY_UNKNOWN
    }
}

impl common::const_default::ConstDefault for MethodOptions_IdempotencyLevel {
    const DEFAULT: Self = Self::IDEMPOTENCY_UNKNOWN;
}

impl ReflectStatic for MethodOptions_IdempotencyLevel {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for MethodOptions_IdempotencyLevel {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
            1 => MethodOptions_IdempotencyLevel::NO_SIDE_EFFECTS,
            2 => MethodOptions_IdempotencyLevel::IDEMPOTENT,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "IDEMPOTENCY_UNKNOWN" => Self::IDEMPOTENCY_UNKNOWN,
            "NO_SIDE_EFFECTS" => Self::NO_SIDE_EFFECTS,
            "IDEMPOTENT" => Self::IDEMPOTENT,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::IDEMPOTENCY_UNKNOWN => "IDEMPOTENCY_UNKNOWN",
            Self::NO_SIDE_EFFECTS => "NO_SIDE_EFFECTS",
            Self::IDEMPOTENT => "IDEMPOTENT",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for MethodOptions_IdempotencyLevel {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct MethodOptions {
    deprecated: Option<bool>,
    idempotency_level: Option<MethodOptions_IdempotencyLevel>,
    features: Option<MessagePtr<FeatureSet>>,
    uninterpreted_option: Vec<MessagePtr<UninterpretedOption>>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for MethodOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for MethodOptions {
    fn static_default() -> &'static Self {
        static VALUE: MethodOptions = MethodOptions::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for MethodOptions {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl MethodOptions {
    pub const DEPRECATED_FIELD_NUM: protobuf_core::FieldNumber = 33;
    pub const IDEMPOTENCY_LEVEL_FIELD_NUM: protobuf_core::FieldNumber = 34;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 35;
    pub const UNINTERPRETED_OPTION_FIELD_NUM: protobuf_core::FieldNumber = 999;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn idempotency_level(&self) -> MethodOptions_IdempotencyLevel {
        self.idempotency_level
            .unwrap_or(MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN)
    }
    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }
    pub fn set_idempotency_level<V: ::core::convert::Into<MethodOptions_IdempotencyLevel>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.idempotency_level = Some(v);
    }
    pub fn idempotency_level_mut(&mut self) -> &mut MethodOptions_IdempotencyLevel {
        self.idempotency_level
            .get_or_insert_with(|| <MethodOptions_IdempotencyLevel>::default())
    }
    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }

    pub fn uninterpreted_option(&self) -> &[MessagePtr<UninterpretedOption>] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption>> {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }

    pub fn add_uninterpreted_option(
        &mut self,
        v: UninterpretedOption,
    ) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option.push(MessagePtr::new(v));
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn new_uninterpreted_option(&mut self) -> &mut MessagePtr<UninterpretedOption> {
        self.uninterpreted_option
            .push(<MessagePtr<UninterpretedOption>>::default());
        self.uninterpreted_option.last_mut().unwrap()
    }

    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::StaticMessage for MethodOptions {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.MethodOptions"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for MethodOptions {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.MethodOptions"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                33 => self.deprecated = Some(BoolCodec::parse(&f)?),
                34 => self.idempotency_level = Some(EnumCodec::parse(&f)?),
                35 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),
                999 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.uninterpreted_option.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.deprecated.as_ref() {
            BoolCodec::serialize(33, *v, out)?;
        }
        if let Some(v) = self.idempotency_level.as_ref() {
            EnumCodec::serialize(34, v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(35, v.as_ref(), out)?;
        }
        MessageCodec::serialize_repeated(999, &self.uninterpreted_option, out)?;
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for MethodOptions {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 33,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("idempotency_level"),
                number: 34,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 35,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            33 => self.deprecated.reflect_clear_field(),
            34 => self.idempotency_level.reflect_clear_field(),
            35 => self.features.reflect_clear_field(),
            999 => self.uninterpreted_option.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            33 => self.deprecated.reflect_has_field(),
            34 => self.idempotency_level.reflect_has_field(),
            35 => self.features.reflect_has_field(),
            999 => self.uninterpreted_option.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            33 => self.deprecated.reflect_field(),
            34 => self.idempotency_level.reflect_field(),
            35 => self.features.reflect_field(),
            999 => self.uninterpreted_option.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            33 => self.deprecated.reflect_field_mut(),
            34 => self.idempotency_level.reflect_field_mut(),
            35 => self.features.reflect_field_mut(),
            999 => self.uninterpreted_option.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "deprecated" => 33,
            "idempotency_level" => 34,
            "features" => 35,
            "uninterpreted_option" => 999,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct UninterpretedOption_NamePart {
    name_part: Option<String>,
    is_extension: Option<bool>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for UninterpretedOption_NamePart {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for UninterpretedOption_NamePart {
    fn static_default() -> &'static Self {
        static VALUE: UninterpretedOption_NamePart = UninterpretedOption_NamePart::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for UninterpretedOption_NamePart {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl UninterpretedOption_NamePart {
    pub const NAME_PART_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const IS_EXTENSION_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn name_part(&self) -> &str {
        self.name_part.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name_part(&self) -> bool {
        self.name_part.is_some()
    }
    pub fn set_name_part<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name_part = Some(v);
    }
    pub fn name_part_mut(&mut self) -> &mut String {
        self.name_part.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_name_part(&mut self) {
        self.name_part = None;
    }

    pub fn is_extension(&self) -> bool {
        self.is_extension.unwrap_or_default()
    }
    pub fn has_is_extension(&self) -> bool {
        self.is_extension.is_some()
    }
    pub fn set_is_extension<V: ::core::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.is_extension = Some(v);
    }
    pub fn is_extension_mut(&mut self) -> &mut bool {
        self.is_extension.get_or_insert_with(|| <bool>::default())
    }
    pub fn clear_is_extension(&mut self) {
        self.is_extension = None;
    }
}

impl protobuf_core::StaticMessage for UninterpretedOption_NamePart {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.UninterpretedOption.NamePart"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for UninterpretedOption_NamePart {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.UninterpretedOption.NamePart"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.name_part = Some(StringCodec::parse(&f)?),
                2 => self.is_extension = Some(BoolCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.name_part.as_ref() {
            StringCodec::serialize(1, v, out)?;
        } else {
            return Err(MessageSerializeError::RequiredFieldNotSet.into());
        }
        if let Some(v) = self.is_extension.as_ref() {
            BoolCodec::serialize(2, *v, out)?;
        } else {
            return Err(MessageSerializeError::RequiredFieldNotSet.into());
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for UninterpretedOption_NamePart {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name_part"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("is_extension"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.name_part.reflect_clear_field(),
            2 => self.is_extension.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.name_part.reflect_has_field(),
            2 => self.is_extension.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.name_part.reflect_field(),
            2 => self.is_extension.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name_part.reflect_field_mut(),
            2 => self.is_extension.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name_part" => 1,
            "is_extension" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct UninterpretedOption {
    name: Vec<MessagePtr<UninterpretedOption_NamePart>>,
    identifier_value: Option<String>,
    positive_int_value: Option<u64>,
    negative_int_value: Option<i64>,
    double_value: Option<f64>,
    string_value: Option<BytesField>,
    aggregate_value: Option<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for UninterpretedOption {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for UninterpretedOption {
    fn static_default() -> &'static Self {
        static VALUE: UninterpretedOption = UninterpretedOption::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for UninterpretedOption {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl UninterpretedOption {
    pub const NAME_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const IDENTIFIER_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const POSITIVE_INT_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const NEGATIVE_INT_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const DOUBLE_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 6;
    pub const STRING_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 7;
    pub const AGGREGATE_VALUE_FIELD_NUM: protobuf_core::FieldNumber = 8;

    pub fn name(&self) -> &[MessagePtr<UninterpretedOption_NamePart>] {
        &self.name
    }

    pub fn name_mut(&mut self) -> &mut Vec<MessagePtr<UninterpretedOption_NamePart>> {
        &mut self.name
    }

    pub fn name_len(&self) -> usize {
        self.name.len()
    }

    pub fn add_name(
        &mut self,
        v: UninterpretedOption_NamePart,
    ) -> &mut MessagePtr<UninterpretedOption_NamePart> {
        self.name.push(MessagePtr::new(v));
        self.name.last_mut().unwrap()
    }

    pub fn new_name(&mut self) -> &mut MessagePtr<UninterpretedOption_NamePart> {
        self.name
            .push(<MessagePtr<UninterpretedOption_NamePart>>::default());
        self.name.last_mut().unwrap()
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn identifier_value(&self) -> &str {
        self.identifier_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }
    pub fn set_identifier_value<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.identifier_value = Some(v);
    }
    pub fn identifier_value_mut(&mut self) -> &mut String {
        self.identifier_value
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = None;
    }

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or_default()
    }
    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }
    pub fn set_positive_int_value<V: ::core::convert::Into<u64>>(&mut self, v: V) {
        let v = v.into();
        self.positive_int_value = Some(v);
    }
    pub fn positive_int_value_mut(&mut self) -> &mut u64 {
        self.positive_int_value
            .get_or_insert_with(|| <u64>::default())
    }
    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = None;
    }

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or_default()
    }
    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }
    pub fn set_negative_int_value<V: ::core::convert::Into<i64>>(&mut self, v: V) {
        let v = v.into();
        self.negative_int_value = Some(v);
    }
    pub fn negative_int_value_mut(&mut self) -> &mut i64 {
        self.negative_int_value
            .get_or_insert_with(|| <i64>::default())
    }
    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = None;
    }

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or_default()
    }
    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }
    pub fn set_double_value<V: ::core::convert::Into<f64>>(&mut self, v: V) {
        let v = v.into();
        self.double_value = Some(v);
    }
    pub fn double_value_mut(&mut self) -> &mut f64 {
        self.double_value.get_or_insert_with(|| <f64>::default())
    }
    pub fn clear_double_value(&mut self) {
        self.double_value = None;
    }

    pub fn string_value(&self) -> &[u8] {
        self.string_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(&[])
    }
    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }
    pub fn set_string_value<V: ::core::convert::Into<BytesField>>(&mut self, v: V) {
        let v = v.into();
        self.string_value = Some(v);
    }
    pub fn string_value_mut(&mut self) -> &mut BytesField {
        self.string_value
            .get_or_insert_with(|| <BytesField>::default())
    }
    pub fn clear_string_value(&mut self) {
        self.string_value = None;
    }

    pub fn aggregate_value(&self) -> &str {
        self.aggregate_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }
    pub fn set_aggregate_value<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.aggregate_value = Some(v);
    }
    pub fn aggregate_value_mut(&mut self) -> &mut String {
        self.aggregate_value
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = None;
    }
}

impl protobuf_core::StaticMessage for UninterpretedOption {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.UninterpretedOption"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for UninterpretedOption {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.UninterpretedOption"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                2 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.name.push(MessagePtr::new(v?));
                    }
                }
                3 => self.identifier_value = Some(StringCodec::parse(&f)?),
                4 => self.positive_int_value = Some(UInt64Codec::parse(&f)?),
                5 => self.negative_int_value = Some(Int64Codec::parse(&f)?),
                6 => self.double_value = Some(DoubleCodec::parse(&f)?),
                7 => self.string_value = Some(BytesCodec::parse(&f)?),
                8 => self.aggregate_value = Some(StringCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(2, &self.name, out)?;
        if let Some(v) = self.identifier_value.as_ref() {
            StringCodec::serialize(3, v, out)?;
        }
        if let Some(v) = self.positive_int_value.as_ref() {
            UInt64Codec::serialize(4, *v, out)?;
        }
        if let Some(v) = self.negative_int_value.as_ref() {
            Int64Codec::serialize(5, *v, out)?;
        }
        if let Some(v) = self.double_value.as_ref() {
            DoubleCodec::serialize(6, *v, out)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            BytesCodec::serialize(7, v, out)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            StringCodec::serialize(8, v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for UninterpretedOption {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("identifier_value"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("positive_int_value"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("negative_int_value"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("double_value"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("string_value"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("aggregate_value"),
                number: 8,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            2 => self.name.reflect_clear_field(),
            3 => self.identifier_value.reflect_clear_field(),
            4 => self.positive_int_value.reflect_clear_field(),
            5 => self.negative_int_value.reflect_clear_field(),
            6 => self.double_value.reflect_clear_field(),
            7 => self.string_value.reflect_clear_field(),
            8 => self.aggregate_value.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            2 => self.name.reflect_has_field(),
            3 => self.identifier_value.reflect_has_field(),
            4 => self.positive_int_value.reflect_has_field(),
            5 => self.negative_int_value.reflect_has_field(),
            6 => self.double_value.reflect_has_field(),
            7 => self.string_value.reflect_has_field(),
            8 => self.aggregate_value.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            2 => self.name.reflect_field(),
            3 => self.identifier_value.reflect_field(),
            4 => self.positive_int_value.reflect_field(),
            5 => self.negative_int_value.reflect_field(),
            6 => self.double_value.reflect_field(),
            7 => self.string_value.reflect_field(),
            8 => self.aggregate_value.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            2 => self.name.reflect_field_mut(),
            3 => self.identifier_value.reflect_field_mut(),
            4 => self.positive_int_value.reflect_field_mut(),
            5 => self.negative_int_value.reflect_field_mut(),
            6 => self.double_value.reflect_field_mut(),
            7 => self.string_value.reflect_field_mut(),
            8 => self.aggregate_value.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 2,
            "identifier_value" => 3,
            "positive_int_value" => 4,
            "negative_int_value" => 5,
            "double_value" => 6,
            "string_value" => 7,
            "aggregate_value" => 8,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FeatureSet_FieldPresence {
    FIELD_PRESENCE_UNKNOWN = 0,
    EXPLICIT = 1,
    IMPLICIT = 2,
    LEGACY_REQUIRED = 3,
}

impl FeatureSet_FieldPresence {}

impl core::default::Default for FeatureSet_FieldPresence {
    fn default() -> Self {
        Self::FIELD_PRESENCE_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FeatureSet_FieldPresence {
    const DEFAULT: Self = Self::FIELD_PRESENCE_UNKNOWN;
}

impl ReflectStatic for FeatureSet_FieldPresence {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FeatureSet_FieldPresence {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FeatureSet_FieldPresence::FIELD_PRESENCE_UNKNOWN,
            1 => FeatureSet_FieldPresence::EXPLICIT,
            2 => FeatureSet_FieldPresence::IMPLICIT,
            3 => FeatureSet_FieldPresence::LEGACY_REQUIRED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "FIELD_PRESENCE_UNKNOWN" => Self::FIELD_PRESENCE_UNKNOWN,
            "EXPLICIT" => Self::EXPLICIT,
            "IMPLICIT" => Self::IMPLICIT,
            "LEGACY_REQUIRED" => Self::LEGACY_REQUIRED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::FIELD_PRESENCE_UNKNOWN => "FIELD_PRESENCE_UNKNOWN",
            Self::EXPLICIT => "EXPLICIT",
            Self::IMPLICIT => "IMPLICIT",
            Self::LEGACY_REQUIRED => "LEGACY_REQUIRED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FeatureSet_FieldPresence {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FeatureSet_EnumType {
    ENUM_TYPE_UNKNOWN = 0,
    OPEN = 1,
    CLOSED = 2,
}

impl FeatureSet_EnumType {}

impl core::default::Default for FeatureSet_EnumType {
    fn default() -> Self {
        Self::ENUM_TYPE_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FeatureSet_EnumType {
    const DEFAULT: Self = Self::ENUM_TYPE_UNKNOWN;
}

impl ReflectStatic for FeatureSet_EnumType {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FeatureSet_EnumType {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FeatureSet_EnumType::ENUM_TYPE_UNKNOWN,
            1 => FeatureSet_EnumType::OPEN,
            2 => FeatureSet_EnumType::CLOSED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "ENUM_TYPE_UNKNOWN" => Self::ENUM_TYPE_UNKNOWN,
            "OPEN" => Self::OPEN,
            "CLOSED" => Self::CLOSED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::ENUM_TYPE_UNKNOWN => "ENUM_TYPE_UNKNOWN",
            Self::OPEN => "OPEN",
            Self::CLOSED => "CLOSED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FeatureSet_EnumType {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FeatureSet_RepeatedFieldEncoding {
    REPEATED_FIELD_ENCODING_UNKNOWN = 0,
    PACKED = 1,
    EXPANDED = 2,
}

impl FeatureSet_RepeatedFieldEncoding {}

impl core::default::Default for FeatureSet_RepeatedFieldEncoding {
    fn default() -> Self {
        Self::REPEATED_FIELD_ENCODING_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FeatureSet_RepeatedFieldEncoding {
    const DEFAULT: Self = Self::REPEATED_FIELD_ENCODING_UNKNOWN;
}

impl ReflectStatic for FeatureSet_RepeatedFieldEncoding {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FeatureSet_RepeatedFieldEncoding {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FeatureSet_RepeatedFieldEncoding::REPEATED_FIELD_ENCODING_UNKNOWN,
            1 => FeatureSet_RepeatedFieldEncoding::PACKED,
            2 => FeatureSet_RepeatedFieldEncoding::EXPANDED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "REPEATED_FIELD_ENCODING_UNKNOWN" => Self::REPEATED_FIELD_ENCODING_UNKNOWN,
            "PACKED" => Self::PACKED,
            "EXPANDED" => Self::EXPANDED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::REPEATED_FIELD_ENCODING_UNKNOWN => "REPEATED_FIELD_ENCODING_UNKNOWN",
            Self::PACKED => "PACKED",
            Self::EXPANDED => "EXPANDED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FeatureSet_RepeatedFieldEncoding {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FeatureSet_MessageEncoding {
    MESSAGE_ENCODING_UNKNOWN = 0,
    LENGTH_PREFIXED = 1,
    DELIMITED = 2,
}

impl FeatureSet_MessageEncoding {}

impl core::default::Default for FeatureSet_MessageEncoding {
    fn default() -> Self {
        Self::MESSAGE_ENCODING_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FeatureSet_MessageEncoding {
    const DEFAULT: Self = Self::MESSAGE_ENCODING_UNKNOWN;
}

impl ReflectStatic for FeatureSet_MessageEncoding {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FeatureSet_MessageEncoding {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FeatureSet_MessageEncoding::MESSAGE_ENCODING_UNKNOWN,
            1 => FeatureSet_MessageEncoding::LENGTH_PREFIXED,
            2 => FeatureSet_MessageEncoding::DELIMITED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "MESSAGE_ENCODING_UNKNOWN" => Self::MESSAGE_ENCODING_UNKNOWN,
            "LENGTH_PREFIXED" => Self::LENGTH_PREFIXED,
            "DELIMITED" => Self::DELIMITED,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::MESSAGE_ENCODING_UNKNOWN => "MESSAGE_ENCODING_UNKNOWN",
            Self::LENGTH_PREFIXED => "LENGTH_PREFIXED",
            Self::DELIMITED => "DELIMITED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FeatureSet_MessageEncoding {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum FeatureSet_JsonFormat {
    JSON_FORMAT_UNKNOWN = 0,
    ALLOW = 1,
    LEGACY_BEST_EFFORT = 2,
}

impl FeatureSet_JsonFormat {}

impl core::default::Default for FeatureSet_JsonFormat {
    fn default() -> Self {
        Self::JSON_FORMAT_UNKNOWN
    }
}

impl common::const_default::ConstDefault for FeatureSet_JsonFormat {
    const DEFAULT: Self = Self::JSON_FORMAT_UNKNOWN;
}

impl ReflectStatic for FeatureSet_JsonFormat {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for FeatureSet_JsonFormat {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => FeatureSet_JsonFormat::JSON_FORMAT_UNKNOWN,
            1 => FeatureSet_JsonFormat::ALLOW,
            2 => FeatureSet_JsonFormat::LEGACY_BEST_EFFORT,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "JSON_FORMAT_UNKNOWN" => Self::JSON_FORMAT_UNKNOWN,
            "ALLOW" => Self::ALLOW,
            "LEGACY_BEST_EFFORT" => Self::LEGACY_BEST_EFFORT,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::JSON_FORMAT_UNKNOWN => "JSON_FORMAT_UNKNOWN",
            Self::ALLOW => "ALLOW",
            Self::LEGACY_BEST_EFFORT => "LEGACY_BEST_EFFORT",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FeatureSet_JsonFormat {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FeatureSet {
    field_presence: Option<FeatureSet_FieldPresence>,
    enum_type: Option<FeatureSet_EnumType>,
    repeated_field_encoding: Option<FeatureSet_RepeatedFieldEncoding>,
    message_encoding: Option<FeatureSet_MessageEncoding>,
    json_format: Option<FeatureSet_JsonFormat>,
    #[cfg(feature = "std")]
    extensions: protobuf_core::ExtensionSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FeatureSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FeatureSet {
    fn static_default() -> &'static Self {
        static VALUE: FeatureSet = FeatureSet::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FeatureSet {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FeatureSet {
    pub const FIELD_PRESENCE_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const ENUM_TYPE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const REPEATED_FIELD_ENCODING_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const MESSAGE_ENCODING_FIELD_NUM: protobuf_core::FieldNumber = 5;
    pub const JSON_FORMAT_FIELD_NUM: protobuf_core::FieldNumber = 6;

    pub fn field_presence(&self) -> FeatureSet_FieldPresence {
        self.field_presence.unwrap_or_default()
    }
    pub fn has_field_presence(&self) -> bool {
        self.field_presence.is_some()
    }
    pub fn set_field_presence<V: ::core::convert::Into<FeatureSet_FieldPresence>>(&mut self, v: V) {
        let v = v.into();
        self.field_presence = Some(v);
    }
    pub fn field_presence_mut(&mut self) -> &mut FeatureSet_FieldPresence {
        self.field_presence
            .get_or_insert_with(|| <FeatureSet_FieldPresence>::default())
    }
    pub fn clear_field_presence(&mut self) {
        self.field_presence = None;
    }

    pub fn enum_type(&self) -> FeatureSet_EnumType {
        self.enum_type.unwrap_or_default()
    }
    pub fn has_enum_type(&self) -> bool {
        self.enum_type.is_some()
    }
    pub fn set_enum_type<V: ::core::convert::Into<FeatureSet_EnumType>>(&mut self, v: V) {
        let v = v.into();
        self.enum_type = Some(v);
    }
    pub fn enum_type_mut(&mut self) -> &mut FeatureSet_EnumType {
        self.enum_type
            .get_or_insert_with(|| <FeatureSet_EnumType>::default())
    }
    pub fn clear_enum_type(&mut self) {
        self.enum_type = None;
    }

    pub fn repeated_field_encoding(&self) -> FeatureSet_RepeatedFieldEncoding {
        self.repeated_field_encoding.unwrap_or_default()
    }
    pub fn has_repeated_field_encoding(&self) -> bool {
        self.repeated_field_encoding.is_some()
    }
    pub fn set_repeated_field_encoding<
        V: ::core::convert::Into<FeatureSet_RepeatedFieldEncoding>,
    >(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.repeated_field_encoding = Some(v);
    }
    pub fn repeated_field_encoding_mut(&mut self) -> &mut FeatureSet_RepeatedFieldEncoding {
        self.repeated_field_encoding
            .get_or_insert_with(|| <FeatureSet_RepeatedFieldEncoding>::default())
    }
    pub fn clear_repeated_field_encoding(&mut self) {
        self.repeated_field_encoding = None;
    }

    pub fn message_encoding(&self) -> FeatureSet_MessageEncoding {
        self.message_encoding.unwrap_or_default()
    }
    pub fn has_message_encoding(&self) -> bool {
        self.message_encoding.is_some()
    }
    pub fn set_message_encoding<V: ::core::convert::Into<FeatureSet_MessageEncoding>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.message_encoding = Some(v);
    }
    pub fn message_encoding_mut(&mut self) -> &mut FeatureSet_MessageEncoding {
        self.message_encoding
            .get_or_insert_with(|| <FeatureSet_MessageEncoding>::default())
    }
    pub fn clear_message_encoding(&mut self) {
        self.message_encoding = None;
    }

    pub fn json_format(&self) -> FeatureSet_JsonFormat {
        self.json_format.unwrap_or_default()
    }
    pub fn has_json_format(&self) -> bool {
        self.json_format.is_some()
    }
    pub fn set_json_format<V: ::core::convert::Into<FeatureSet_JsonFormat>>(&mut self, v: V) {
        let v = v.into();
        self.json_format = Some(v);
    }
    pub fn json_format_mut(&mut self) -> &mut FeatureSet_JsonFormat {
        self.json_format
            .get_or_insert_with(|| <FeatureSet_JsonFormat>::default())
    }
    pub fn clear_json_format(&mut self) {
        self.json_format = None;
    }
}

impl protobuf_core::StaticMessage for FeatureSet {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FeatureSet"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FeatureSet {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FeatureSet"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.field_presence = Some(EnumCodec::parse(&f)?),
                2 => self.enum_type = Some(EnumCodec::parse(&f)?),
                3 => self.repeated_field_encoding = Some(EnumCodec::parse(&f)?),
                5 => self.message_encoding = Some(EnumCodec::parse(&f)?),
                6 => self.json_format = Some(EnumCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.extensions.parse_merge(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.field_presence.as_ref() {
            EnumCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.enum_type.as_ref() {
            EnumCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.repeated_field_encoding.as_ref() {
            EnumCodec::serialize(3, v, out)?;
        }
        if let Some(v) = self.message_encoding.as_ref() {
            EnumCodec::serialize(5, v, out)?;
        }
        if let Some(v) = self.json_format.as_ref() {
            EnumCodec::serialize(6, v, out)?;
        }
        #[cfg(feature = "std")]
        self.extensions.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FeatureSet {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.extensions.unknown_fields())
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        Some(&self.extensions)
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        Some(&mut self.extensions)
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("field_presence"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("enum_type"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("repeated_field_encoding"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("message_encoding"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("json_format"),
                number: 6,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.field_presence.reflect_clear_field(),
            2 => self.enum_type.reflect_clear_field(),
            3 => self.repeated_field_encoding.reflect_clear_field(),
            5 => self.message_encoding.reflect_clear_field(),
            6 => self.json_format.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.field_presence.reflect_has_field(),
            2 => self.enum_type.reflect_has_field(),
            3 => self.repeated_field_encoding.reflect_has_field(),
            5 => self.message_encoding.reflect_has_field(),
            6 => self.json_format.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.field_presence.reflect_field(),
            2 => self.enum_type.reflect_field(),
            3 => self.repeated_field_encoding.reflect_field(),
            5 => self.message_encoding.reflect_field(),
            6 => self.json_format.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.field_presence.reflect_field_mut(),
            2 => self.enum_type.reflect_field_mut(),
            3 => self.repeated_field_encoding.reflect_field_mut(),
            5 => self.message_encoding.reflect_field_mut(),
            6 => self.json_format.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "field_presence" => 1,
            "enum_type" => 2,
            "repeated_field_encoding" => 3,
            "message_encoding" => 5,
            "json_format" => 6,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FeatureSetDefaults_FeatureSetEditionDefault {
    edition: Option<String>,
    features: Option<MessagePtr<FeatureSet>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FeatureSetDefaults_FeatureSetEditionDefault {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FeatureSetDefaults_FeatureSetEditionDefault {
    fn static_default() -> &'static Self {
        static VALUE: FeatureSetDefaults_FeatureSetEditionDefault =
            FeatureSetDefaults_FeatureSetEditionDefault::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FeatureSetDefaults_FeatureSetEditionDefault {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FeatureSetDefaults_FeatureSetEditionDefault {
    pub const EDITION_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const FEATURES_FIELD_NUM: protobuf_core::FieldNumber = 2;

    pub fn edition(&self) -> &str {
        self.edition.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_edition(&self) -> bool {
        self.edition.is_some()
    }
    pub fn set_edition<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.edition = Some(v);
    }
    pub fn edition_mut(&mut self) -> &mut String {
        self.edition.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_edition(&mut self) {
        self.edition = None;
    }

    pub fn features(&self) -> &FeatureSet {
        self.features
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FeatureSet::static_default())
    }
    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }
    pub fn set_features<V: ::core::convert::Into<FeatureSet>>(&mut self, v: V) {
        let v = v.into();
        self.features = Some(MessagePtr::new(v));
    }
    pub fn features_mut(&mut self) -> &mut FeatureSet {
        self.features
            .get_or_insert_with(|| MessagePtr::new(FeatureSet::default()))
            .as_mut()
    }
    pub fn clear_features(&mut self) {
        self.features = None;
    }
}

impl protobuf_core::StaticMessage for FeatureSetDefaults_FeatureSetEditionDefault {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FeatureSetDefaults_FeatureSetEditionDefault {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => self.edition = Some(StringCodec::parse(&f)?),
                2 => self.features = Some(MessagePtr::new(MessageCodec::parse(&f)?)),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        if let Some(v) = self.edition.as_ref() {
            StringCodec::serialize(1, v, out)?;
        }
        if let Some(v) = self.features.as_ref() {
            MessageCodec::serialize(2, v.as_ref(), out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FeatureSetDefaults_FeatureSetEditionDefault {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("edition"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("features"),
                number: 2,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.edition.reflect_clear_field(),
            2 => self.features.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.edition.reflect_has_field(),
            2 => self.features.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.edition.reflect_field(),
            2 => self.features.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.edition.reflect_field_mut(),
            2 => self.features.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "edition" => 1,
            "features" => 2,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct FeatureSetDefaults {
    defaults: Vec<MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault>>,
    minimum_edition: Option<String>,
    maximum_edition: Option<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for FeatureSetDefaults {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for FeatureSetDefaults {
    fn static_default() -> &'static Self {
        static VALUE: FeatureSetDefaults = FeatureSetDefaults::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for FeatureSetDefaults {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl FeatureSetDefaults {
    pub const DEFAULTS_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const MINIMUM_EDITION_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const MAXIMUM_EDITION_FIELD_NUM: protobuf_core::FieldNumber = 3;

    pub fn defaults(&self) -> &[MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault>] {
        &self.defaults
    }

    pub fn defaults_mut(
        &mut self,
    ) -> &mut Vec<MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault>> {
        &mut self.defaults
    }

    pub fn defaults_len(&self) -> usize {
        self.defaults.len()
    }

    pub fn add_defaults(
        &mut self,
        v: FeatureSetDefaults_FeatureSetEditionDefault,
    ) -> &mut MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault> {
        self.defaults.push(MessagePtr::new(v));
        self.defaults.last_mut().unwrap()
    }

    pub fn new_defaults(&mut self) -> &mut MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault> {
        self.defaults
            .push(<MessagePtr<FeatureSetDefaults_FeatureSetEditionDefault>>::default());
        self.defaults.last_mut().unwrap()
    }

    pub fn clear_defaults(&mut self) {
        self.defaults.clear();
    }

    pub fn minimum_edition(&self) -> &str {
        self.minimum_edition
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_minimum_edition(&self) -> bool {
        self.minimum_edition.is_some()
    }
    pub fn set_minimum_edition<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.minimum_edition = Some(v);
    }
    pub fn minimum_edition_mut(&mut self) -> &mut String {
        self.minimum_edition
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_minimum_edition(&mut self) {
        self.minimum_edition = None;
    }

    pub fn maximum_edition(&self) -> &str {
        self.maximum_edition
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_maximum_edition(&self) -> bool {
        self.maximum_edition.is_some()
    }
    pub fn set_maximum_edition<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.maximum_edition = Some(v);
    }
    pub fn maximum_edition_mut(&mut self) -> &mut String {
        self.maximum_edition
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_maximum_edition(&mut self) {
        self.maximum_edition = None;
    }
}

impl protobuf_core::StaticMessage for FeatureSetDefaults {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.FeatureSetDefaults"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for FeatureSetDefaults {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.FeatureSetDefaults"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.defaults.push(MessagePtr::new(v?));
                    }
                }
                2 => self.minimum_edition = Some(StringCodec::parse(&f)?),
                3 => self.maximum_edition = Some(StringCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(1, &self.defaults, out)?;
        if let Some(v) = self.minimum_edition.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.maximum_edition.as_ref() {
            StringCodec::serialize(3, v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for FeatureSetDefaults {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("defaults"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("minimum_edition"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("maximum_edition"),
                number: 3,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.defaults.reflect_clear_field(),
            2 => self.minimum_edition.reflect_clear_field(),
            3 => self.maximum_edition.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.defaults.reflect_has_field(),
            2 => self.minimum_edition.reflect_has_field(),
            3 => self.maximum_edition.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.defaults.reflect_field(),
            2 => self.minimum_edition.reflect_field(),
            3 => self.maximum_edition.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.defaults.reflect_field_mut(),
            2 => self.minimum_edition.reflect_field_mut(),
            3 => self.maximum_edition.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "defaults" => 1,
            "minimum_edition" => 2,
            "maximum_edition" => 3,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct SourceCodeInfo_Location {
    path: Vec<i32>,
    span: Vec<i32>,
    leading_comments: Option<String>,
    trailing_comments: Option<String>,
    leading_detached_comments: Vec<String>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for SourceCodeInfo_Location {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for SourceCodeInfo_Location {
    fn static_default() -> &'static Self {
        static VALUE: SourceCodeInfo_Location = SourceCodeInfo_Location::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for SourceCodeInfo_Location {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl SourceCodeInfo_Location {
    pub const PATH_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const SPAN_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const LEADING_COMMENTS_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const TRAILING_COMMENTS_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const LEADING_DETACHED_COMMENTS_FIELD_NUM: protobuf_core::FieldNumber = 6;

    pub fn path(&self) -> &[i32] {
        &self.path
    }

    pub fn path_mut(&mut self) -> &mut Vec<i32> {
        &mut self.path
    }

    pub fn path_len(&self) -> usize {
        self.path.len()
    }

    pub fn add_path(&mut self, v: i32) -> &mut i32 {
        self.path.push(v);
        self.path.last_mut().unwrap()
    }

    pub fn new_path(&mut self) -> &mut i32 {
        self.path.push(<i32>::default());
        self.path.last_mut().unwrap()
    }

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn span(&self) -> &[i32] {
        &self.span
    }

    pub fn span_mut(&mut self) -> &mut Vec<i32> {
        &mut self.span
    }

    pub fn span_len(&self) -> usize {
        self.span.len()
    }

    pub fn add_span(&mut self, v: i32) -> &mut i32 {
        self.span.push(v);
        self.span.last_mut().unwrap()
    }

    pub fn new_span(&mut self) -> &mut i32 {
        self.span.push(<i32>::default());
        self.span.last_mut().unwrap()
    }

    pub fn clear_span(&mut self) {
        self.span.clear();
    }

    pub fn leading_comments(&self) -> &str {
        self.leading_comments
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_leading_comments(&self) -> bool {
        self.leading_comments.is_some()
    }
    pub fn set_leading_comments<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.leading_comments = Some(v);
    }
    pub fn leading_comments_mut(&mut self) -> &mut String {
        self.leading_comments
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_leading_comments(&mut self) {
        self.leading_comments = None;
    }

    pub fn trailing_comments(&self) -> &str {
        self.trailing_comments
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_trailing_comments(&self) -> bool {
        self.trailing_comments.is_some()
    }
    pub fn set_trailing_comments<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.trailing_comments = Some(v);
    }
    pub fn trailing_comments_mut(&mut self) -> &mut String {
        self.trailing_comments
            .get_or_insert_with(|| <String>::default())
    }
    pub fn clear_trailing_comments(&mut self) {
        self.trailing_comments = None;
    }

    pub fn leading_detached_comments(&self) -> &[String] {
        &self.leading_detached_comments
    }

    pub fn leading_detached_comments_mut(&mut self) -> &mut Vec<String> {
        &mut self.leading_detached_comments
    }

    pub fn leading_detached_comments_len(&self) -> usize {
        self.leading_detached_comments.len()
    }

    pub fn add_leading_detached_comments(&mut self, v: String) -> &mut String {
        self.leading_detached_comments.push(v);
        self.leading_detached_comments.last_mut().unwrap()
    }

    pub fn new_leading_detached_comments(&mut self) -> &mut String {
        self.leading_detached_comments.push(<String>::default());
        self.leading_detached_comments.last_mut().unwrap()
    }

    pub fn clear_leading_detached_comments(&mut self) {
        self.leading_detached_comments.clear();
    }
}

impl protobuf_core::StaticMessage for SourceCodeInfo_Location {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo.Location"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for SourceCodeInfo_Location {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo.Location"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in Int32Codec::parse_repeated(&f) {
                        self.path.push(v?);
                    }
                }
                2 => {
                    for v in Int32Codec::parse_repeated(&f) {
                        self.span.push(v?);
                    }
                }
                3 => self.leading_comments = Some(StringCodec::parse(&f)?),
                4 => self.trailing_comments = Some(StringCodec::parse(&f)?),
                6 => {
                    for v in StringCodec::parse_repeated(&f) {
                        self.leading_detached_comments.push(v?);
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        Int32Codec::serialize_repeated(1, &self.path, out)?;
        Int32Codec::serialize_repeated(2, &self.span, out)?;
        if let Some(v) = self.leading_comments.as_ref() {
            StringCodec::serialize(3, v, out)?;
        }
        if let Some(v) = self.trailing_comments.as_ref() {
            StringCodec::serialize(4, v, out)?;
        }
        StringCodec::serialize_repeated(6, &self.leading_detached_comments, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for SourceCodeInfo_Location {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("path"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("span"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("leading_comments"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("trailing_comments"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("leading_detached_comments"),
                number: 6,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.path.reflect_clear_field(),
            2 => self.span.reflect_clear_field(),
            3 => self.leading_comments.reflect_clear_field(),
            4 => self.trailing_comments.reflect_clear_field(),
            6 => self.leading_detached_comments.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.path.reflect_has_field(),
            2 => self.span.reflect_has_field(),
            3 => self.leading_comments.reflect_has_field(),
            4 => self.trailing_comments.reflect_has_field(),
            6 => self.leading_detached_comments.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.path.reflect_field(),
            2 => self.span.reflect_field(),
            3 => self.leading_comments.reflect_field(),
            4 => self.trailing_comments.reflect_field(),
            6 => self.leading_detached_comments.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.path.reflect_field_mut(),
            2 => self.span.reflect_field_mut(),
            3 => self.leading_comments.reflect_field_mut(),
            4 => self.trailing_comments.reflect_field_mut(),
            6 => self.leading_detached_comments.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "path" => 1,
            "span" => 2,
            "leading_comments" => 3,
            "trailing_comments" => 4,
            "leading_detached_comments" => 6,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct SourceCodeInfo {
    location: Vec<MessagePtr<SourceCodeInfo_Location>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for SourceCodeInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for SourceCodeInfo {
    fn static_default() -> &'static Self {
        static VALUE: SourceCodeInfo = SourceCodeInfo::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for SourceCodeInfo {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl SourceCodeInfo {
    pub const LOCATION_FIELD_NUM: protobuf_core::FieldNumber = 1;

    pub fn location(&self) -> &[MessagePtr<SourceCodeInfo_Location>] {
        &self.location
    }

    pub fn location_mut(&mut self) -> &mut Vec<MessagePtr<SourceCodeInfo_Location>> {
        &mut self.location
    }

    pub fn location_len(&self) -> usize {
        self.location.len()
    }

    pub fn add_location(
        &mut self,
        v: SourceCodeInfo_Location,
    ) -> &mut MessagePtr<SourceCodeInfo_Location> {
        self.location.push(MessagePtr::new(v));
        self.location.last_mut().unwrap()
    }

    pub fn new_location(&mut self) -> &mut MessagePtr<SourceCodeInfo_Location> {
        self.location
            .push(<MessagePtr<SourceCodeInfo_Location>>::default());
        self.location.last_mut().unwrap()
    }

    pub fn clear_location(&mut self) {
        self.location.clear();
    }
}

impl protobuf_core::StaticMessage for SourceCodeInfo {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for SourceCodeInfo {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.location.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(1, &self.location, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for SourceCodeInfo {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("location"),
            number: 1,
        }]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.location.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.location.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.location.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.location.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "location" => 1,

            _ => return None,
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub enum GeneratedCodeInfo_Annotation_Semantic {
    NONE = 0,
    SET = 1,
    ALIAS = 2,
}

impl GeneratedCodeInfo_Annotation_Semantic {}

impl core::default::Default for GeneratedCodeInfo_Annotation_Semantic {
    fn default() -> Self {
        Self::NONE
    }
}

impl common::const_default::ConstDefault for GeneratedCodeInfo_Annotation_Semantic {
    const DEFAULT: Self = Self::NONE;
}

impl ReflectStatic for GeneratedCodeInfo_Annotation_Semantic {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        &Self::DEFAULT
    }
}

impl protobuf_core::Enum for GeneratedCodeInfo_Annotation_Semantic {
    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Enum) + 'static> {
        Box::new(self.clone())
    }

    fn parse(v: protobuf_core::EnumValue) -> WireResult<Self> {
        Ok(match v {
            0 => GeneratedCodeInfo_Annotation_Semantic::NONE,
            1 => GeneratedCodeInfo_Annotation_Semantic::SET,
            2 => GeneratedCodeInfo_Annotation_Semantic::ALIAS,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }

    fn parse_name(s: &str) -> WireResult<Self> {
        Ok(match s {
            "NONE" => Self::NONE,
            "SET" => Self::SET,
            "ALIAS" => Self::ALIAS,
            _ => {
                return Err(WireError::UnknownEnumVariant);
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::NONE => "NONE",
            Self::SET => "SET",
            Self::ALIAS => "ALIAS",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> WireResult<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> WireResult<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for GeneratedCodeInfo_Annotation_Semantic {
    fn reflect(&self) -> protobuf_core::reflection::Reflection {
        protobuf_core::reflection::Reflection::Enum(self)
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct GeneratedCodeInfo_Annotation {
    path: Vec<i32>,
    source_file: Option<String>,
    begin: Option<i32>,
    end: Option<i32>,
    semantic: Option<GeneratedCodeInfo_Annotation_Semantic>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for GeneratedCodeInfo_Annotation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for GeneratedCodeInfo_Annotation {
    fn static_default() -> &'static Self {
        static VALUE: GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for GeneratedCodeInfo_Annotation {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl GeneratedCodeInfo_Annotation {
    pub const PATH_FIELD_NUM: protobuf_core::FieldNumber = 1;
    pub const SOURCE_FILE_FIELD_NUM: protobuf_core::FieldNumber = 2;
    pub const BEGIN_FIELD_NUM: protobuf_core::FieldNumber = 3;
    pub const END_FIELD_NUM: protobuf_core::FieldNumber = 4;
    pub const SEMANTIC_FIELD_NUM: protobuf_core::FieldNumber = 5;

    pub fn path(&self) -> &[i32] {
        &self.path
    }

    pub fn path_mut(&mut self) -> &mut Vec<i32> {
        &mut self.path
    }

    pub fn path_len(&self) -> usize {
        self.path.len()
    }

    pub fn add_path(&mut self, v: i32) -> &mut i32 {
        self.path.push(v);
        self.path.last_mut().unwrap()
    }

    pub fn new_path(&mut self) -> &mut i32 {
        self.path.push(<i32>::default());
        self.path.last_mut().unwrap()
    }

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn source_file(&self) -> &str {
        self.source_file.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_source_file(&self) -> bool {
        self.source_file.is_some()
    }
    pub fn set_source_file<V: ::core::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.source_file = Some(v);
    }
    pub fn source_file_mut(&mut self) -> &mut String {
        self.source_file.get_or_insert_with(|| <String>::default())
    }
    pub fn clear_source_file(&mut self) {
        self.source_file = None;
    }

    pub fn begin(&self) -> i32 {
        self.begin.unwrap_or_default()
    }
    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }
    pub fn set_begin<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.begin = Some(v);
    }
    pub fn begin_mut(&mut self) -> &mut i32 {
        self.begin.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_begin(&mut self) {
        self.begin = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::core::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| <i32>::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }

    pub fn semantic(&self) -> GeneratedCodeInfo_Annotation_Semantic {
        self.semantic.unwrap_or_default()
    }
    pub fn has_semantic(&self) -> bool {
        self.semantic.is_some()
    }
    pub fn set_semantic<V: ::core::convert::Into<GeneratedCodeInfo_Annotation_Semantic>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.semantic = Some(v);
    }
    pub fn semantic_mut(&mut self) -> &mut GeneratedCodeInfo_Annotation_Semantic {
        self.semantic
            .get_or_insert_with(|| <GeneratedCodeInfo_Annotation_Semantic>::default())
    }
    pub fn clear_semantic(&mut self) {
        self.semantic = None;
    }
}

impl protobuf_core::StaticMessage for GeneratedCodeInfo_Annotation {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo.Annotation"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for GeneratedCodeInfo_Annotation {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo.Annotation"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in Int32Codec::parse_repeated(&f) {
                        self.path.push(v?);
                    }
                }
                2 => self.source_file = Some(StringCodec::parse(&f)?),
                3 => self.begin = Some(Int32Codec::parse(&f)?),
                4 => self.end = Some(Int32Codec::parse(&f)?),
                5 => self.semantic = Some(EnumCodec::parse(&f)?),

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        Int32Codec::serialize_repeated(1, &self.path, out)?;
        if let Some(v) = self.source_file.as_ref() {
            StringCodec::serialize(2, v, out)?;
        }
        if let Some(v) = self.begin.as_ref() {
            Int32Codec::serialize(3, *v, out)?;
        }
        if let Some(v) = self.end.as_ref() {
            Int32Codec::serialize(4, *v, out)?;
        }
        if let Some(v) = self.semantic.as_ref() {
            EnumCodec::serialize(5, v, out)?;
        }
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for GeneratedCodeInfo_Annotation {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("path"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("source_file"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("begin"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("semantic"),
                number: 5,
            },
        ]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.path.reflect_clear_field(),
            2 => self.source_file.reflect_clear_field(),
            3 => self.begin.reflect_clear_field(),
            4 => self.end.reflect_clear_field(),
            5 => self.semantic.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.path.reflect_has_field(),
            2 => self.source_file.reflect_has_field(),
            3 => self.begin.reflect_has_field(),
            4 => self.end.reflect_has_field(),
            5 => self.semantic.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.path.reflect_field(),
            2 => self.source_file.reflect_field(),
            3 => self.begin.reflect_field(),
            4 => self.end.reflect_field(),
            5 => self.semantic.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.path.reflect_field_mut(),
            2 => self.source_file.reflect_field_mut(),
            3 => self.begin.reflect_field_mut(),
            4 => self.end.reflect_field_mut(),
            5 => self.semantic.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "path" => 1,
            "source_file" => 2,
            "begin" => 3,
            "end" => 4,
            "semantic" => 5,

            _ => return None,
        })
    }
}

#[derive(Clone, Default, PartialEq, ConstDefault)]
pub struct GeneratedCodeInfo {
    annotation: Vec<MessagePtr<GeneratedCodeInfo_Annotation>>,
    #[cfg(feature = "std")]
    unknown_fields: protobuf_core::UnknownFieldSet,
}

#[cfg(feature = "alloc")]
impl ::core::fmt::Debug for GeneratedCodeInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.write_str(&protobuf_core::text::serialize_text_proto(self))
    }
}

impl StaticDefault for GeneratedCodeInfo {
    fn static_default() -> &'static Self {
        static VALUE: GeneratedCodeInfo = GeneratedCodeInfo::DEFAULT;
        &VALUE
    }
}

impl ReflectStatic for GeneratedCodeInfo {
    type Type = Self;

    fn reflect_static_default() -> &'static Self::Type {
        Self::static_default()
    }
}

impl GeneratedCodeInfo {
    pub const ANNOTATION_FIELD_NUM: protobuf_core::FieldNumber = 1;

    pub fn annotation(&self) -> &[MessagePtr<GeneratedCodeInfo_Annotation>] {
        &self.annotation
    }

    pub fn annotation_mut(&mut self) -> &mut Vec<MessagePtr<GeneratedCodeInfo_Annotation>> {
        &mut self.annotation
    }

    pub fn annotation_len(&self) -> usize {
        self.annotation.len()
    }

    pub fn add_annotation(
        &mut self,
        v: GeneratedCodeInfo_Annotation,
    ) -> &mut MessagePtr<GeneratedCodeInfo_Annotation> {
        self.annotation.push(MessagePtr::new(v));
        self.annotation.last_mut().unwrap()
    }

    pub fn new_annotation(&mut self) -> &mut MessagePtr<GeneratedCodeInfo_Annotation> {
        self.annotation
            .push(<MessagePtr<GeneratedCodeInfo_Annotation>>::default());
        self.annotation.last_mut().unwrap()
    }

    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }
}

impl protobuf_core::StaticMessage for GeneratedCodeInfo {
    fn static_type_url() -> &'static str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo"
    }

    #[cfg(feature = "std")]
    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR_0F2934D003718DD8
    }
}

impl protobuf_core::Message for GeneratedCodeInfo {
    fn type_url(&self) -> &str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo"
    }

    #[cfg(feature = "alloc")]
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize_to(&mut data)?;
        Ok(data)
    }

    #[cfg(feature = "alloc")]
    fn merge_from(&mut self, other: &Self) -> Result<()>
    where
        Self: Sized,
    {
        use protobuf_core::ReflectMergeFrom;
        self.reflect_merge_from(other)
    }

    #[cfg(feature = "alloc")]
    fn box_clone(&self) -> Box<dyn (protobuf_core::Message) + 'static> {
        Box::new(self.clone())
    }

    fn parse_merge(&mut self, data: &[u8]) -> WireResult<()> {
        for field_ref in WireFieldIter::new(data) {
            let field_ref = field_ref?;
            let f = field_ref.field;
            match f.field_number {
                1 => {
                    for v in MessageCodec::parse_repeated(&f) {
                        self.annotation.push(MessagePtr::new(v?));
                    }
                }

                _ => {
                    #[cfg(feature = "std")]
                    self.unknown_fields.fields.push(field_ref.span.into());
                }
            }
        }
        Ok(())
    }
    fn serialize_to<A: Appendable<Item = u8> + ?Sized>(&self, out: &mut A) -> Result<()> {
        MessageCodec::serialize_repeated(1, &self.annotation, out)?;
        #[cfg(feature = "std")]
        self.unknown_fields.serialize_to(out)?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl protobuf_core::MessageReflection for GeneratedCodeInfo {
    fn unknown_fields(&self) -> Option<&protobuf_core::UnknownFieldSet> {
        Some(&self.unknown_fields)
    }

    fn extensions(&self) -> Option<&protobuf_core::ExtensionSet> {
        None
    }

    fn extensions_mut(&mut self) -> Option<&mut protobuf_core::ExtensionSet> {
        None
    }

    fn box_clone2(&self) -> Box<dyn (protobuf_core::MessageReflection) + 'static> {
        Box::new(self.clone())
    }

    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("annotation"),
            number: 1,
        }]
    }

    fn clear_field_with_number(&mut self, num: FieldNumber) {
        match num {
            1 => self.annotation.reflect_clear_field(),

            _ => {}
        }
    }

    fn has_field_with_number(&self, num: FieldNumber) -> bool {
        match num {
            1 => self.annotation.reflect_has_field(),

            _ => false,
        }
    }

    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        Some(match num {
            1 => self.annotation.reflect_field(),

            _ => return None,
        })
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.annotation.reflect_field_mut(),

            _ => return None,
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "annotation" => 1,

            _ => return None,
        })
    }
}
