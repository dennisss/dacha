// AUTOGENERATED BY PROTOBUF COMPILER

use std::sync::Arc;

use common::const_default::ConstDefault;
use common::errors::*;
use protobuf_core::reflection::*;
use protobuf_core::wire::*;
use protobuf_core::*;

pub static FILE_DESCRIPTOR: protobuf_core::StaticFileDescriptor = protobuf_core::StaticFileDescriptor {
                proto: b"\x12\x0fgoogle\x2eprotobuf\x226\x0a\x11FileDescriptorSet\x12\x21\x0a\x04file\x18\x01\x20\x03\x28\x0b2\x13FileDescriptorProto\x22\xf5\x02\x0a\x13FileDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x0f\x0a\x07package\x18\x02\x20\x01\x28\x09\x12\x12\x0a\x0adependency\x18\x03\x20\x03\x28\x09\x12\x19\x0a\x11public\x5fdependency\x18\x0a\x20\x03\x28\x05\x12\x17\x0a\x0fweak\x5fdependency\x18\x0b\x20\x03\x28\x05\x12\x25\x0a\x0cmessage\x5ftype\x18\x04\x20\x03\x28\x0b2\x0fDescriptorProto\x12\x26\x0a\x09enum\x5ftype\x18\x05\x20\x03\x28\x0b2\x13EnumDescriptorProto\x12\x27\x0a\x07service\x18\x06\x20\x03\x28\x0b2\x16ServiceDescriptorProto\x12\x27\x0a\x09extension\x18\x07\x20\x03\x28\x0b2\x14FieldDescriptorProto\x12\x1c\x0a\x07options\x18\x08\x20\x01\x28\x0b2\x0bFileOptions\x12\x28\x0a\x10source\x5fcode\x5finfo\x18\x09\x20\x01\x28\x0b2\x0eSourceCodeInfo\x12\x0e\x0a\x06syntax\x18\x0c\x20\x01\x28\x09\x22\xf0\x03\x0a\x0fDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x23\x0a\x05field\x18\x02\x20\x03\x28\x0b2\x14FieldDescriptorProto\x12\x27\x0a\x09extension\x18\x06\x20\x03\x28\x0b2\x14FieldDescriptorProto\x12\x24\x0a\x0bnested\x5ftype\x18\x03\x20\x03\x28\x0b2\x0fDescriptorProto\x12\x26\x0a\x09enum\x5ftype\x18\x04\x20\x03\x28\x0b2\x13EnumDescriptorProto\x12\x27\x0a\x0fextension\x5frange\x18\x05\x20\x03\x28\x0b2\x0eExtensionRange\x12\x28\x0a\x0aoneof\x5fdecl\x18\x08\x20\x03\x28\x0b2\x14OneofDescriptorProto\x12\x1f\x0a\x07options\x18\x07\x20\x01\x28\x0b2\x0eMessageOptions\x12\x25\x0a\x0ereserved\x5frange\x18\x09\x20\x03\x28\x0b2\x0dReservedRange\x12\x15\x0a\x0dreserved\x5fname\x18\x0a\x20\x03\x28\x09\x1aT\x0a\x0eExtensionRange\x12\x0d\x0a\x05start\x18\x01\x20\x01\x28\x05\x12\x0b\x0a\x03end\x18\x02\x20\x01\x28\x05\x12\x26\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x15ExtensionRangeOptions\x1a\x2b\x0a\x0dReservedRange\x12\x0d\x0a\x05start\x18\x01\x20\x01\x28\x05\x12\x0b\x0a\x03end\x18\x02\x20\x01\x28\x05\x22\x5b\x0a\x15ExtensionRangeOptions\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22\xdf\x04\x0a\x14FieldDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x0e\x0a\x06number\x18\x03\x20\x01\x28\x05\x12\x14\x0a\x05label\x18\x04\x20\x01\x28\x0b2\x05Label\x12\x12\x0a\x04type\x18\x05\x20\x01\x28\x0b2\x04Type\x12\x11\x0a\x09type\x5fname\x18\x06\x20\x01\x28\x09\x12\x10\x0a\x08extendee\x18\x02\x20\x01\x28\x09\x12\x15\x0a\x0ddefault\x5fvalue\x18\x07\x20\x01\x28\x09\x12\x13\x0a\x0boneof\x5findex\x18\x09\x20\x01\x28\x05\x12\x11\x0a\x09json\x5fname\x18\x0a\x20\x01\x28\x09\x12\x1d\x0a\x07options\x18\x08\x20\x01\x28\x0b2\x0cFieldOptions\x22\xb6\x02\x0a\x04Type\x12\x0f\x0a\x0bTYPE\x5fDOUBLE\x10\x01\x12\x0e\x0a\x0aTYPE\x5fFLOAT\x10\x02\x12\x0e\x0a\x0aTYPE\x5fINT64\x10\x03\x12\x0f\x0a\x0bTYPE\x5fUINT64\x10\x04\x12\x0e\x0a\x0aTYPE\x5fINT32\x10\x05\x12\x10\x0a\x0cTYPE\x5fFIXED64\x10\x06\x12\x10\x0a\x0cTYPE\x5fFIXED32\x10\x07\x12\x0d\x0a\x09TYPE\x5fBOOL\x10\x08\x12\x0f\x0a\x0bTYPE\x5fSTRING\x10\x09\x12\x0e\x0a\x0aTYPE\x5fGROUP\x10\x0a\x12\x10\x0a\x0cTYPE\x5fMESSAGE\x10\x0b\x12\x0e\x0a\x0aTYPE\x5fBYTES\x10\x0c\x12\x0f\x0a\x0bTYPE\x5fUINT32\x10\x0d\x12\x0d\x0a\x09TYPE\x5fENUM\x10\x0e\x12\x11\x0a\x0dTYPE\x5fSFIXED32\x10\x0f\x12\x11\x0a\x0dTYPE\x5fSFIXED64\x10\x10\x12\x0f\x0a\x0bTYPE\x5fSINT32\x10\x11\x12\x0f\x0a\x0bTYPE\x5fSINT64\x10\x12\x22C\x0a\x05Label\x12\x12\x0a\x0eLABEL\x5fOPTIONAL\x10\x01\x12\x12\x0a\x0eLABEL\x5fREQUIRED\x10\x02\x12\x12\x0a\x0eLABEL\x5fREPEATED\x10\x03\x22C\x0a\x14OneofDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x1d\x0a\x07options\x18\x02\x20\x01\x28\x0b2\x0cOneofOptions\x22\xdd\x01\x0a\x13EnumDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x27\x0a\x05value\x18\x02\x20\x03\x28\x0b2\x18EnumValueDescriptorProto\x12\x1c\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x0bEnumOptions\x12\x29\x0a\x0ereserved\x5frange\x18\x04\x20\x03\x28\x0b2\x11EnumReservedRange\x12\x15\x0a\x0dreserved\x5fname\x18\x05\x20\x03\x28\x09\x1a\x2f\x0a\x11EnumReservedRange\x12\x0d\x0a\x05start\x18\x01\x20\x01\x28\x05\x12\x0b\x0a\x03end\x18\x02\x20\x01\x28\x05\x22\x5b\x0a\x18EnumValueDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x0e\x0a\x06number\x18\x02\x20\x01\x28\x05\x12\x21\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x10EnumValueOptions\x22n\x0a\x16ServiceDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x25\x0a\x06method\x18\x02\x20\x03\x28\x0b2\x15MethodDescriptorProto\x12\x1f\x0a\x07options\x18\x03\x20\x01\x28\x0b2\x0eServiceOptions\x22\xa2\x01\x0a\x15MethodDescriptorProto\x12\x0c\x0a\x04name\x18\x01\x20\x01\x28\x09\x12\x12\x0a\x0ainput\x5ftype\x18\x02\x20\x01\x28\x09\x12\x13\x0a\x0boutput\x5ftype\x18\x03\x20\x01\x28\x09\x12\x1e\x0a\x07options\x18\x04\x20\x01\x28\x0b2\x0dMethodOptions\x12\x18\x0a\x10client\x5fstreaming\x18\x05\x20\x01\x28\x08\x12\x18\x0a\x10server\x5fstreaming\x18\x06\x20\x01\x28\x08\x22\xb4\x05\x0a\x0bFileOptions\x12\x14\x0a\x0cjava\x5fpackage\x18\x01\x20\x01\x28\x09\x12\x1c\x0a\x14java\x5fouter\x5fclassname\x18\x08\x20\x01\x28\x09\x12\x1b\x0a\x13java\x5fmultiple\x5ffiles\x18\x0a\x20\x01\x28\x08\x12\x25\x0a\x1djava\x5fgenerate\x5fequals\x5fand\x5fhash\x18\x14\x20\x01\x28\x08\x12\x1e\x0a\x16java\x5fstring\x5fcheck\x5futf8\x18\x1b\x20\x01\x28\x08\x12\x22\x0a\x0coptimize\x5ffor\x18\x09\x20\x01\x28\x0b2\x0cOptimizeMode\x12\x12\x0a\x0ago\x5fpackage\x18\x0b\x20\x01\x28\x09\x12\x1b\x0a\x13cc\x5fgeneric\x5fservices\x18\x10\x20\x01\x28\x08\x12\x1d\x0a\x15java\x5fgeneric\x5fservices\x18\x11\x20\x01\x28\x08\x12\x1b\x0a\x13py\x5fgeneric\x5fservices\x18\x12\x20\x01\x28\x08\x12\x1c\x0a\x14php\x5fgeneric\x5fservices\x18\x2a\x20\x01\x28\x08\x12\x12\x0a\x0adeprecated\x18\x17\x20\x01\x28\x08\x12\x18\x0a\x10cc\x5fenable\x5farenas\x18\x1f\x20\x01\x28\x08\x12\x19\x0a\x11objc\x5fclass\x5fprefix\x18\x24\x20\x01\x28\x09\x12\x18\x0a\x10csharp\x5fnamespace\x18\x25\x20\x01\x28\x09\x12\x14\x0a\x0cswift\x5fprefix\x18\x27\x20\x01\x28\x09\x12\x18\x0a\x10php\x5fclass\x5fprefix\x18\x28\x20\x01\x28\x09\x12\x15\x0a\x0dphp\x5fnamespace\x18\x29\x20\x01\x28\x09\x12\x1e\x0a\x16php\x5fmetadata\x5fnamespace\x18\x2c\x20\x01\x28\x09\x12\x14\x0a\x0cruby\x5fpackage\x18\x2d\x20\x01\x28\x09\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x22\x3a\x0a\x0cOptimizeMode\x12\x09\x0a\x05SPEED\x10\x01\x12\x0d\x0a\x09CODE\x5fSIZE\x10\x02\x12\x10\x0a\x0cLITE\x5fRUNTIME\x10\x03\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22\xc5\x01\x0a\x0eMessageOptions\x12\x1f\x0a\x17message\x5fset\x5fwire\x5fformat\x18\x01\x20\x01\x28\x08\x12\x27\x0a\x1fno\x5fstandard\x5fdescriptor\x5faccessor\x18\x02\x20\x01\x28\x08\x12\x12\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x12\x11\x0a\x09map\x5fentry\x18\x07\x20\x01\x28\x08\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22\xa8\x02\x0a\x0cFieldOptions\x12\x14\x0a\x05ctype\x18\x01\x20\x01\x28\x0b2\x05CType\x12\x0e\x0a\x06packed\x18\x02\x20\x01\x28\x08\x12\x16\x0a\x06jstype\x18\x06\x20\x01\x28\x0b2\x06JSType\x12\x0c\x0a\x04lazy\x18\x05\x20\x01\x28\x08\x12\x12\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x12\x0c\x0a\x04weak\x18\x0a\x20\x01\x28\x08\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x22\x2f\x0a\x05CType\x12\x0a\x0a\x06STRING\x10\x00\x12\x08\x0a\x04CORD\x10\x01\x12\x10\x0a\x0cSTRING\x5fPIECE\x10\x02\x225\x0a\x06JSType\x12\x0d\x0a\x09JS\x5fNORMAL\x10\x00\x12\x0d\x0a\x09JS\x5fSTRING\x10\x01\x12\x0d\x0a\x09JS\x5fNUMBER\x10\x02\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22R\x0a\x0cOneofOptions\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22z\x0a\x0bEnumOptions\x12\x13\x0a\x0ballow\x5falias\x18\x02\x20\x01\x28\x08\x12\x12\x0a\x0adeprecated\x18\x03\x20\x01\x28\x08\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22j\x0a\x10EnumValueOptions\x12\x12\x0a\x0adeprecated\x18\x01\x20\x01\x28\x08\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22h\x0a\x0eServiceOptions\x12\x12\x0a\x0adeprecated\x18\x21\x20\x01\x28\x08\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22\xe6\x01\x0a\x0dMethodOptions\x12\x12\x0a\x0adeprecated\x18\x21\x20\x01\x28\x08\x12\x2b\x0a\x11idempotency\x5flevel\x18\x22\x20\x01\x28\x0b2\x10IdempotencyLevel\x122\x0a\x14uninterpreted\x5foption\x18\xe7\x07\x20\x03\x28\x0b2\x13UninterpretedOption\x22P\x0a\x10IdempotencyLevel\x12\x17\x0a\x13IDEMPOTENCY\x5fUNKNOWN\x10\x00\x12\x13\x0a\x0fNO\x5fSIDE\x5fEFFECTS\x10\x01\x12\x0e\x0a\x0aIDEMPOTENT\x10\x02\x2a\x0e\x08\xe8\x07\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x22\xf9\x01\x0a\x13UninterpretedOption\x12\x16\x0a\x04name\x18\x02\x20\x03\x28\x0b2\x08NamePart\x12\x18\x0a\x10identifier\x5fvalue\x18\x03\x20\x01\x28\x09\x12\x1a\x0a\x12positive\x5fint\x5fvalue\x18\x04\x20\x01\x28\x04\x12\x1a\x0a\x12negative\x5fint\x5fvalue\x18\x05\x20\x01\x28\x03\x12\x14\x0a\x0cdouble\x5fvalue\x18\x06\x20\x01\x28\x01\x12\x14\x0a\x0cstring\x5fvalue\x18\x07\x20\x01\x28\x0c\x12\x17\x0a\x0faggregate\x5fvalue\x18\x08\x20\x01\x28\x09\x1a3\x0a\x08NamePart\x12\x11\x0a\x09name\x5fpart\x18\x01\x20\x02\x28\x09\x12\x14\x0a\x0cis\x5fextension\x18\x02\x20\x02\x28\x08\x22\xac\x01\x0a\x0eSourceCodeInfo\x12\x1a\x0a\x08location\x18\x01\x20\x03\x28\x0b2\x08Location\x1a\x7e\x0a\x08Location\x12\x0c\x0a\x04path\x18\x01\x20\x03\x28\x05\x12\x0c\x0a\x04span\x18\x02\x20\x03\x28\x05\x12\x18\x0a\x10leading\x5fcomments\x18\x03\x20\x01\x28\x09\x12\x19\x0a\x11trailing\x5fcomments\x18\x04\x20\x01\x28\x09\x12\x21\x0a\x19leading\x5fdetached\x5fcomments\x18\x06\x20\x03\x28\x09\x22\x80\x01\x0a\x11GeneratedCodeInfo\x12\x1e\x0a\x0aannotation\x18\x01\x20\x03\x28\x0b2\x0aAnnotation\x1aK\x0a\x0aAnnotation\x12\x0c\x0a\x04path\x18\x01\x20\x03\x28\x05\x12\x13\x0a\x0bsource\x5ffile\x18\x02\x20\x01\x28\x09\x12\x0d\x0a\x05begin\x18\x03\x20\x01\x28\x05\x12\x0b\x0a\x03end\x18\x04\x20\x01\x28\x05b\x06proto2",
                dependencies: &[]
            };
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct FileDescriptorSet {
    file: Vec<FileDescriptorProto>,
}

impl FileDescriptorSet {
    pub fn static_default_value() -> &'static Self {
        static VALUE: FileDescriptorSet = FileDescriptorSet::DEFAULT;
        &VALUE
    }

    pub fn file(&self) -> &[FileDescriptorProto] {
        &self.file
    }

    pub fn file_mut(&mut self) -> &mut [FileDescriptorProto] {
        &mut self.file
    }

    pub fn file_len(&self) -> usize {
        self.file.len()
    }
    pub fn add_file(&mut self, v: FileDescriptorProto) -> &mut FileDescriptorProto {
        self.file.push(v);
        self.file.last_mut().unwrap()
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }
}

impl protobuf_core::Message for FileDescriptorSet {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.FileDescriptorSet"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => {
                    self.file.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.file.iter() {
            WireField::serialize_message(1, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for FileDescriptorSet {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("file"),
            number: 1,
        }]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.file.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.file.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "file" => 1,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct FileDescriptorProto {
    name: Option<String>,
    package: Option<String>,
    dependency: Vec<String>,
    public_dependency: Vec<i32>,
    weak_dependency: Vec<i32>,
    message_type: Vec<DescriptorProto>,
    enum_type: Vec<EnumDescriptorProto>,
    service: Vec<ServiceDescriptorProto>,
    extension: Vec<FieldDescriptorProto>,
    options: Option<MessagePtr<FileOptions>>,
    source_code_info: Option<MessagePtr<SourceCodeInfo>>,
    syntax: Option<String>,
}

impl FileDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: FileDescriptorProto = FileDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn package(&self) -> &str {
        self.package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }
    pub fn set_package<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.package = Some(v);
    }
    pub fn package_mut(&mut self) -> &mut String {
        self.package.get_or_insert_with(|| String::default())
    }
    pub fn clear_package(&mut self) {
        self.package = None;
    }

    pub fn dependency(&self) -> &[String] {
        &self.dependency
    }

    pub fn dependency_mut(&mut self) -> &mut [String] {
        &mut self.dependency
    }

    pub fn dependency_len(&self) -> usize {
        self.dependency.len()
    }
    pub fn add_dependency(&mut self, v: String) -> &mut String {
        self.dependency.push(v);
        self.dependency.last_mut().unwrap()
    }
    pub fn clear_dependency(&mut self) {
        self.dependency.clear();
    }

    pub fn public_dependency(&self) -> &[i32] {
        &self.public_dependency
    }

    pub fn public_dependency_mut(&mut self) -> &mut [i32] {
        &mut self.public_dependency
    }

    pub fn public_dependency_len(&self) -> usize {
        self.public_dependency.len()
    }
    pub fn add_public_dependency(&mut self, v: i32) -> &mut i32 {
        self.public_dependency.push(v);
        self.public_dependency.last_mut().unwrap()
    }
    pub fn clear_public_dependency(&mut self) {
        self.public_dependency.clear();
    }

    pub fn weak_dependency(&self) -> &[i32] {
        &self.weak_dependency
    }

    pub fn weak_dependency_mut(&mut self) -> &mut [i32] {
        &mut self.weak_dependency
    }

    pub fn weak_dependency_len(&self) -> usize {
        self.weak_dependency.len()
    }
    pub fn add_weak_dependency(&mut self, v: i32) -> &mut i32 {
        self.weak_dependency.push(v);
        self.weak_dependency.last_mut().unwrap()
    }
    pub fn clear_weak_dependency(&mut self) {
        self.weak_dependency.clear();
    }

    pub fn message_type(&self) -> &[DescriptorProto] {
        &self.message_type
    }

    pub fn message_type_mut(&mut self) -> &mut [DescriptorProto] {
        &mut self.message_type
    }

    pub fn message_type_len(&self) -> usize {
        self.message_type.len()
    }
    pub fn add_message_type(&mut self, v: DescriptorProto) -> &mut DescriptorProto {
        self.message_type.push(v);
        self.message_type.last_mut().unwrap()
    }
    pub fn clear_message_type(&mut self) {
        self.message_type.clear();
    }

    pub fn enum_type(&self) -> &[EnumDescriptorProto] {
        &self.enum_type
    }

    pub fn enum_type_mut(&mut self) -> &mut [EnumDescriptorProto] {
        &mut self.enum_type
    }

    pub fn enum_type_len(&self) -> usize {
        self.enum_type.len()
    }
    pub fn add_enum_type(&mut self, v: EnumDescriptorProto) -> &mut EnumDescriptorProto {
        self.enum_type.push(v);
        self.enum_type.last_mut().unwrap()
    }
    pub fn clear_enum_type(&mut self) {
        self.enum_type.clear();
    }

    pub fn service(&self) -> &[ServiceDescriptorProto] {
        &self.service
    }

    pub fn service_mut(&mut self) -> &mut [ServiceDescriptorProto] {
        &mut self.service
    }

    pub fn service_len(&self) -> usize {
        self.service.len()
    }
    pub fn add_service(&mut self, v: ServiceDescriptorProto) -> &mut ServiceDescriptorProto {
        self.service.push(v);
        self.service.last_mut().unwrap()
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn extension(&self) -> &[FieldDescriptorProto] {
        &self.extension
    }

    pub fn extension_mut(&mut self) -> &mut [FieldDescriptorProto] {
        &mut self.extension
    }

    pub fn extension_len(&self) -> usize {
        self.extension.len()
    }
    pub fn add_extension(&mut self, v: FieldDescriptorProto) -> &mut FieldDescriptorProto {
        self.extension.push(v);
        self.extension.last_mut().unwrap()
    }
    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    pub fn options(&self) -> &FileOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FileOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<FileOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut FileOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(FileOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn source_code_info(&self) -> &SourceCodeInfo {
        self.source_code_info
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(SourceCodeInfo::static_default_value())
    }
    pub fn has_source_code_info(&self) -> bool {
        self.source_code_info.is_some()
    }
    pub fn set_source_code_info<V: ::std::convert::Into<SourceCodeInfo>>(&mut self, v: V) {
        let v = v.into();
        self.source_code_info = Some(MessagePtr::new(v));
    }
    pub fn source_code_info_mut(&mut self) -> &mut SourceCodeInfo {
        self.source_code_info
            .get_or_insert_with(|| MessagePtr::new(SourceCodeInfo::default()))
            .as_mut()
    }
    pub fn clear_source_code_info(&mut self) {
        self.source_code_info = None;
    }

    pub fn syntax(&self) -> &str {
        self.syntax.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }
    pub fn set_syntax<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.syntax = Some(v);
    }
    pub fn syntax_mut(&mut self) -> &mut String {
        self.syntax.get_or_insert_with(|| String::default())
    }
    pub fn clear_syntax(&mut self) {
        self.syntax = None;
    }
}

impl protobuf_core::Message for FileDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.FileDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => self.package = Some(f.parse_string()?),
                3 => {
                    self.dependency.push(f.parse_string()?);
                }
                10 => {
                    self.public_dependency.push(f.parse_int32()?);
                }
                11 => {
                    self.weak_dependency.push(f.parse_int32()?);
                }
                4 => {
                    self.message_type.push(f.parse_message()?);
                }
                5 => {
                    self.enum_type.push(f.parse_message()?);
                }
                6 => {
                    self.service.push(f.parse_message()?);
                }
                7 => {
                    self.extension.push(f.parse_message()?);
                }
                8 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                9 => self.source_code_info = Some(MessagePtr::new(f.parse_message()?)),
                12 => self.syntax = Some(f.parse_string()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.package.as_ref() {
            WireField::serialize_string(2, v, &mut data)?;
        }
        for v in self.dependency.iter() {
            WireField::serialize_string(3, v, &mut data)?;
        }
        for v in self.public_dependency.iter() {
            WireField::serialize_int32(10, *v, &mut data)?;
        }
        for v in self.weak_dependency.iter() {
            WireField::serialize_int32(11, *v, &mut data)?;
        }
        for v in self.message_type.iter() {
            WireField::serialize_message(4, v, &mut data)?;
        }
        for v in self.enum_type.iter() {
            WireField::serialize_message(5, v, &mut data)?;
        }
        for v in self.service.iter() {
            WireField::serialize_message(6, v, &mut data)?;
        }
        for v in self.extension.iter() {
            WireField::serialize_message(7, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(8, v.as_ref(), &mut data)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            WireField::serialize_message(9, v.as_ref(), &mut data)?;
        }
        if let Some(v) = self.syntax.as_ref() {
            WireField::serialize_string(12, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for FileDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("package"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("dependency"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("public_dependency"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("weak_dependency"),
                number: 11,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("message_type"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("enum_type"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("service"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("source_code_info"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("syntax"),
                number: 12,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.package.reflect(),
            3 => self.dependency.reflect(),
            10 => self.public_dependency.reflect(),
            11 => self.weak_dependency.reflect(),
            4 => self.message_type.reflect(),
            5 => self.enum_type.reflect(),
            6 => self.service.reflect(),
            7 => self.extension.reflect(),
            8 => self.options.reflect(),
            9 => self.source_code_info.reflect(),
            12 => self.syntax.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.package.reflect_mut(),
            3 => self.dependency.reflect_mut(),
            10 => self.public_dependency.reflect_mut(),
            11 => self.weak_dependency.reflect_mut(),
            4 => self.message_type.reflect_mut(),
            5 => self.enum_type.reflect_mut(),
            6 => self.service.reflect_mut(),
            7 => self.extension.reflect_mut(),
            8 => self.options.reflect_mut(),
            9 => self.source_code_info.reflect_mut(),
            12 => self.syntax.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "package" => 2,
            "dependency" => 3,
            "public_dependency" => 10,
            "weak_dependency" => 11,
            "message_type" => 4,
            "enum_type" => 5,
            "service" => 6,
            "extension" => 7,
            "options" => 8,
            "source_code_info" => 9,
            "syntax" => 12,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct DescriptorProto_ExtensionRange {
    start: Option<i32>,
    end: Option<i32>,
    options: Option<MessagePtr<ExtensionRangeOptions>>,
}

impl DescriptorProto_ExtensionRange {
    pub fn static_default_value() -> &'static Self {
        static VALUE: DescriptorProto_ExtensionRange = DescriptorProto_ExtensionRange::DEFAULT;
        &VALUE
    }

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| i32::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| i32::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }

    pub fn options(&self) -> &ExtensionRangeOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(ExtensionRangeOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<ExtensionRangeOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut ExtensionRangeOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(ExtensionRangeOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::Message for DescriptorProto_ExtensionRange {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ExtensionRange"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.start = Some(f.parse_int32()?),
                2 => self.end = Some(f.parse_int32()?),
                3 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.start.as_ref() {
            WireField::serialize_int32(1, *v, &mut data)?;
        }
        if let Some(v) = self.end.as_ref() {
            WireField::serialize_int32(2, *v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(3, v.as_ref(), &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for DescriptorProto_ExtensionRange {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.start.reflect(),
            2 => self.end.reflect(),
            3 => self.options.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_mut(),
            2 => self.end.reflect_mut(),
            3 => self.options.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,
            "options" => 3,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct DescriptorProto_ReservedRange {
    start: Option<i32>,
    end: Option<i32>,
}

impl DescriptorProto_ReservedRange {
    pub fn static_default_value() -> &'static Self {
        static VALUE: DescriptorProto_ReservedRange = DescriptorProto_ReservedRange::DEFAULT;
        &VALUE
    }

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| i32::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| i32::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }
}

impl protobuf_core::Message for DescriptorProto_ReservedRange {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto.ReservedRange"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.start = Some(f.parse_int32()?),
                2 => self.end = Some(f.parse_int32()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.start.as_ref() {
            WireField::serialize_int32(1, *v, &mut data)?;
        }
        if let Some(v) = self.end.as_ref() {
            WireField::serialize_int32(2, *v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for DescriptorProto_ReservedRange {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.start.reflect(),
            2 => self.end.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_mut(),
            2 => self.end.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct DescriptorProto {
    name: Option<String>,
    field: Vec<FieldDescriptorProto>,
    extension: Vec<FieldDescriptorProto>,
    nested_type: Vec<DescriptorProto>,
    enum_type: Vec<EnumDescriptorProto>,
    extension_range: Vec<DescriptorProto_ExtensionRange>,
    oneof_decl: Vec<OneofDescriptorProto>,
    options: Option<MessagePtr<MessageOptions>>,
    reserved_range: Vec<DescriptorProto_ReservedRange>,
    reserved_name: Vec<String>,
}

impl DescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: DescriptorProto = DescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn field(&self) -> &[FieldDescriptorProto] {
        &self.field
    }

    pub fn field_mut(&mut self) -> &mut [FieldDescriptorProto] {
        &mut self.field
    }

    pub fn field_len(&self) -> usize {
        self.field.len()
    }
    pub fn add_field(&mut self, v: FieldDescriptorProto) -> &mut FieldDescriptorProto {
        self.field.push(v);
        self.field.last_mut().unwrap()
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn extension(&self) -> &[FieldDescriptorProto] {
        &self.extension
    }

    pub fn extension_mut(&mut self) -> &mut [FieldDescriptorProto] {
        &mut self.extension
    }

    pub fn extension_len(&self) -> usize {
        self.extension.len()
    }
    pub fn add_extension(&mut self, v: FieldDescriptorProto) -> &mut FieldDescriptorProto {
        self.extension.push(v);
        self.extension.last_mut().unwrap()
    }
    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    pub fn nested_type(&self) -> &[DescriptorProto] {
        &self.nested_type
    }

    pub fn nested_type_mut(&mut self) -> &mut [DescriptorProto] {
        &mut self.nested_type
    }

    pub fn nested_type_len(&self) -> usize {
        self.nested_type.len()
    }
    pub fn add_nested_type(&mut self, v: DescriptorProto) -> &mut DescriptorProto {
        self.nested_type.push(v);
        self.nested_type.last_mut().unwrap()
    }
    pub fn clear_nested_type(&mut self) {
        self.nested_type.clear();
    }

    pub fn enum_type(&self) -> &[EnumDescriptorProto] {
        &self.enum_type
    }

    pub fn enum_type_mut(&mut self) -> &mut [EnumDescriptorProto] {
        &mut self.enum_type
    }

    pub fn enum_type_len(&self) -> usize {
        self.enum_type.len()
    }
    pub fn add_enum_type(&mut self, v: EnumDescriptorProto) -> &mut EnumDescriptorProto {
        self.enum_type.push(v);
        self.enum_type.last_mut().unwrap()
    }
    pub fn clear_enum_type(&mut self) {
        self.enum_type.clear();
    }

    pub fn extension_range(&self) -> &[DescriptorProto_ExtensionRange] {
        &self.extension_range
    }

    pub fn extension_range_mut(&mut self) -> &mut [DescriptorProto_ExtensionRange] {
        &mut self.extension_range
    }

    pub fn extension_range_len(&self) -> usize {
        self.extension_range.len()
    }
    pub fn add_extension_range(
        &mut self,
        v: DescriptorProto_ExtensionRange,
    ) -> &mut DescriptorProto_ExtensionRange {
        self.extension_range.push(v);
        self.extension_range.last_mut().unwrap()
    }
    pub fn clear_extension_range(&mut self) {
        self.extension_range.clear();
    }

    pub fn oneof_decl(&self) -> &[OneofDescriptorProto] {
        &self.oneof_decl
    }

    pub fn oneof_decl_mut(&mut self) -> &mut [OneofDescriptorProto] {
        &mut self.oneof_decl
    }

    pub fn oneof_decl_len(&self) -> usize {
        self.oneof_decl.len()
    }
    pub fn add_oneof_decl(&mut self, v: OneofDescriptorProto) -> &mut OneofDescriptorProto {
        self.oneof_decl.push(v);
        self.oneof_decl.last_mut().unwrap()
    }
    pub fn clear_oneof_decl(&mut self) {
        self.oneof_decl.clear();
    }

    pub fn options(&self) -> &MessageOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(MessageOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<MessageOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut MessageOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(MessageOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn reserved_range(&self) -> &[DescriptorProto_ReservedRange] {
        &self.reserved_range
    }

    pub fn reserved_range_mut(&mut self) -> &mut [DescriptorProto_ReservedRange] {
        &mut self.reserved_range
    }

    pub fn reserved_range_len(&self) -> usize {
        self.reserved_range.len()
    }
    pub fn add_reserved_range(
        &mut self,
        v: DescriptorProto_ReservedRange,
    ) -> &mut DescriptorProto_ReservedRange {
        self.reserved_range.push(v);
        self.reserved_range.last_mut().unwrap()
    }
    pub fn clear_reserved_range(&mut self) {
        self.reserved_range.clear();
    }

    pub fn reserved_name(&self) -> &[String] {
        &self.reserved_name
    }

    pub fn reserved_name_mut(&mut self) -> &mut [String] {
        &mut self.reserved_name
    }

    pub fn reserved_name_len(&self) -> usize {
        self.reserved_name.len()
    }
    pub fn add_reserved_name(&mut self, v: String) -> &mut String {
        self.reserved_name.push(v);
        self.reserved_name.last_mut().unwrap()
    }
    pub fn clear_reserved_name(&mut self) {
        self.reserved_name.clear();
    }
}

impl protobuf_core::Message for DescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.DescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => {
                    self.field.push(f.parse_message()?);
                }
                6 => {
                    self.extension.push(f.parse_message()?);
                }
                3 => {
                    self.nested_type.push(f.parse_message()?);
                }
                4 => {
                    self.enum_type.push(f.parse_message()?);
                }
                5 => {
                    self.extension_range.push(f.parse_message()?);
                }
                8 => {
                    self.oneof_decl.push(f.parse_message()?);
                }
                7 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                9 => {
                    self.reserved_range.push(f.parse_message()?);
                }
                10 => {
                    self.reserved_name.push(f.parse_string()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        for v in self.field.iter() {
            WireField::serialize_message(2, v, &mut data)?;
        }
        for v in self.extension.iter() {
            WireField::serialize_message(6, v, &mut data)?;
        }
        for v in self.nested_type.iter() {
            WireField::serialize_message(3, v, &mut data)?;
        }
        for v in self.enum_type.iter() {
            WireField::serialize_message(4, v, &mut data)?;
        }
        for v in self.extension_range.iter() {
            WireField::serialize_message(5, v, &mut data)?;
        }
        for v in self.oneof_decl.iter() {
            WireField::serialize_message(8, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(7, v.as_ref(), &mut data)?;
        }
        for v in self.reserved_range.iter() {
            WireField::serialize_message(9, v, &mut data)?;
        }
        for v in self.reserved_name.iter() {
            WireField::serialize_string(10, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for DescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("field"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("nested_type"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("enum_type"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extension_range"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("oneof_decl"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_range"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_name"),
                number: 10,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.field.reflect(),
            6 => self.extension.reflect(),
            3 => self.nested_type.reflect(),
            4 => self.enum_type.reflect(),
            5 => self.extension_range.reflect(),
            8 => self.oneof_decl.reflect(),
            7 => self.options.reflect(),
            9 => self.reserved_range.reflect(),
            10 => self.reserved_name.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.field.reflect_mut(),
            6 => self.extension.reflect_mut(),
            3 => self.nested_type.reflect_mut(),
            4 => self.enum_type.reflect_mut(),
            5 => self.extension_range.reflect_mut(),
            8 => self.oneof_decl.reflect_mut(),
            7 => self.options.reflect_mut(),
            9 => self.reserved_range.reflect_mut(),
            10 => self.reserved_name.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "field" => 2,
            "extension" => 6,
            "nested_type" => 3,
            "enum_type" => 4,
            "extension_range" => 5,
            "oneof_decl" => 8,
            "options" => 7,
            "reserved_range" => 9,
            "reserved_name" => 10,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct ExtensionRangeOptions {
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl ExtensionRangeOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: ExtensionRangeOptions = ExtensionRangeOptions::DEFAULT;
        &VALUE
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for ExtensionRangeOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.ExtensionRangeOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for ExtensionRangeOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("uninterpreted_option"),
            number: 999,
        }]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum FieldDescriptorProto_Type {
    TYPE_DOUBLE = 1,
    TYPE_FLOAT = 2,
    TYPE_INT64 = 3,
    TYPE_UINT64 = 4,
    TYPE_INT32 = 5,
    TYPE_FIXED64 = 6,
    TYPE_FIXED32 = 7,
    TYPE_BOOL = 8,
    TYPE_STRING = 9,
    TYPE_GROUP = 10,
    TYPE_MESSAGE = 11,
    TYPE_BYTES = 12,
    TYPE_UINT32 = 13,
    TYPE_ENUM = 14,
    TYPE_SFIXED32 = 15,
    TYPE_SFIXED64 = 16,
    TYPE_SINT32 = 17,
    TYPE_SINT64 = 18,
}

impl std::default::Default for FieldDescriptorProto_Type {
    fn default() -> Self {
        Self::TYPE_DOUBLE
    }
}

impl common::const_default::ConstDefault for FieldDescriptorProto_Type {
    const DEFAULT: Self = Self::TYPE_DOUBLE;
}

impl protobuf_core::Enum for FieldDescriptorProto_Type {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            1 => FieldDescriptorProto_Type::TYPE_DOUBLE,
            2 => FieldDescriptorProto_Type::TYPE_FLOAT,
            3 => FieldDescriptorProto_Type::TYPE_INT64,
            4 => FieldDescriptorProto_Type::TYPE_UINT64,
            5 => FieldDescriptorProto_Type::TYPE_INT32,
            6 => FieldDescriptorProto_Type::TYPE_FIXED64,
            7 => FieldDescriptorProto_Type::TYPE_FIXED32,
            8 => FieldDescriptorProto_Type::TYPE_BOOL,
            9 => FieldDescriptorProto_Type::TYPE_STRING,
            10 => FieldDescriptorProto_Type::TYPE_GROUP,
            11 => FieldDescriptorProto_Type::TYPE_MESSAGE,
            12 => FieldDescriptorProto_Type::TYPE_BYTES,
            13 => FieldDescriptorProto_Type::TYPE_UINT32,
            14 => FieldDescriptorProto_Type::TYPE_ENUM,
            15 => FieldDescriptorProto_Type::TYPE_SFIXED32,
            16 => FieldDescriptorProto_Type::TYPE_SFIXED64,
            17 => FieldDescriptorProto_Type::TYPE_SINT32,
            18 => FieldDescriptorProto_Type::TYPE_SINT64,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "TYPE_DOUBLE" => Self::TYPE_DOUBLE,
            "TYPE_FLOAT" => Self::TYPE_FLOAT,
            "TYPE_INT64" => Self::TYPE_INT64,
            "TYPE_UINT64" => Self::TYPE_UINT64,
            "TYPE_INT32" => Self::TYPE_INT32,
            "TYPE_FIXED64" => Self::TYPE_FIXED64,
            "TYPE_FIXED32" => Self::TYPE_FIXED32,
            "TYPE_BOOL" => Self::TYPE_BOOL,
            "TYPE_STRING" => Self::TYPE_STRING,
            "TYPE_GROUP" => Self::TYPE_GROUP,
            "TYPE_MESSAGE" => Self::TYPE_MESSAGE,
            "TYPE_BYTES" => Self::TYPE_BYTES,
            "TYPE_UINT32" => Self::TYPE_UINT32,
            "TYPE_ENUM" => Self::TYPE_ENUM,
            "TYPE_SFIXED32" => Self::TYPE_SFIXED32,
            "TYPE_SFIXED64" => Self::TYPE_SFIXED64,
            "TYPE_SINT32" => Self::TYPE_SINT32,
            "TYPE_SINT64" => Self::TYPE_SINT64,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::TYPE_DOUBLE => "TYPE_DOUBLE",
            Self::TYPE_FLOAT => "TYPE_FLOAT",
            Self::TYPE_INT64 => "TYPE_INT64",
            Self::TYPE_UINT64 => "TYPE_UINT64",
            Self::TYPE_INT32 => "TYPE_INT32",
            Self::TYPE_FIXED64 => "TYPE_FIXED64",
            Self::TYPE_FIXED32 => "TYPE_FIXED32",
            Self::TYPE_BOOL => "TYPE_BOOL",
            Self::TYPE_STRING => "TYPE_STRING",
            Self::TYPE_GROUP => "TYPE_GROUP",
            Self::TYPE_MESSAGE => "TYPE_MESSAGE",
            Self::TYPE_BYTES => "TYPE_BYTES",
            Self::TYPE_UINT32 => "TYPE_UINT32",
            Self::TYPE_ENUM => "TYPE_ENUM",
            Self::TYPE_SFIXED32 => "TYPE_SFIXED32",
            Self::TYPE_SFIXED64 => "TYPE_SFIXED64",
            Self::TYPE_SINT32 => "TYPE_SINT32",
            Self::TYPE_SINT64 => "TYPE_SINT64",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldDescriptorProto_Type {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum FieldDescriptorProto_Label {
    LABEL_OPTIONAL = 1,
    LABEL_REQUIRED = 2,
    LABEL_REPEATED = 3,
}

impl std::default::Default for FieldDescriptorProto_Label {
    fn default() -> Self {
        Self::LABEL_OPTIONAL
    }
}

impl common::const_default::ConstDefault for FieldDescriptorProto_Label {
    const DEFAULT: Self = Self::LABEL_OPTIONAL;
}

impl protobuf_core::Enum for FieldDescriptorProto_Label {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            1 => FieldDescriptorProto_Label::LABEL_OPTIONAL,
            2 => FieldDescriptorProto_Label::LABEL_REQUIRED,
            3 => FieldDescriptorProto_Label::LABEL_REPEATED,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "LABEL_OPTIONAL" => Self::LABEL_OPTIONAL,
            "LABEL_REQUIRED" => Self::LABEL_REQUIRED,
            "LABEL_REPEATED" => Self::LABEL_REPEATED,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::LABEL_OPTIONAL => "LABEL_OPTIONAL",
            Self::LABEL_REQUIRED => "LABEL_REQUIRED",
            Self::LABEL_REPEATED => "LABEL_REPEATED",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldDescriptorProto_Label {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct FieldDescriptorProto {
    name: Option<String>,
    number: Option<i32>,
    label: Option<FieldDescriptorProto_Label>,
    typ: Option<FieldDescriptorProto_Type>,
    type_name: Option<String>,
    extendee: Option<String>,
    default_value: Option<String>,
    oneof_index: Option<i32>,
    json_name: Option<String>,
    options: Option<MessagePtr<FieldOptions>>,
}

impl FieldDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: FieldDescriptorProto = FieldDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn number(&self) -> i32 {
        self.number.unwrap_or_default()
    }
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    pub fn set_number<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.number = Some(v);
    }
    pub fn number_mut(&mut self) -> &mut i32 {
        self.number.get_or_insert_with(|| i32::default())
    }
    pub fn clear_number(&mut self) {
        self.number = None;
    }

    pub fn label(&self) -> FieldDescriptorProto_Label {
        self.label.unwrap_or_default()
    }
    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }
    pub fn set_label<V: ::std::convert::Into<FieldDescriptorProto_Label>>(&mut self, v: V) {
        let v = v.into();
        self.label = Some(v);
    }
    pub fn label_mut(&mut self) -> &mut FieldDescriptorProto_Label {
        self.label
            .get_or_insert_with(|| FieldDescriptorProto_Label::default())
    }
    pub fn clear_label(&mut self) {
        self.label = None;
    }

    pub fn typ(&self) -> FieldDescriptorProto_Type {
        self.typ.unwrap_or_default()
    }
    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }
    pub fn set_typ<V: ::std::convert::Into<FieldDescriptorProto_Type>>(&mut self, v: V) {
        let v = v.into();
        self.typ = Some(v);
    }
    pub fn typ_mut(&mut self) -> &mut FieldDescriptorProto_Type {
        self.typ
            .get_or_insert_with(|| FieldDescriptorProto_Type::default())
    }
    pub fn clear_typ(&mut self) {
        self.typ = None;
    }

    pub fn type_name(&self) -> &str {
        self.type_name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }
    pub fn set_type_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.type_name = Some(v);
    }
    pub fn type_name_mut(&mut self) -> &mut String {
        self.type_name.get_or_insert_with(|| String::default())
    }
    pub fn clear_type_name(&mut self) {
        self.type_name = None;
    }

    pub fn extendee(&self) -> &str {
        self.extendee.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }
    pub fn set_extendee<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.extendee = Some(v);
    }
    pub fn extendee_mut(&mut self) -> &mut String {
        self.extendee.get_or_insert_with(|| String::default())
    }
    pub fn clear_extendee(&mut self) {
        self.extendee = None;
    }

    pub fn default_value(&self) -> &str {
        self.default_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }
    pub fn set_default_value<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.default_value = Some(v);
    }
    pub fn default_value_mut(&mut self) -> &mut String {
        self.default_value.get_or_insert_with(|| String::default())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value = None;
    }

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or_default()
    }
    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }
    pub fn set_oneof_index<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.oneof_index = Some(v);
    }
    pub fn oneof_index_mut(&mut self) -> &mut i32 {
        self.oneof_index.get_or_insert_with(|| i32::default())
    }
    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = None;
    }

    pub fn json_name(&self) -> &str {
        self.json_name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }
    pub fn set_json_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.json_name = Some(v);
    }
    pub fn json_name_mut(&mut self) -> &mut String {
        self.json_name.get_or_insert_with(|| String::default())
    }
    pub fn clear_json_name(&mut self) {
        self.json_name = None;
    }

    pub fn options(&self) -> &FieldOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(FieldOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<FieldOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut FieldOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(FieldOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::Message for FieldDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.FieldDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                3 => self.number = Some(f.parse_int32()?),
                4 => self.label = Some(f.parse_enum()?),
                5 => self.typ = Some(f.parse_enum()?),
                6 => self.type_name = Some(f.parse_string()?),
                2 => self.extendee = Some(f.parse_string()?),
                7 => self.default_value = Some(f.parse_string()?),
                9 => self.oneof_index = Some(f.parse_int32()?),
                10 => self.json_name = Some(f.parse_string()?),
                8 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.number.as_ref() {
            WireField::serialize_int32(3, *v, &mut data)?;
        }
        if let Some(v) = self.label.as_ref() {
            WireField::serialize_enum(4, v, &mut data)?;
        }
        if let Some(v) = self.typ.as_ref() {
            WireField::serialize_enum(5, v, &mut data)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            WireField::serialize_string(6, v, &mut data)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            WireField::serialize_string(2, v, &mut data)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            WireField::serialize_string(7, v, &mut data)?;
        }
        if let Some(v) = self.oneof_index.as_ref() {
            WireField::serialize_int32(9, *v, &mut data)?;
        }
        if let Some(v) = self.json_name.as_ref() {
            WireField::serialize_string(10, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(8, v.as_ref(), &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for FieldDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("number"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("label"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("type"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("type_name"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("extendee"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("default_value"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("oneof_index"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("json_name"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 8,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            3 => self.number.reflect(),
            4 => self.label.reflect(),
            5 => self.typ.reflect(),
            6 => self.type_name.reflect(),
            2 => self.extendee.reflect(),
            7 => self.default_value.reflect(),
            9 => self.oneof_index.reflect(),
            10 => self.json_name.reflect(),
            8 => self.options.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            3 => self.number.reflect_mut(),
            4 => self.label.reflect_mut(),
            5 => self.typ.reflect_mut(),
            6 => self.type_name.reflect_mut(),
            2 => self.extendee.reflect_mut(),
            7 => self.default_value.reflect_mut(),
            9 => self.oneof_index.reflect_mut(),
            10 => self.json_name.reflect_mut(),
            8 => self.options.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "number" => 3,
            "label" => 4,
            "type" => 5,
            "type_name" => 6,
            "extendee" => 2,
            "default_value" => 7,
            "oneof_index" => 9,
            "json_name" => 10,
            "options" => 8,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct OneofDescriptorProto {
    name: Option<String>,
    options: Option<MessagePtr<OneofOptions>>,
}

impl OneofDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: OneofDescriptorProto = OneofDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn options(&self) -> &OneofOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(OneofOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<OneofOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut OneofOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(OneofOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::Message for OneofDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.OneofDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(2, v.as_ref(), &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for OneofDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 2,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.options.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.options.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "options" => 2,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct EnumDescriptorProto_EnumReservedRange {
    start: Option<i32>,
    end: Option<i32>,
}

impl EnumDescriptorProto_EnumReservedRange {
    pub fn static_default_value() -> &'static Self {
        static VALUE: EnumDescriptorProto_EnumReservedRange =
            EnumDescriptorProto_EnumReservedRange::DEFAULT;
        &VALUE
    }

    pub fn start(&self) -> i32 {
        self.start.unwrap_or_default()
    }
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    pub fn set_start<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.start = Some(v);
    }
    pub fn start_mut(&mut self) -> &mut i32 {
        self.start.get_or_insert_with(|| i32::default())
    }
    pub fn clear_start(&mut self) {
        self.start = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| i32::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }
}

impl protobuf_core::Message for EnumDescriptorProto_EnumReservedRange {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto.EnumReservedRange"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.start = Some(f.parse_int32()?),
                2 => self.end = Some(f.parse_int32()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.start.as_ref() {
            WireField::serialize_int32(1, *v, &mut data)?;
        }
        if let Some(v) = self.end.as_ref() {
            WireField::serialize_int32(2, *v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for EnumDescriptorProto_EnumReservedRange {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("start"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 2,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.start.reflect(),
            2 => self.end.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.start.reflect_mut(),
            2 => self.end.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "start" => 1,
            "end" => 2,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct EnumDescriptorProto {
    name: Option<String>,
    value: Vec<EnumValueDescriptorProto>,
    options: Option<MessagePtr<EnumOptions>>,
    reserved_range: Vec<EnumDescriptorProto_EnumReservedRange>,
    reserved_name: Vec<String>,
}

impl EnumDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: EnumDescriptorProto = EnumDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn value(&self) -> &[EnumValueDescriptorProto] {
        &self.value
    }

    pub fn value_mut(&mut self) -> &mut [EnumValueDescriptorProto] {
        &mut self.value
    }

    pub fn value_len(&self) -> usize {
        self.value.len()
    }
    pub fn add_value(&mut self, v: EnumValueDescriptorProto) -> &mut EnumValueDescriptorProto {
        self.value.push(v);
        self.value.last_mut().unwrap()
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn options(&self) -> &EnumOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(EnumOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<EnumOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut EnumOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(EnumOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn reserved_range(&self) -> &[EnumDescriptorProto_EnumReservedRange] {
        &self.reserved_range
    }

    pub fn reserved_range_mut(&mut self) -> &mut [EnumDescriptorProto_EnumReservedRange] {
        &mut self.reserved_range
    }

    pub fn reserved_range_len(&self) -> usize {
        self.reserved_range.len()
    }
    pub fn add_reserved_range(
        &mut self,
        v: EnumDescriptorProto_EnumReservedRange,
    ) -> &mut EnumDescriptorProto_EnumReservedRange {
        self.reserved_range.push(v);
        self.reserved_range.last_mut().unwrap()
    }
    pub fn clear_reserved_range(&mut self) {
        self.reserved_range.clear();
    }

    pub fn reserved_name(&self) -> &[String] {
        &self.reserved_name
    }

    pub fn reserved_name_mut(&mut self) -> &mut [String] {
        &mut self.reserved_name
    }

    pub fn reserved_name_len(&self) -> usize {
        self.reserved_name.len()
    }
    pub fn add_reserved_name(&mut self, v: String) -> &mut String {
        self.reserved_name.push(v);
        self.reserved_name.last_mut().unwrap()
    }
    pub fn clear_reserved_name(&mut self) {
        self.reserved_name.clear();
    }
}

impl protobuf_core::Message for EnumDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.EnumDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => {
                    self.value.push(f.parse_message()?);
                }
                3 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                4 => {
                    self.reserved_range.push(f.parse_message()?);
                }
                5 => {
                    self.reserved_name.push(f.parse_string()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        for v in self.value.iter() {
            WireField::serialize_message(2, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(3, v.as_ref(), &mut data)?;
        }
        for v in self.reserved_range.iter() {
            WireField::serialize_message(4, v, &mut data)?;
        }
        for v in self.reserved_name.iter() {
            WireField::serialize_string(5, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for EnumDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("value"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_range"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("reserved_name"),
                number: 5,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.value.reflect(),
            3 => self.options.reflect(),
            4 => self.reserved_range.reflect(),
            5 => self.reserved_name.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.value.reflect_mut(),
            3 => self.options.reflect_mut(),
            4 => self.reserved_range.reflect_mut(),
            5 => self.reserved_name.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "value" => 2,
            "options" => 3,
            "reserved_range" => 4,
            "reserved_name" => 5,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct EnumValueDescriptorProto {
    name: Option<String>,
    number: Option<i32>,
    options: Option<MessagePtr<EnumValueOptions>>,
}

impl EnumValueDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: EnumValueDescriptorProto = EnumValueDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn number(&self) -> i32 {
        self.number.unwrap_or_default()
    }
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    pub fn set_number<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.number = Some(v);
    }
    pub fn number_mut(&mut self) -> &mut i32 {
        self.number.get_or_insert_with(|| i32::default())
    }
    pub fn clear_number(&mut self) {
        self.number = None;
    }

    pub fn options(&self) -> &EnumValueOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(EnumValueOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<EnumValueOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut EnumValueOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(EnumValueOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::Message for EnumValueDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.EnumValueDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => self.number = Some(f.parse_int32()?),
                3 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.number.as_ref() {
            WireField::serialize_int32(2, *v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(3, v.as_ref(), &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for EnumValueDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("number"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.number.reflect(),
            3 => self.options.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.number.reflect_mut(),
            3 => self.options.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "number" => 2,
            "options" => 3,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct ServiceDescriptorProto {
    name: Option<String>,
    method: Vec<MethodDescriptorProto>,
    options: Option<MessagePtr<ServiceOptions>>,
}

impl ServiceDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: ServiceDescriptorProto = ServiceDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn method(&self) -> &[MethodDescriptorProto] {
        &self.method
    }

    pub fn method_mut(&mut self) -> &mut [MethodDescriptorProto] {
        &mut self.method
    }

    pub fn method_len(&self) -> usize {
        self.method.len()
    }
    pub fn add_method(&mut self, v: MethodDescriptorProto) -> &mut MethodDescriptorProto {
        self.method.push(v);
        self.method.last_mut().unwrap()
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    pub fn options(&self) -> &ServiceOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(ServiceOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<ServiceOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut ServiceOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(ServiceOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }
}

impl protobuf_core::Message for ServiceDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.ServiceDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => {
                    self.method.push(f.parse_message()?);
                }
                3 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        for v in self.method.iter() {
            WireField::serialize_message(2, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(3, v.as_ref(), &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for ServiceDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("method"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 3,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.method.reflect(),
            3 => self.options.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.method.reflect_mut(),
            3 => self.options.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "method" => 2,
            "options" => 3,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct MethodDescriptorProto {
    name: Option<String>,
    input_type: Option<String>,
    output_type: Option<String>,
    options: Option<MessagePtr<MethodOptions>>,
    client_streaming: Option<bool>,
    server_streaming: Option<bool>,
}

impl MethodDescriptorProto {
    pub fn static_default_value() -> &'static Self {
        static VALUE: MethodDescriptorProto = MethodDescriptorProto::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    pub fn set_name<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name = Some(v);
    }
    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(|| String::default())
    }
    pub fn clear_name(&mut self) {
        self.name = None;
    }

    pub fn input_type(&self) -> &str {
        self.input_type.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }
    pub fn set_input_type<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.input_type = Some(v);
    }
    pub fn input_type_mut(&mut self) -> &mut String {
        self.input_type.get_or_insert_with(|| String::default())
    }
    pub fn clear_input_type(&mut self) {
        self.input_type = None;
    }

    pub fn output_type(&self) -> &str {
        self.output_type.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }
    pub fn set_output_type<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.output_type = Some(v);
    }
    pub fn output_type_mut(&mut self) -> &mut String {
        self.output_type.get_or_insert_with(|| String::default())
    }
    pub fn clear_output_type(&mut self) {
        self.output_type = None;
    }

    pub fn options(&self) -> &MethodOptions {
        self.options
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(MethodOptions::static_default_value())
    }
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    pub fn set_options<V: ::std::convert::Into<MethodOptions>>(&mut self, v: V) {
        let v = v.into();
        self.options = Some(MessagePtr::new(v));
    }
    pub fn options_mut(&mut self) -> &mut MethodOptions {
        self.options
            .get_or_insert_with(|| MessagePtr::new(MethodOptions::default()))
            .as_mut()
    }
    pub fn clear_options(&mut self) {
        self.options = None;
    }

    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(false)
    }
    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }
    pub fn set_client_streaming<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.client_streaming = Some(v);
    }
    pub fn client_streaming_mut(&mut self) -> &mut bool {
        self.client_streaming.get_or_insert_with(|| bool::default())
    }
    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = None;
    }

    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(false)
    }
    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }
    pub fn set_server_streaming<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.server_streaming = Some(v);
    }
    pub fn server_streaming_mut(&mut self) -> &mut bool {
        self.server_streaming.get_or_insert_with(|| bool::default())
    }
    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = None;
    }
}

impl protobuf_core::Message for MethodDescriptorProto {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.MethodDescriptorProto"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name = Some(f.parse_string()?),
                2 => self.input_type = Some(f.parse_string()?),
                3 => self.output_type = Some(f.parse_string()?),
                4 => self.options = Some(MessagePtr::new(f.parse_message()?)),
                5 => self.client_streaming = Some(f.parse_bool()?),
                6 => self.server_streaming = Some(f.parse_bool()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            WireField::serialize_string(2, v, &mut data)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            WireField::serialize_string(3, v, &mut data)?;
        }
        if let Some(v) = self.options.as_ref() {
            WireField::serialize_message(4, v.as_ref(), &mut data)?;
        }
        if let Some(v) = self.client_streaming.as_ref() {
            WireField::serialize_bool(5, *v, &mut data)?;
        }
        if let Some(v) = self.server_streaming.as_ref() {
            WireField::serialize_bool(6, *v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for MethodDescriptorProto {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("input_type"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("output_type"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("options"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("client_streaming"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("server_streaming"),
                number: 6,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name.reflect(),
            2 => self.input_type.reflect(),
            3 => self.output_type.reflect(),
            4 => self.options.reflect(),
            5 => self.client_streaming.reflect(),
            6 => self.server_streaming.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name.reflect_mut(),
            2 => self.input_type.reflect_mut(),
            3 => self.output_type.reflect_mut(),
            4 => self.options.reflect_mut(),
            5 => self.client_streaming.reflect_mut(),
            6 => self.server_streaming.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 1,
            "input_type" => 2,
            "output_type" => 3,
            "options" => 4,
            "client_streaming" => 5,
            "server_streaming" => 6,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum FileOptions_OptimizeMode {
    SPEED = 1,
    CODE_SIZE = 2,
    LITE_RUNTIME = 3,
}

impl std::default::Default for FileOptions_OptimizeMode {
    fn default() -> Self {
        Self::SPEED
    }
}

impl common::const_default::ConstDefault for FileOptions_OptimizeMode {
    const DEFAULT: Self = Self::SPEED;
}

impl protobuf_core::Enum for FileOptions_OptimizeMode {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            1 => FileOptions_OptimizeMode::SPEED,
            2 => FileOptions_OptimizeMode::CODE_SIZE,
            3 => FileOptions_OptimizeMode::LITE_RUNTIME,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "SPEED" => Self::SPEED,
            "CODE_SIZE" => Self::CODE_SIZE,
            "LITE_RUNTIME" => Self::LITE_RUNTIME,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::SPEED => "SPEED",
            Self::CODE_SIZE => "CODE_SIZE",
            Self::LITE_RUNTIME => "LITE_RUNTIME",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FileOptions_OptimizeMode {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct FileOptions {
    java_package: Option<String>,
    java_outer_classname: Option<String>,
    java_multiple_files: Option<bool>,
    java_generate_equals_and_hash: Option<bool>,
    java_string_check_utf8: Option<bool>,
    optimize_for: Option<FileOptions_OptimizeMode>,
    go_package: Option<String>,
    cc_generic_services: Option<bool>,
    java_generic_services: Option<bool>,
    py_generic_services: Option<bool>,
    php_generic_services: Option<bool>,
    deprecated: Option<bool>,
    cc_enable_arenas: Option<bool>,
    objc_class_prefix: Option<String>,
    csharp_namespace: Option<String>,
    swift_prefix: Option<String>,
    php_class_prefix: Option<String>,
    php_namespace: Option<String>,
    php_metadata_namespace: Option<String>,
    ruby_package: Option<String>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl FileOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: FileOptions = FileOptions::DEFAULT;
        &VALUE
    }

    pub fn java_package(&self) -> &str {
        self.java_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }
    pub fn set_java_package<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.java_package = Some(v);
    }
    pub fn java_package_mut(&mut self) -> &mut String {
        self.java_package.get_or_insert_with(|| String::default())
    }
    pub fn clear_java_package(&mut self) {
        self.java_package = None;
    }

    pub fn java_outer_classname(&self) -> &str {
        self.java_outer_classname
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }
    pub fn set_java_outer_classname<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.java_outer_classname = Some(v);
    }
    pub fn java_outer_classname_mut(&mut self) -> &mut String {
        self.java_outer_classname
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = None;
    }

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }
    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }
    pub fn set_java_multiple_files<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_multiple_files = Some(v);
    }
    pub fn java_multiple_files_mut(&mut self) -> &mut bool {
        self.java_multiple_files
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = None;
    }

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or_default()
    }
    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }
    pub fn set_java_generate_equals_and_hash<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_generate_equals_and_hash = Some(v);
    }
    pub fn java_generate_equals_and_hash_mut(&mut self) -> &mut bool {
        self.java_generate_equals_and_hash
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = None;
    }

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }
    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }
    pub fn set_java_string_check_utf8<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_string_check_utf8 = Some(v);
    }
    pub fn java_string_check_utf8_mut(&mut self) -> &mut bool {
        self.java_string_check_utf8
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = None;
    }

    pub fn optimize_for(&self) -> FileOptions_OptimizeMode {
        self.optimize_for.unwrap_or(FileOptions_OptimizeMode::SPEED)
    }
    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }
    pub fn set_optimize_for<V: ::std::convert::Into<FileOptions_OptimizeMode>>(&mut self, v: V) {
        let v = v.into();
        self.optimize_for = Some(v);
    }
    pub fn optimize_for_mut(&mut self) -> &mut FileOptions_OptimizeMode {
        self.optimize_for
            .get_or_insert_with(|| FileOptions_OptimizeMode::default())
    }
    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = None;
    }

    pub fn go_package(&self) -> &str {
        self.go_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }
    pub fn set_go_package<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.go_package = Some(v);
    }
    pub fn go_package_mut(&mut self) -> &mut String {
        self.go_package.get_or_insert_with(|| String::default())
    }
    pub fn clear_go_package(&mut self) {
        self.go_package = None;
    }

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }
    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }
    pub fn set_cc_generic_services<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.cc_generic_services = Some(v);
    }
    pub fn cc_generic_services_mut(&mut self) -> &mut bool {
        self.cc_generic_services
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = None;
    }

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }
    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }
    pub fn set_java_generic_services<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.java_generic_services = Some(v);
    }
    pub fn java_generic_services_mut(&mut self) -> &mut bool {
        self.java_generic_services
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = None;
    }

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }
    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }
    pub fn set_py_generic_services<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.py_generic_services = Some(v);
    }
    pub fn py_generic_services_mut(&mut self) -> &mut bool {
        self.py_generic_services
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = None;
    }

    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(false)
    }
    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }
    pub fn set_php_generic_services<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.php_generic_services = Some(v);
    }
    pub fn php_generic_services_mut(&mut self) -> &mut bool {
        self.php_generic_services
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(false)
    }
    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }
    pub fn set_cc_enable_arenas<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.cc_enable_arenas = Some(v);
    }
    pub fn cc_enable_arenas_mut(&mut self) -> &mut bool {
        self.cc_enable_arenas.get_or_insert_with(|| bool::default())
    }
    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = None;
    }

    pub fn objc_class_prefix(&self) -> &str {
        self.objc_class_prefix
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }
    pub fn set_objc_class_prefix<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.objc_class_prefix = Some(v);
    }
    pub fn objc_class_prefix_mut(&mut self) -> &mut String {
        self.objc_class_prefix
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = None;
    }

    pub fn csharp_namespace(&self) -> &str {
        self.csharp_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }
    pub fn set_csharp_namespace<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.csharp_namespace = Some(v);
    }
    pub fn csharp_namespace_mut(&mut self) -> &mut String {
        self.csharp_namespace
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = None;
    }

    pub fn swift_prefix(&self) -> &str {
        self.swift_prefix.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }
    pub fn set_swift_prefix<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.swift_prefix = Some(v);
    }
    pub fn swift_prefix_mut(&mut self) -> &mut String {
        self.swift_prefix.get_or_insert_with(|| String::default())
    }
    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = None;
    }

    pub fn php_class_prefix(&self) -> &str {
        self.php_class_prefix
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }
    pub fn set_php_class_prefix<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_class_prefix = Some(v);
    }
    pub fn php_class_prefix_mut(&mut self) -> &mut String {
        self.php_class_prefix
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = None;
    }

    pub fn php_namespace(&self) -> &str {
        self.php_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }
    pub fn set_php_namespace<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_namespace = Some(v);
    }
    pub fn php_namespace_mut(&mut self) -> &mut String {
        self.php_namespace.get_or_insert_with(|| String::default())
    }
    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = None;
    }

    pub fn php_metadata_namespace(&self) -> &str {
        self.php_metadata_namespace
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }
    pub fn set_php_metadata_namespace<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.php_metadata_namespace = Some(v);
    }
    pub fn php_metadata_namespace_mut(&mut self) -> &mut String {
        self.php_metadata_namespace
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = None;
    }

    pub fn ruby_package(&self) -> &str {
        self.ruby_package.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }
    pub fn set_ruby_package<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.ruby_package = Some(v);
    }
    pub fn ruby_package_mut(&mut self) -> &mut String {
        self.ruby_package.get_or_insert_with(|| String::default())
    }
    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for FileOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.FileOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.java_package = Some(f.parse_string()?),
                8 => self.java_outer_classname = Some(f.parse_string()?),
                10 => self.java_multiple_files = Some(f.parse_bool()?),
                20 => self.java_generate_equals_and_hash = Some(f.parse_bool()?),
                27 => self.java_string_check_utf8 = Some(f.parse_bool()?),
                9 => self.optimize_for = Some(f.parse_enum()?),
                11 => self.go_package = Some(f.parse_string()?),
                16 => self.cc_generic_services = Some(f.parse_bool()?),
                17 => self.java_generic_services = Some(f.parse_bool()?),
                18 => self.py_generic_services = Some(f.parse_bool()?),
                42 => self.php_generic_services = Some(f.parse_bool()?),
                23 => self.deprecated = Some(f.parse_bool()?),
                31 => self.cc_enable_arenas = Some(f.parse_bool()?),
                36 => self.objc_class_prefix = Some(f.parse_string()?),
                37 => self.csharp_namespace = Some(f.parse_string()?),
                39 => self.swift_prefix = Some(f.parse_string()?),
                40 => self.php_class_prefix = Some(f.parse_string()?),
                41 => self.php_namespace = Some(f.parse_string()?),
                44 => self.php_metadata_namespace = Some(f.parse_string()?),
                45 => self.ruby_package = Some(f.parse_string()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.java_package.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            WireField::serialize_string(8, v, &mut data)?;
        }
        if let Some(v) = self.java_multiple_files.as_ref() {
            WireField::serialize_bool(10, *v, &mut data)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash.as_ref() {
            WireField::serialize_bool(20, *v, &mut data)?;
        }
        if let Some(v) = self.java_string_check_utf8.as_ref() {
            WireField::serialize_bool(27, *v, &mut data)?;
        }
        if let Some(v) = self.optimize_for.as_ref() {
            WireField::serialize_enum(9, v, &mut data)?;
        }
        if let Some(v) = self.go_package.as_ref() {
            WireField::serialize_string(11, v, &mut data)?;
        }
        if let Some(v) = self.cc_generic_services.as_ref() {
            WireField::serialize_bool(16, *v, &mut data)?;
        }
        if let Some(v) = self.java_generic_services.as_ref() {
            WireField::serialize_bool(17, *v, &mut data)?;
        }
        if let Some(v) = self.py_generic_services.as_ref() {
            WireField::serialize_bool(18, *v, &mut data)?;
        }
        if let Some(v) = self.php_generic_services.as_ref() {
            WireField::serialize_bool(42, *v, &mut data)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(23, *v, &mut data)?;
        }
        if let Some(v) = self.cc_enable_arenas.as_ref() {
            WireField::serialize_bool(31, *v, &mut data)?;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            WireField::serialize_string(36, v, &mut data)?;
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            WireField::serialize_string(37, v, &mut data)?;
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            WireField::serialize_string(39, v, &mut data)?;
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            WireField::serialize_string(40, v, &mut data)?;
        }
        if let Some(v) = self.php_namespace.as_ref() {
            WireField::serialize_string(41, v, &mut data)?;
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            WireField::serialize_string(44, v, &mut data)?;
        }
        if let Some(v) = self.ruby_package.as_ref() {
            WireField::serialize_string(45, v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for FileOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_package"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_outer_classname"),
                number: 8,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_multiple_files"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_generate_equals_and_hash"),
                number: 20,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_string_check_utf8"),
                number: 27,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("optimize_for"),
                number: 9,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("go_package"),
                number: 11,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("cc_generic_services"),
                number: 16,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("java_generic_services"),
                number: 17,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("py_generic_services"),
                number: 18,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_generic_services"),
                number: 42,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 23,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("cc_enable_arenas"),
                number: 31,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("objc_class_prefix"),
                number: 36,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("csharp_namespace"),
                number: 37,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("swift_prefix"),
                number: 39,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_class_prefix"),
                number: 40,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_namespace"),
                number: 41,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("php_metadata_namespace"),
                number: 44,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("ruby_package"),
                number: 45,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.java_package.reflect(),
            8 => self.java_outer_classname.reflect(),
            10 => self.java_multiple_files.reflect(),
            20 => self.java_generate_equals_and_hash.reflect(),
            27 => self.java_string_check_utf8.reflect(),
            9 => self.optimize_for.reflect(),
            11 => self.go_package.reflect(),
            16 => self.cc_generic_services.reflect(),
            17 => self.java_generic_services.reflect(),
            18 => self.py_generic_services.reflect(),
            42 => self.php_generic_services.reflect(),
            23 => self.deprecated.reflect(),
            31 => self.cc_enable_arenas.reflect(),
            36 => self.objc_class_prefix.reflect(),
            37 => self.csharp_namespace.reflect(),
            39 => self.swift_prefix.reflect(),
            40 => self.php_class_prefix.reflect(),
            41 => self.php_namespace.reflect(),
            44 => self.php_metadata_namespace.reflect(),
            45 => self.ruby_package.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.java_package.reflect_mut(),
            8 => self.java_outer_classname.reflect_mut(),
            10 => self.java_multiple_files.reflect_mut(),
            20 => self.java_generate_equals_and_hash.reflect_mut(),
            27 => self.java_string_check_utf8.reflect_mut(),
            9 => self.optimize_for.reflect_mut(),
            11 => self.go_package.reflect_mut(),
            16 => self.cc_generic_services.reflect_mut(),
            17 => self.java_generic_services.reflect_mut(),
            18 => self.py_generic_services.reflect_mut(),
            42 => self.php_generic_services.reflect_mut(),
            23 => self.deprecated.reflect_mut(),
            31 => self.cc_enable_arenas.reflect_mut(),
            36 => self.objc_class_prefix.reflect_mut(),
            37 => self.csharp_namespace.reflect_mut(),
            39 => self.swift_prefix.reflect_mut(),
            40 => self.php_class_prefix.reflect_mut(),
            41 => self.php_namespace.reflect_mut(),
            44 => self.php_metadata_namespace.reflect_mut(),
            45 => self.ruby_package.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "java_package" => 1,
            "java_outer_classname" => 8,
            "java_multiple_files" => 10,
            "java_generate_equals_and_hash" => 20,
            "java_string_check_utf8" => 27,
            "optimize_for" => 9,
            "go_package" => 11,
            "cc_generic_services" => 16,
            "java_generic_services" => 17,
            "py_generic_services" => 18,
            "php_generic_services" => 42,
            "deprecated" => 23,
            "cc_enable_arenas" => 31,
            "objc_class_prefix" => 36,
            "csharp_namespace" => 37,
            "swift_prefix" => 39,
            "php_class_prefix" => 40,
            "php_namespace" => 41,
            "php_metadata_namespace" => 44,
            "ruby_package" => 45,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct MessageOptions {
    message_set_wire_format: Option<bool>,
    no_standard_descriptor_accessor: Option<bool>,
    deprecated: Option<bool>,
    map_entry: Option<bool>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl MessageOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: MessageOptions = MessageOptions::DEFAULT;
        &VALUE
    }

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }
    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }
    pub fn set_message_set_wire_format<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.message_set_wire_format = Some(v);
    }
    pub fn message_set_wire_format_mut(&mut self) -> &mut bool {
        self.message_set_wire_format
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = None;
    }

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }
    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }
    pub fn set_no_standard_descriptor_accessor<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.no_standard_descriptor_accessor = Some(v);
    }
    pub fn no_standard_descriptor_accessor_mut(&mut self) -> &mut bool {
        self.no_standard_descriptor_accessor
            .get_or_insert_with(|| bool::default())
    }
    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or_default()
    }
    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }
    pub fn set_map_entry<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.map_entry = Some(v);
    }
    pub fn map_entry_mut(&mut self) -> &mut bool {
        self.map_entry.get_or_insert_with(|| bool::default())
    }
    pub fn clear_map_entry(&mut self) {
        self.map_entry = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for MessageOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.MessageOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.message_set_wire_format = Some(f.parse_bool()?),
                2 => self.no_standard_descriptor_accessor = Some(f.parse_bool()?),
                3 => self.deprecated = Some(f.parse_bool()?),
                7 => self.map_entry = Some(f.parse_bool()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.message_set_wire_format.as_ref() {
            WireField::serialize_bool(1, *v, &mut data)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor.as_ref() {
            WireField::serialize_bool(2, *v, &mut data)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(3, *v, &mut data)?;
        }
        if let Some(v) = self.map_entry.as_ref() {
            WireField::serialize_bool(7, *v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for MessageOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("message_set_wire_format"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("no_standard_descriptor_accessor"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("map_entry"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.message_set_wire_format.reflect(),
            2 => self.no_standard_descriptor_accessor.reflect(),
            3 => self.deprecated.reflect(),
            7 => self.map_entry.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.message_set_wire_format.reflect_mut(),
            2 => self.no_standard_descriptor_accessor.reflect_mut(),
            3 => self.deprecated.reflect_mut(),
            7 => self.map_entry.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "message_set_wire_format" => 1,
            "no_standard_descriptor_accessor" => 2,
            "deprecated" => 3,
            "map_entry" => 7,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum FieldOptions_CType {
    STRING = 0,
    CORD = 1,
    STRING_PIECE = 2,
}

impl std::default::Default for FieldOptions_CType {
    fn default() -> Self {
        Self::STRING
    }
}

impl common::const_default::ConstDefault for FieldOptions_CType {
    const DEFAULT: Self = Self::STRING;
}

impl protobuf_core::Enum for FieldOptions_CType {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            0 => FieldOptions_CType::STRING,
            1 => FieldOptions_CType::CORD,
            2 => FieldOptions_CType::STRING_PIECE,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "STRING" => Self::STRING,
            "CORD" => Self::CORD,
            "STRING_PIECE" => Self::STRING_PIECE,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::STRING => "STRING",
            Self::CORD => "CORD",
            Self::STRING_PIECE => "STRING_PIECE",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_CType {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum FieldOptions_JSType {
    JS_NORMAL = 0,
    JS_STRING = 1,
    JS_NUMBER = 2,
}

impl std::default::Default for FieldOptions_JSType {
    fn default() -> Self {
        Self::JS_NORMAL
    }
}

impl common::const_default::ConstDefault for FieldOptions_JSType {
    const DEFAULT: Self = Self::JS_NORMAL;
}

impl protobuf_core::Enum for FieldOptions_JSType {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            0 => FieldOptions_JSType::JS_NORMAL,
            1 => FieldOptions_JSType::JS_STRING,
            2 => FieldOptions_JSType::JS_NUMBER,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "JS_NORMAL" => Self::JS_NORMAL,
            "JS_STRING" => Self::JS_STRING,
            "JS_NUMBER" => Self::JS_NUMBER,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::JS_NORMAL => "JS_NORMAL",
            Self::JS_STRING => "JS_STRING",
            Self::JS_NUMBER => "JS_NUMBER",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for FieldOptions_JSType {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct FieldOptions {
    ctype: Option<FieldOptions_CType>,
    packed: Option<bool>,
    jstype: Option<FieldOptions_JSType>,
    lazy: Option<bool>,
    deprecated: Option<bool>,
    weak: Option<bool>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl FieldOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: FieldOptions = FieldOptions::DEFAULT;
        &VALUE
    }

    pub fn ctype(&self) -> FieldOptions_CType {
        self.ctype.unwrap_or(FieldOptions_CType::STRING)
    }
    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }
    pub fn set_ctype<V: ::std::convert::Into<FieldOptions_CType>>(&mut self, v: V) {
        let v = v.into();
        self.ctype = Some(v);
    }
    pub fn ctype_mut(&mut self) -> &mut FieldOptions_CType {
        self.ctype
            .get_or_insert_with(|| FieldOptions_CType::default())
    }
    pub fn clear_ctype(&mut self) {
        self.ctype = None;
    }

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or_default()
    }
    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }
    pub fn set_packed<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.packed = Some(v);
    }
    pub fn packed_mut(&mut self) -> &mut bool {
        self.packed.get_or_insert_with(|| bool::default())
    }
    pub fn clear_packed(&mut self) {
        self.packed = None;
    }

    pub fn jstype(&self) -> FieldOptions_JSType {
        self.jstype.unwrap_or(FieldOptions_JSType::JS_NORMAL)
    }
    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }
    pub fn set_jstype<V: ::std::convert::Into<FieldOptions_JSType>>(&mut self, v: V) {
        let v = v.into();
        self.jstype = Some(v);
    }
    pub fn jstype_mut(&mut self) -> &mut FieldOptions_JSType {
        self.jstype
            .get_or_insert_with(|| FieldOptions_JSType::default())
    }
    pub fn clear_jstype(&mut self) {
        self.jstype = None;
    }

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }
    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }
    pub fn set_lazy<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.lazy = Some(v);
    }
    pub fn lazy_mut(&mut self) -> &mut bool {
        self.lazy.get_or_insert_with(|| bool::default())
    }
    pub fn clear_lazy(&mut self) {
        self.lazy = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }
    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }
    pub fn set_weak<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.weak = Some(v);
    }
    pub fn weak_mut(&mut self) -> &mut bool {
        self.weak.get_or_insert_with(|| bool::default())
    }
    pub fn clear_weak(&mut self) {
        self.weak = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for FieldOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.FieldOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.ctype = Some(f.parse_enum()?),
                2 => self.packed = Some(f.parse_bool()?),
                6 => self.jstype = Some(f.parse_enum()?),
                5 => self.lazy = Some(f.parse_bool()?),
                3 => self.deprecated = Some(f.parse_bool()?),
                10 => self.weak = Some(f.parse_bool()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.ctype.as_ref() {
            WireField::serialize_enum(1, v, &mut data)?;
        }
        if let Some(v) = self.packed.as_ref() {
            WireField::serialize_bool(2, *v, &mut data)?;
        }
        if let Some(v) = self.jstype.as_ref() {
            WireField::serialize_enum(6, v, &mut data)?;
        }
        if let Some(v) = self.lazy.as_ref() {
            WireField::serialize_bool(5, *v, &mut data)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(3, *v, &mut data)?;
        }
        if let Some(v) = self.weak.as_ref() {
            WireField::serialize_bool(10, *v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for FieldOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("ctype"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("packed"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("jstype"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("lazy"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("weak"),
                number: 10,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.ctype.reflect(),
            2 => self.packed.reflect(),
            6 => self.jstype.reflect(),
            5 => self.lazy.reflect(),
            3 => self.deprecated.reflect(),
            10 => self.weak.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.ctype.reflect_mut(),
            2 => self.packed.reflect_mut(),
            6 => self.jstype.reflect_mut(),
            5 => self.lazy.reflect_mut(),
            3 => self.deprecated.reflect_mut(),
            10 => self.weak.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "ctype" => 1,
            "packed" => 2,
            "jstype" => 6,
            "lazy" => 5,
            "deprecated" => 3,
            "weak" => 10,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct OneofOptions {
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl OneofOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: OneofOptions = OneofOptions::DEFAULT;
        &VALUE
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for OneofOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.OneofOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for OneofOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("uninterpreted_option"),
            number: 999,
        }]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct EnumOptions {
    allow_alias: Option<bool>,
    deprecated: Option<bool>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl EnumOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: EnumOptions = EnumOptions::DEFAULT;
        &VALUE
    }

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or_default()
    }
    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }
    pub fn set_allow_alias<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.allow_alias = Some(v);
    }
    pub fn allow_alias_mut(&mut self) -> &mut bool {
        self.allow_alias.get_or_insert_with(|| bool::default())
    }
    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = None;
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for EnumOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.EnumOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                2 => self.allow_alias = Some(f.parse_bool()?),
                3 => self.deprecated = Some(f.parse_bool()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.allow_alias.as_ref() {
            WireField::serialize_bool(2, *v, &mut data)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(3, *v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for EnumOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("allow_alias"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            2 => self.allow_alias.reflect(),
            3 => self.deprecated.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            2 => self.allow_alias.reflect_mut(),
            3 => self.deprecated.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "allow_alias" => 2,
            "deprecated" => 3,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct EnumValueOptions {
    deprecated: Option<bool>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl EnumValueOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: EnumValueOptions = EnumValueOptions::DEFAULT;
        &VALUE
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for EnumValueOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.EnumValueOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.deprecated = Some(f.parse_bool()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(1, *v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for EnumValueOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.deprecated.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.deprecated.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "deprecated" => 1,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct ServiceOptions {
    deprecated: Option<bool>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl ServiceOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: ServiceOptions = ServiceOptions::DEFAULT;
        &VALUE
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for ServiceOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.ServiceOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                33 => self.deprecated = Some(f.parse_bool()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(33, *v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for ServiceOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 33,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            33 => self.deprecated.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            33 => self.deprecated.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "deprecated" => 33,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum MethodOptions_IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0,
    NO_SIDE_EFFECTS = 1,
    IDEMPOTENT = 2,
}

impl std::default::Default for MethodOptions_IdempotencyLevel {
    fn default() -> Self {
        Self::IDEMPOTENCY_UNKNOWN
    }
}

impl common::const_default::ConstDefault for MethodOptions_IdempotencyLevel {
    const DEFAULT: Self = Self::IDEMPOTENCY_UNKNOWN;
}

impl protobuf_core::Enum for MethodOptions_IdempotencyLevel {
    fn parse(v: protobuf_core::EnumValue) -> Result<Self> {
        Ok(match v {
            0 => MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
            1 => MethodOptions_IdempotencyLevel::NO_SIDE_EFFECTS,
            2 => MethodOptions_IdempotencyLevel::IDEMPOTENT,
            _ => {
                return Err(err_msg("Unknown enum value"));
            }
        })
    }

    fn parse_name(s: &str) -> Result<Self> {
        Ok(match s {
            "IDEMPOTENCY_UNKNOWN" => Self::IDEMPOTENCY_UNKNOWN,
            "NO_SIDE_EFFECTS" => Self::NO_SIDE_EFFECTS,
            "IDEMPOTENT" => Self::IDEMPOTENT,
            _ => {
                return Err(format_err!("Unknown enum name: {}", s));
            }
        })
    }
    fn name(&self) -> &'static str {
        match self {
            Self::IDEMPOTENCY_UNKNOWN => "IDEMPOTENCY_UNKNOWN",
            Self::NO_SIDE_EFFECTS => "NO_SIDE_EFFECTS",
            Self::IDEMPOTENT => "IDEMPOTENT",
        }
    }

    fn value(&self) -> protobuf_core::EnumValue {
        *self as protobuf_core::EnumValue
    }

    fn assign(&mut self, v: protobuf_core::EnumValue) -> Result<()> {
        *self = Self::parse(v)?;
        Ok(())
    }

    fn assign_name(&mut self, s: &str) -> Result<()> {
        *self = Self::parse_name(s)?;
        Ok(())
    }
}

impl protobuf_core::reflection::Reflect for MethodOptions_IdempotencyLevel {
    fn reflect(&self) -> Option<protobuf_core::reflection::Reflection> {
        Some(protobuf_core::reflection::Reflection::Enum(self))
    }
    fn reflect_mut(&mut self) -> protobuf_core::reflection::ReflectionMut {
        protobuf_core::reflection::ReflectionMut::Enum(self)
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct MethodOptions {
    deprecated: Option<bool>,
    idempotency_level: Option<MethodOptions_IdempotencyLevel>,
    uninterpreted_option: Vec<UninterpretedOption>,
}

impl MethodOptions {
    pub fn static_default_value() -> &'static Self {
        static VALUE: MethodOptions = MethodOptions::DEFAULT;
        &VALUE
    }

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    pub fn set_deprecated<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.deprecated = Some(v);
    }
    pub fn deprecated_mut(&mut self) -> &mut bool {
        self.deprecated.get_or_insert_with(|| bool::default())
    }
    pub fn clear_deprecated(&mut self) {
        self.deprecated = None;
    }

    pub fn idempotency_level(&self) -> MethodOptions_IdempotencyLevel {
        self.idempotency_level
            .unwrap_or(MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN)
    }
    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }
    pub fn set_idempotency_level<V: ::std::convert::Into<MethodOptions_IdempotencyLevel>>(
        &mut self,
        v: V,
    ) {
        let v = v.into();
        self.idempotency_level = Some(v);
    }
    pub fn idempotency_level_mut(&mut self) -> &mut MethodOptions_IdempotencyLevel {
        self.idempotency_level
            .get_or_insert_with(|| MethodOptions_IdempotencyLevel::default())
    }
    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = None;
    }

    pub fn uninterpreted_option(&self) -> &[UninterpretedOption] {
        &self.uninterpreted_option
    }

    pub fn uninterpreted_option_mut(&mut self) -> &mut [UninterpretedOption] {
        &mut self.uninterpreted_option
    }

    pub fn uninterpreted_option_len(&self) -> usize {
        self.uninterpreted_option.len()
    }
    pub fn add_uninterpreted_option(&mut self, v: UninterpretedOption) -> &mut UninterpretedOption {
        self.uninterpreted_option.push(v);
        self.uninterpreted_option.last_mut().unwrap()
    }
    pub fn clear_uninterpreted_option(&mut self) {
        self.uninterpreted_option.clear();
    }
}

impl protobuf_core::Message for MethodOptions {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.MethodOptions"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                33 => self.deprecated = Some(f.parse_bool()?),
                34 => self.idempotency_level = Some(f.parse_enum()?),
                999 => {
                    self.uninterpreted_option.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.deprecated.as_ref() {
            WireField::serialize_bool(33, *v, &mut data)?;
        }
        if let Some(v) = self.idempotency_level.as_ref() {
            WireField::serialize_enum(34, v, &mut data)?;
        }
        for v in self.uninterpreted_option.iter() {
            WireField::serialize_message(999, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for MethodOptions {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("deprecated"),
                number: 33,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("idempotency_level"),
                number: 34,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("uninterpreted_option"),
                number: 999,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            33 => self.deprecated.reflect(),
            34 => self.idempotency_level.reflect(),
            999 => self.uninterpreted_option.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            33 => self.deprecated.reflect_mut(),
            34 => self.idempotency_level.reflect_mut(),
            999 => self.uninterpreted_option.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "deprecated" => 33,
            "idempotency_level" => 34,
            "uninterpreted_option" => 999,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct UninterpretedOption_NamePart {
    name_part: Option<String>,
    is_extension: Option<bool>,
}

impl UninterpretedOption_NamePart {
    pub fn static_default_value() -> &'static Self {
        static VALUE: UninterpretedOption_NamePart = UninterpretedOption_NamePart::DEFAULT;
        &VALUE
    }

    pub fn name_part(&self) -> &str {
        self.name_part.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_name_part(&self) -> bool {
        self.name_part.is_some()
    }
    pub fn set_name_part<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.name_part = Some(v);
    }
    pub fn name_part_mut(&mut self) -> &mut String {
        self.name_part.get_or_insert_with(|| String::default())
    }
    pub fn clear_name_part(&mut self) {
        self.name_part = None;
    }

    pub fn is_extension(&self) -> bool {
        self.is_extension.unwrap_or_default()
    }
    pub fn has_is_extension(&self) -> bool {
        self.is_extension.is_some()
    }
    pub fn set_is_extension<V: ::std::convert::Into<bool>>(&mut self, v: V) {
        let v = v.into();
        self.is_extension = Some(v);
    }
    pub fn is_extension_mut(&mut self) -> &mut bool {
        self.is_extension.get_or_insert_with(|| bool::default())
    }
    pub fn clear_is_extension(&mut self) {
        self.is_extension = None;
    }
}

impl protobuf_core::Message for UninterpretedOption_NamePart {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.UninterpretedOption.NamePart"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => self.name_part = Some(f.parse_string()?),
                2 => self.is_extension = Some(f.parse_bool()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        if let Some(v) = self.name_part.as_ref() {
            WireField::serialize_string(1, v, &mut data)?;
        } else {
            return Err(err_msg("Required field 'name_part' not set"));
        }
        if let Some(v) = self.is_extension.as_ref() {
            WireField::serialize_bool(2, *v, &mut data)?;
        } else {
            return Err(err_msg("Required field 'is_extension' not set"));
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for UninterpretedOption_NamePart {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name_part"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("is_extension"),
                number: 2,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.name_part.reflect(),
            2 => self.is_extension.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.name_part.reflect_mut(),
            2 => self.is_extension.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name_part" => 1,
            "is_extension" => 2,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct UninterpretedOption {
    name: Vec<UninterpretedOption_NamePart>,
    identifier_value: Option<String>,
    positive_int_value: Option<u64>,
    negative_int_value: Option<i64>,
    double_value: Option<f64>,
    string_value: Option<BytesField>,
    aggregate_value: Option<String>,
}

impl UninterpretedOption {
    pub fn static_default_value() -> &'static Self {
        static VALUE: UninterpretedOption = UninterpretedOption::DEFAULT;
        &VALUE
    }

    pub fn name(&self) -> &[UninterpretedOption_NamePart] {
        &self.name
    }

    pub fn name_mut(&mut self) -> &mut [UninterpretedOption_NamePart] {
        &mut self.name
    }

    pub fn name_len(&self) -> usize {
        self.name.len()
    }
    pub fn add_name(
        &mut self,
        v: UninterpretedOption_NamePart,
    ) -> &mut UninterpretedOption_NamePart {
        self.name.push(v);
        self.name.last_mut().unwrap()
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn identifier_value(&self) -> &str {
        self.identifier_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }
    pub fn set_identifier_value<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.identifier_value = Some(v);
    }
    pub fn identifier_value_mut(&mut self) -> &mut String {
        self.identifier_value
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = None;
    }

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or_default()
    }
    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }
    pub fn set_positive_int_value<V: ::std::convert::Into<u64>>(&mut self, v: V) {
        let v = v.into();
        self.positive_int_value = Some(v);
    }
    pub fn positive_int_value_mut(&mut self) -> &mut u64 {
        self.positive_int_value
            .get_or_insert_with(|| u64::default())
    }
    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = None;
    }

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or_default()
    }
    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }
    pub fn set_negative_int_value<V: ::std::convert::Into<i64>>(&mut self, v: V) {
        let v = v.into();
        self.negative_int_value = Some(v);
    }
    pub fn negative_int_value_mut(&mut self) -> &mut i64 {
        self.negative_int_value
            .get_or_insert_with(|| i64::default())
    }
    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = None;
    }

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or_default()
    }
    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }
    pub fn set_double_value<V: ::std::convert::Into<f64>>(&mut self, v: V) {
        let v = v.into();
        self.double_value = Some(v);
    }
    pub fn double_value_mut(&mut self) -> &mut f64 {
        self.double_value.get_or_insert_with(|| f64::default())
    }
    pub fn clear_double_value(&mut self) {
        self.double_value = None;
    }

    pub fn string_value(&self) -> &[u8] {
        self.string_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or(&[])
    }
    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }
    pub fn set_string_value<V: ::std::convert::Into<BytesField>>(&mut self, v: V) {
        let v = v.into();
        self.string_value = Some(v);
    }
    pub fn string_value_mut(&mut self) -> &mut BytesField {
        self.string_value
            .get_or_insert_with(|| BytesField::default())
    }
    pub fn clear_string_value(&mut self) {
        self.string_value = None;
    }

    pub fn aggregate_value(&self) -> &str {
        self.aggregate_value
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }
    pub fn set_aggregate_value<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.aggregate_value = Some(v);
    }
    pub fn aggregate_value_mut(&mut self) -> &mut String {
        self.aggregate_value
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = None;
    }
}

impl protobuf_core::Message for UninterpretedOption {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.UninterpretedOption"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                2 => {
                    self.name.push(f.parse_message()?);
                }
                3 => self.identifier_value = Some(f.parse_string()?),
                4 => self.positive_int_value = Some(f.parse_uint64()?),
                5 => self.negative_int_value = Some(f.parse_int64()?),
                6 => self.double_value = Some(f.parse_double()?),
                7 => self.string_value = Some(f.parse_bytes()?),
                8 => self.aggregate_value = Some(f.parse_string()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.name.iter() {
            WireField::serialize_message(2, v, &mut data)?;
        }
        if let Some(v) = self.identifier_value.as_ref() {
            WireField::serialize_string(3, v, &mut data)?;
        }
        if let Some(v) = self.positive_int_value.as_ref() {
            WireField::serialize_uint64(4, *v, &mut data)?;
        }
        if let Some(v) = self.negative_int_value.as_ref() {
            WireField::serialize_int64(5, *v, &mut data)?;
        }
        if let Some(v) = self.double_value.as_ref() {
            WireField::serialize_double(6, *v, &mut data)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            WireField::serialize_bytes(7, v, &mut data)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            WireField::serialize_string(8, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for UninterpretedOption {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("name"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("identifier_value"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("positive_int_value"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("negative_int_value"),
                number: 5,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("double_value"),
                number: 6,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("string_value"),
                number: 7,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("aggregate_value"),
                number: 8,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            2 => self.name.reflect(),
            3 => self.identifier_value.reflect(),
            4 => self.positive_int_value.reflect(),
            5 => self.negative_int_value.reflect(),
            6 => self.double_value.reflect(),
            7 => self.string_value.reflect(),
            8 => self.aggregate_value.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            2 => self.name.reflect_mut(),
            3 => self.identifier_value.reflect_mut(),
            4 => self.positive_int_value.reflect_mut(),
            5 => self.negative_int_value.reflect_mut(),
            6 => self.double_value.reflect_mut(),
            7 => self.string_value.reflect_mut(),
            8 => self.aggregate_value.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "name" => 2,
            "identifier_value" => 3,
            "positive_int_value" => 4,
            "negative_int_value" => 5,
            "double_value" => 6,
            "string_value" => 7,
            "aggregate_value" => 8,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct SourceCodeInfo_Location {
    path: Vec<i32>,
    span: Vec<i32>,
    leading_comments: Option<String>,
    trailing_comments: Option<String>,
    leading_detached_comments: Vec<String>,
}

impl SourceCodeInfo_Location {
    pub fn static_default_value() -> &'static Self {
        static VALUE: SourceCodeInfo_Location = SourceCodeInfo_Location::DEFAULT;
        &VALUE
    }

    pub fn path(&self) -> &[i32] {
        &self.path
    }

    pub fn path_mut(&mut self) -> &mut [i32] {
        &mut self.path
    }

    pub fn path_len(&self) -> usize {
        self.path.len()
    }
    pub fn add_path(&mut self, v: i32) -> &mut i32 {
        self.path.push(v);
        self.path.last_mut().unwrap()
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn span(&self) -> &[i32] {
        &self.span
    }

    pub fn span_mut(&mut self) -> &mut [i32] {
        &mut self.span
    }

    pub fn span_len(&self) -> usize {
        self.span.len()
    }
    pub fn add_span(&mut self, v: i32) -> &mut i32 {
        self.span.push(v);
        self.span.last_mut().unwrap()
    }
    pub fn clear_span(&mut self) {
        self.span.clear();
    }

    pub fn leading_comments(&self) -> &str {
        self.leading_comments
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_leading_comments(&self) -> bool {
        self.leading_comments.is_some()
    }
    pub fn set_leading_comments<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.leading_comments = Some(v);
    }
    pub fn leading_comments_mut(&mut self) -> &mut String {
        self.leading_comments
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_leading_comments(&mut self) {
        self.leading_comments = None;
    }

    pub fn trailing_comments(&self) -> &str {
        self.trailing_comments
            .as_ref()
            .map(|v| v.as_ref())
            .unwrap_or("")
    }
    pub fn has_trailing_comments(&self) -> bool {
        self.trailing_comments.is_some()
    }
    pub fn set_trailing_comments<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.trailing_comments = Some(v);
    }
    pub fn trailing_comments_mut(&mut self) -> &mut String {
        self.trailing_comments
            .get_or_insert_with(|| String::default())
    }
    pub fn clear_trailing_comments(&mut self) {
        self.trailing_comments = None;
    }

    pub fn leading_detached_comments(&self) -> &[String] {
        &self.leading_detached_comments
    }

    pub fn leading_detached_comments_mut(&mut self) -> &mut [String] {
        &mut self.leading_detached_comments
    }

    pub fn leading_detached_comments_len(&self) -> usize {
        self.leading_detached_comments.len()
    }
    pub fn add_leading_detached_comments(&mut self, v: String) -> &mut String {
        self.leading_detached_comments.push(v);
        self.leading_detached_comments.last_mut().unwrap()
    }
    pub fn clear_leading_detached_comments(&mut self) {
        self.leading_detached_comments.clear();
    }
}

impl protobuf_core::Message for SourceCodeInfo_Location {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo.Location"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => {
                    self.path.push(f.parse_int32()?);
                }
                2 => {
                    self.span.push(f.parse_int32()?);
                }
                3 => self.leading_comments = Some(f.parse_string()?),
                4 => self.trailing_comments = Some(f.parse_string()?),
                6 => {
                    self.leading_detached_comments.push(f.parse_string()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.path.iter() {
            WireField::serialize_int32(1, *v, &mut data)?;
        }
        for v in self.span.iter() {
            WireField::serialize_int32(2, *v, &mut data)?;
        }
        if let Some(v) = self.leading_comments.as_ref() {
            WireField::serialize_string(3, v, &mut data)?;
        }
        if let Some(v) = self.trailing_comments.as_ref() {
            WireField::serialize_string(4, v, &mut data)?;
        }
        for v in self.leading_detached_comments.iter() {
            WireField::serialize_string(6, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for SourceCodeInfo_Location {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("path"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("span"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("leading_comments"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("trailing_comments"),
                number: 4,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("leading_detached_comments"),
                number: 6,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.path.reflect(),
            2 => self.span.reflect(),
            3 => self.leading_comments.reflect(),
            4 => self.trailing_comments.reflect(),
            6 => self.leading_detached_comments.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.path.reflect_mut(),
            2 => self.span.reflect_mut(),
            3 => self.leading_comments.reflect_mut(),
            4 => self.trailing_comments.reflect_mut(),
            6 => self.leading_detached_comments.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "path" => 1,
            "span" => 2,
            "leading_comments" => 3,
            "trailing_comments" => 4,
            "leading_detached_comments" => 6,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct SourceCodeInfo {
    location: Vec<SourceCodeInfo_Location>,
}

impl SourceCodeInfo {
    pub fn static_default_value() -> &'static Self {
        static VALUE: SourceCodeInfo = SourceCodeInfo::DEFAULT;
        &VALUE
    }

    pub fn location(&self) -> &[SourceCodeInfo_Location] {
        &self.location
    }

    pub fn location_mut(&mut self) -> &mut [SourceCodeInfo_Location] {
        &mut self.location
    }

    pub fn location_len(&self) -> usize {
        self.location.len()
    }
    pub fn add_location(&mut self, v: SourceCodeInfo_Location) -> &mut SourceCodeInfo_Location {
        self.location.push(v);
        self.location.last_mut().unwrap()
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }
}

impl protobuf_core::Message for SourceCodeInfo {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.SourceCodeInfo"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => {
                    self.location.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.location.iter() {
            WireField::serialize_message(1, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for SourceCodeInfo {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("location"),
            number: 1,
        }]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.location.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.location.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "location" => 1,
            _ => {
                return None;
            }
        })
    }
}

#[derive(Clone, Default, Debug, ConstDefault)]
pub struct GeneratedCodeInfo_Annotation {
    path: Vec<i32>,
    source_file: Option<String>,
    begin: Option<i32>,
    end: Option<i32>,
}

impl GeneratedCodeInfo_Annotation {
    pub fn static_default_value() -> &'static Self {
        static VALUE: GeneratedCodeInfo_Annotation = GeneratedCodeInfo_Annotation::DEFAULT;
        &VALUE
    }

    pub fn path(&self) -> &[i32] {
        &self.path
    }

    pub fn path_mut(&mut self) -> &mut [i32] {
        &mut self.path
    }

    pub fn path_len(&self) -> usize {
        self.path.len()
    }
    pub fn add_path(&mut self, v: i32) -> &mut i32 {
        self.path.push(v);
        self.path.last_mut().unwrap()
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn source_file(&self) -> &str {
        self.source_file.as_ref().map(|v| v.as_ref()).unwrap_or("")
    }
    pub fn has_source_file(&self) -> bool {
        self.source_file.is_some()
    }
    pub fn set_source_file<V: ::std::convert::Into<String>>(&mut self, v: V) {
        let v = v.into();
        self.source_file = Some(v);
    }
    pub fn source_file_mut(&mut self) -> &mut String {
        self.source_file.get_or_insert_with(|| String::default())
    }
    pub fn clear_source_file(&mut self) {
        self.source_file = None;
    }

    pub fn begin(&self) -> i32 {
        self.begin.unwrap_or_default()
    }
    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }
    pub fn set_begin<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.begin = Some(v);
    }
    pub fn begin_mut(&mut self) -> &mut i32 {
        self.begin.get_or_insert_with(|| i32::default())
    }
    pub fn clear_begin(&mut self) {
        self.begin = None;
    }

    pub fn end(&self) -> i32 {
        self.end.unwrap_or_default()
    }
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    pub fn set_end<V: ::std::convert::Into<i32>>(&mut self, v: V) {
        let v = v.into();
        self.end = Some(v);
    }
    pub fn end_mut(&mut self) -> &mut i32 {
        self.end.get_or_insert_with(|| i32::default())
    }
    pub fn clear_end(&mut self) {
        self.end = None;
    }
}

impl protobuf_core::Message for GeneratedCodeInfo_Annotation {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo.Annotation"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => {
                    self.path.push(f.parse_int32()?);
                }
                2 => self.source_file = Some(f.parse_string()?),
                3 => self.begin = Some(f.parse_int32()?),
                4 => self.end = Some(f.parse_int32()?),
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.path.iter() {
            WireField::serialize_int32(1, *v, &mut data)?;
        }
        if let Some(v) = self.source_file.as_ref() {
            WireField::serialize_string(2, v, &mut data)?;
        }
        if let Some(v) = self.begin.as_ref() {
            WireField::serialize_int32(3, *v, &mut data)?;
        }
        if let Some(v) = self.end.as_ref() {
            WireField::serialize_int32(4, *v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for GeneratedCodeInfo_Annotation {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("path"),
                number: 1,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("source_file"),
                number: 2,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("begin"),
                number: 3,
            },
            protobuf_core::FieldDescriptorShort {
                name: protobuf_core::StringPtr::Static("end"),
                number: 4,
            },
        ]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.path.reflect(),
            2 => self.source_file.reflect(),
            3 => self.begin.reflect(),
            4 => self.end.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.path.reflect_mut(),
            2 => self.source_file.reflect_mut(),
            3 => self.begin.reflect_mut(),
            4 => self.end.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "path" => 1,
            "source_file" => 2,
            "begin" => 3,
            "end" => 4,
            _ => {
                return None;
            }
        })
    }
}
#[derive(Clone, Default, Debug, ConstDefault)]
pub struct GeneratedCodeInfo {
    annotation: Vec<GeneratedCodeInfo_Annotation>,
}

impl GeneratedCodeInfo {
    pub fn static_default_value() -> &'static Self {
        static VALUE: GeneratedCodeInfo = GeneratedCodeInfo::DEFAULT;
        &VALUE
    }

    pub fn annotation(&self) -> &[GeneratedCodeInfo_Annotation] {
        &self.annotation
    }

    pub fn annotation_mut(&mut self) -> &mut [GeneratedCodeInfo_Annotation] {
        &mut self.annotation
    }

    pub fn annotation_len(&self) -> usize {
        self.annotation.len()
    }
    pub fn add_annotation(
        &mut self,
        v: GeneratedCodeInfo_Annotation,
    ) -> &mut GeneratedCodeInfo_Annotation {
        self.annotation.push(v);
        self.annotation.last_mut().unwrap()
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }
}

impl protobuf_core::Message for GeneratedCodeInfo {
    fn type_url(&self) -> &'static str {
        "type.googleapis.com/google.protobuf.GeneratedCodeInfo"
    }

    fn file_descriptor() -> &'static protobuf_core::StaticFileDescriptor {
        &FILE_DESCRIPTOR
    }

    fn parse(data: &[u8]) -> Result<Self> {
        let mut msg = Self::default();
        msg.parse_merge(data)?;
        Ok(msg)
    }

    fn parse_merge(&mut self, data: &[u8]) -> Result<()> {
        for f in WireFieldIter::new(data) {
            let f = f?;
            match f.field_number {
                1 => {
                    self.annotation.push(f.parse_message()?);
                }
                _ => {}
            }
        }
        Ok(())
    }
    fn serialize(&self) -> Result<Vec<u8>> {
        let mut data = vec![];
        for v in self.annotation.iter() {
            WireField::serialize_message(1, v, &mut data)?;
        }
        Ok(data)
    }
}

impl protobuf_core::MessageReflection for GeneratedCodeInfo {
    fn fields(&self) -> &[protobuf_core::FieldDescriptorShort] {
        &[protobuf_core::FieldDescriptorShort {
            name: protobuf_core::StringPtr::Static("annotation"),
            number: 1,
        }]
    }
    fn field_by_number(&self, num: FieldNumber) -> Option<Reflection> {
        match num {
            1 => self.annotation.reflect(),
            _ => None,
        }
    }

    fn field_by_number_mut(&mut self, num: FieldNumber) -> Option<ReflectionMut> {
        Some(match num {
            1 => self.annotation.reflect_mut(),
            _ => {
                return None;
            }
        })
    }

    fn field_number_by_name(&self, name: &str) -> Option<FieldNumber> {
        Some(match name {
            "annotation" => 1,
            _ => {
                return None;
            }
        })
    }
}
